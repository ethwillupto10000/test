
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':8089/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.head.appendChild(r) })(window.document);
var NGR = (function (exports) {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics$1 = function(d, b) {
        extendStatics$1 = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics$1(d, b);
    };

    function __extends$1(d, b) {
        extendStatics$1(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$1 = function() {
        __assign$1 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    function isString$1(str) {
        return typeof str === 'string';
    }
    function isFunction$1(fun) {
        return typeof fun === 'function';
    }
    var defaultOptions$d = {
        order: 0,
        type: 'bottom',
    };
    var NCore$1 = (function () {
        function NCore() {
            this._listeners = {};
            this._onetimeListeners = {};
        }
        NCore.getIndexByOrder = function (arr, options) {
            for (var i = 0; i < arr.length; i += 1) {
                if (options.type === 'top') {
                    if (arr[i].order <= options.order) {
                        return i;
                    }
                }
                else {
                    if (arr[i].order < options.order) {
                        return i;
                    }
                }
            }
            return arr.length;
        };
        NCore.prototype.on = function (type, listener, options) {
            if (!isString$1(type) || !isFunction$1(listener)) {
                console.warn('on: expect on(type: string, listener: Function)');
                return this;
            }
            var arr = this._listeners[type];
            var opts = __assign$1(__assign$1({}, defaultOptions$d), options);
            if (arr) {
                var index = NCore.getIndexByOrder(arr, opts);
                arr.splice(index, 0, { callback: listener, order: opts.order });
            }
            else {
                this._listeners[type] = [{
                        callback: listener,
                        order: opts.order,
                    }];
            }
            return this;
        };
        NCore.prototype.once = function (type, listener, options) {
            if (!isString$1(type) || !isFunction$1(listener)) {
                console.warn('once: expect on(type: string, listener: Function)');
                return this;
            }
            var arr = this._onetimeListeners[type];
            var opts = __assign$1(__assign$1({}, defaultOptions$d), options);
            if (arr) {
                var index = NCore.getIndexByOrder(arr, opts);
                arr.splice(index, 0, { callback: listener, order: opts.order });
            }
            else {
                this._onetimeListeners[type] = [{
                        callback: listener,
                        order: opts.order,
                    }];
            }
            return this;
        };
        NCore.prototype.off = function (type, listener) {
            if (!isString$1(type) || !isFunction$1(listener)) {
                console.warn('off: expect on(type: string, listener: Function)');
                return this;
            }
            var arr = this._listeners[type] || [];
            for (var i = arr.length - 1; i >= 0; i -= 1) {
                if (arr[i].callback === listener) {
                    arr.splice(i, 1);
                }
            }
            arr.length === 0 && delete this._listeners[type];
            var onetimeArr = this._onetimeListeners[type] || [];
            for (var i = onetimeArr.length - 1; i >= 0; i -= 1) {
                if (onetimeArr[i].callback === listener) {
                    onetimeArr.splice(i, 1);
                }
            }
            onetimeArr.length === 0 && delete this._onetimeListeners[type];
            return this;
        };
        NCore.prototype.fire = function (type, eventData) {
            var arr = Array.from(this._listeners[type] || []);
            for (var i = 0; i < arr.length; i += 1) {
                arr[i].callback(eventData);
            }
            var onetimeArr = Array.from(this._onetimeListeners[type] || []);
            for (var i = 0; i < onetimeArr.length; i += 1) {
                onetimeArr[i].callback(eventData);
            }
            delete this._onetimeListeners[type];
            return this;
        };
        NCore.prototype.clearRegister = function () {
            this._listeners = {};
            this._onetimeListeners = {};
        };
        NCore.prototype.getListeners = function (type) {
            return this._listeners[type] || this._onetimeListeners[type];
        };
        return NCore;
    }());

    function easeInQuad(x) {
        return x * x;
    }
    function easeOutQuad(x) {
        return 1 - (1 - x) * (1 - x);
    }
    function easeInOutQuad(x) {
        return x < 0.5 ?
            2 * x * x :
            1 - Math.pow(-2 * x + 2, 2) / 2;
    }
    function easeOutQuart(x) {
        return 1 - Math.pow(1 - x, 4);
    }
    function linear(x) {
        return x;
    }
    function easeOutCirc(x) {
        return Math.sqrt(1 - Math.pow(x - 1, 2));
    }
    function easeInSine(x) {
        return 1 - Math.cos(x * Math.PI / 2);
    }
    function easeOutSine(x) {
        return Math.sin(x * Math.PI / 2);
    }
    function easeInOutSine(x) {
        return -0.5 * (Math.cos(Math.PI * x) - 1);
    }
    var animateFunction = {
        easeInQuad: easeInQuad,
        easeOutQuad: easeOutQuad,
        easeOutQuart: easeOutQuart,
        easeInOutQuad: easeInOutQuad,
        linear: linear,
        easeOutCirc: easeOutCirc,
        easeInSine: easeInSine,
        easeOutSine: easeOutSine,
        easeInOutSine: easeInOutSine,
    };

    function bindAll(arr, context) {
        for (var i = 0; i < arr.length; i += 1) {
            if (context[arr[i]]) {
                context[arr[i]] = context[arr[i]].bind(context);
            }
        }
    }
    function createRect(point, width, height, anchor) {
        if (anchor === void 0) { anchor = 'center'; }
        var AnchorMap = {
            center: [0.5, 0.5],
            top: [0.5, 1],
            bottom: [0.5, 0],
            left: [0, 0.5],
            right: [1, 0.5],
            'top-left': [0, 1],
            'top-right': [1, 1],
            'bottom-left': [0, 0],
            'bottom-right': [1, 0],
        };
        var anchorArr = AnchorMap[anchor] || [0.5, 0.5];
        return [
            point[0] - anchorArr[0] * width, point[1] + (1 - anchorArr[1]) * height,
            point[0] - anchorArr[0] * width, point[1] - anchorArr[1] * height,
            point[0] + (1 - anchorArr[0]) * width, point[1] + (1 - anchorArr[1]) * height,
            point[0] + (1 - anchorArr[0]) * width, point[1] - anchorArr[1] * height,
        ];
    }
    function createScreenBounds(point, width, height, anchor) {
        if (anchor === void 0) { anchor = 'center'; }
        var AnchorMap = {
            center: [0.5, 0.5],
            top: [0.5, 0],
            bottom: [0.5, 1],
            left: [0, 0.5],
            right: [1, 0.5],
            'top-left': [0, 0],
            'top-right': [1, 0],
            'bottom-left': [0, 1],
            'bottom-right': [1, 1],
        };
        var anchorArr = AnchorMap[anchor] || [0.5, 0.5];
        return {
            leftBottom: [
                point[0] - anchorArr[0] * width, point[1] - anchorArr[1] * height,
            ],
            rightTop: [
                point[0] + (1 - anchorArr[0]) * width, point[1] + (1 - anchorArr[1]) * height,
            ],
        };
    }
    function createPointGeometry(point, width, height, anchor) {
        var vertices = createRect(point, width, height, anchor);
        var texCoords = [0, 1, 0, 0, 1, 1, 1, 0];
        return { vertices: vertices, texCoords: texCoords };
    }
    function createFeaturePoint(point, properties) {
        return {
            type: 'Feature',
            properties: properties,
            geometry: {
                type: 'Point',
                coordinates: point,
            },
        };
    }
    function sleep(ms) {
        if (ms === void 0) { ms = 0; }
        return new Promise(function (resolve) {
            setTimeout(resolve, ms);
        });
    }
    function clamp(num, min, max) {
        return num < min ? min : (num < max ? num : max);
    }
    function mergeArray(arr, l, m, r, cb) {
        var i = l, j = m + 1;
        var temp = [];
        while (i <= m && j <= r) {
            if (cb(arr[i], arr[j]) > 0) {
                temp.push(arr[j]);
                j += 1;
            }
            else {
                temp.push(arr[i]);
                i += 1;
            }
        }
        while (i <= m) {
            temp.push(arr[i]);
            i += 1;
        }
        while (j <= r) {
            temp.push(arr[j]);
            j += 1;
        }
        for (var i_1 = 0; i_1 < temp.length; i_1 += 1) {
            arr[l + i_1] = temp[i_1];
        }
    }
    function mergeSort(arr, l, r, cb) {
        if (l < r) {
            var m = Math.floor((l + r) / 2);
            mergeSort(arr, l, m, cb);
            mergeSort(arr, m + 1, r, cb);
            mergeArray(arr, l, m, r, cb);
        }
    }
    function sort(arr, callback) {
        mergeSort(arr, 0, arr.length - 1, callback);
    }
    function filter(arr, filterArr) {
        var set = new Set(filterArr);
        var result = [];
        var filterResult = [];
        for (var i = 0; i < arr.length; i += 1) {
            set.has(arr[i]) ? filterResult.push(arr[i]) : result.push(arr[i]);
        }
        return { result: result, filterResult: filterResult };
    }
    function equalObject(obj1, obj2) {
        if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
            return obj1 === obj2;
        }
        if (Object.keys(obj1).length !== Object.keys(obj2).length) {
            return false;
        }
        for (var key in obj1) {
            if (obj1[key] instanceof Object && obj2[key] instanceof Object) {
                var flag = equalObject(obj1[key], obj2[key]);
                if (!flag)
                    return false;
            }
            else if (obj1[key] !== obj2[key]) {
                return false;
            }
        }
        return true;
    }
    function step(arr, step, callback) {
        var num = Math.ceil(arr.length / step);
        for (var i = 0; i < num; i += 1) {
            var start = i * step;
            var end = Math.min((i + 1) * step, arr.length);
            callback(arr.slice(start, end));
        }
    }
    function getMinMax(points) {
        var minX = points[0].x, maxX = points[0].x;
        var minY = points[0].y, maxY = points[0].y;
        for (var i = 1; i < points.length; i += 1) {
            if (points[i].x > maxX) {
                maxX = points[i].x;
            }
            if (points[i].x < minX) {
                minX = points[i].x;
            }
            if (points[i].y > maxY) {
                maxY = points[i].y;
            }
            if (points[i].y < minY) {
                minY = points[i].y;
            }
        }
        return { minX: minX, minY: minY, maxX: maxX, maxY: maxY };
    }

    var UTILS = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bindAll: bindAll,
        createRect: createRect,
        createScreenBounds: createScreenBounds,
        createPointGeometry: createPointGeometry,
        createFeaturePoint: createFeaturePoint,
        sleep: sleep,
        clamp: clamp,
        sort: sort,
        filter: filter,
        equalObject: equalObject,
        step: step,
        getMinMax: getMinMax
    });

    var Animator = (function (_super) {
        __extends$1(Animator, _super);
        function Animator() {
            var _this = _super.call(this) || this;
            _this._current = {};
            _this._startTimestamp = 0;
            _this._duration = 0;
            _this._progress = 0;
            _this._easingFun = animateFunction.linear;
            _this._isUpdateSpeed = false;
            bindAll([
                '_updateFrame',
            ], _this);
            return _this;
        }
        Animator.prototype.ofNumber = function (start, end, duration) {
            this._start = { num: start };
            this._end = { num: end };
            this._duration = duration;
            return this;
        };
        Animator.prototype.ofObject = function (start, end, duration) {
            this._start = __assign$1({}, start);
            this._end = __assign$1({}, end);
            this._duration = duration;
            return this;
        };
        Animator.prototype.start = function () {
            if (this._timer)
                return;
            this.fire('start', __assign$1({}, this._start));
            this._current = __assign$1({}, this._start);
            this.play(false);
            return this;
        };
        Animator.prototype._updateFrame = function () {
            if (!this._start || !this._end)
                return;
            this._progress = (performance.now() - this._startTimestamp) / this._duration;
            if (this._progress >= 1) {
                this._current = __assign$1({}, this._end);
                this.fire('update', this._current);
                this._complete();
            }
            else {
                this._timer = requestAnimationFrame(this._updateFrame);
                var percent = this._easingFun(this._progress);
                for (var key in this._current) {
                    var step = this._end[key] - this._start[key];
                    this._current[key] = this._start[key] + step * percent;
                }
                if (!this._isUpdateSpeed) {
                    this.fire('update', this._current);
                }
                else {
                    this.fire('changeSpeed', this._current);
                }
            }
        };
        Animator.prototype.pause = function () {
            this._stopFrameUpdate();
        };
        Animator.prototype.play = function (isUpdateSpeed) {
            this._isUpdateSpeed = isUpdateSpeed;
            if (this._timer || !this._current || this._progress >= 1)
                return;
            if (this._duration <= 0) {
                this._current = __assign$1({}, this._end);
                this.fire('update', this._current);
                this._complete();
            }
            else {
                this._startTimestamp = performance.now() - this._progress * this._duration;
                this._timer = requestAnimationFrame(this._updateFrame);
            }
        };
        Animator.prototype.stop = function () {
            this._stopFrameUpdate();
            this.clearRegister();
            this.fire('stop', __assign$1({}, this._current));
        };
        Animator.prototype._complete = function () {
            this._stopFrameUpdate();
            this.fire('complete', this._current);
        };
        Animator.prototype._stopFrameUpdate = function () {
            this._startTimestamp = 0;
            if (this._timer) {
                cancelAnimationFrame(this._timer);
                delete this._timer;
            }
        };
        Animator.prototype.easing = function (name) {
            this._easingFun = animateFunction[name];
            return this;
        };
        return Animator;
    }(NCore$1));

    var Matrix4$1 = (function () {
        function Matrix4(value) {
            this._value = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            if (value) {
                for (var i = 0; i < value.length; i += 1) {
                    this._value[i] = value[i];
                }
            }
        }
        Matrix4.prototype.setIdentity = function () {
            var e = this._value;
            e[0] = 1;
            e[4] = 0;
            e[8] = 0;
            e[12] = 0;
            e[1] = 0;
            e[5] = 1;
            e[9] = 0;
            e[13] = 0;
            e[2] = 0;
            e[6] = 0;
            e[10] = 1;
            e[14] = 0;
            e[3] = 0;
            e[7] = 0;
            e[11] = 0;
            e[15] = 1;
            return this;
        };
        Matrix4.prototype.multiply = function (other) {
            var i, e, a, b, ai0, ai1, ai2, ai3;
            e = this._value;
            a = this._value;
            b = other._value;
            if (e === b) {
                b = [];
                for (i = 0; i < 16; ++i) {
                    b[i] = e[i];
                }
            }
            for (i = 0; i < 4; i++) {
                ai0 = a[i];
                ai1 = a[i + 4];
                ai2 = a[i + 8];
                ai3 = a[i + 12];
                e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
                e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
                e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
                e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
            }
            return this;
        };
        Matrix4.prototype.transpose = function () {
            var e, t;
            e = this._value;
            t = e[1];
            e[1] = e[4];
            e[4] = t;
            t = e[2];
            e[2] = e[8];
            e[8] = t;
            t = e[3];
            e[3] = e[12];
            e[12] = t;
            t = e[6];
            e[6] = e[9];
            e[9] = t;
            t = e[7];
            e[7] = e[13];
            e[13] = t;
            t = e[11];
            e[11] = e[14];
            e[14] = t;
            return this;
        };
        Matrix4.prototype.invert = function () {
            var i, s, d, inv, det;
            s = this._value;
            d = this._value;
            inv = [];
            inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15]
                + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];
            inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15]
                - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];
            inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15]
                + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];
            inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14]
                - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];
            inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15]
                - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];
            inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15]
                + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];
            inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15]
                - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];
            inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14]
                + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];
            inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15]
                + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];
            inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15]
                - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];
            inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15]
                + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];
            inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14]
                - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];
            inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11]
                - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];
            inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11]
                + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];
            inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11]
                - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];
            inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10]
                + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];
            det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];
            if (det === 0) {
                return this;
            }
            det = 1 / det;
            for (i = 0; i < 16; i++) {
                d[i] = inv[i] * det;
            }
            return this;
        };
        Matrix4.prototype.setOrtho = function (left, right, bottom, top, near, far) {
            var e, rw, rh, rd;
            if (left === right || bottom === top || near === far) {
                throw 'null frustum';
            }
            rw = 1 / (right - left);
            rh = 1 / (top - bottom);
            rd = 1 / (far - near);
            e = this._value;
            e[0] = 2 * rw;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 0;
            e[5] = 2 * rh;
            e[6] = 0;
            e[7] = 0;
            e[8] = 0;
            e[9] = 0;
            e[10] = -2 * rd;
            e[11] = 0;
            e[12] = -(right + left) * rw;
            e[13] = -(top + bottom) * rh;
            e[14] = -(far + near) * rd;
            e[15] = 1;
            return this;
        };
        Matrix4.prototype.setFrustum = function (left, right, bottom, top, near, far) {
            var e, rw, rh, rd;
            if (left === right || top === bottom || near === far) {
                throw 'null frustum';
            }
            if (near <= 0) {
                throw 'near <= 0';
            }
            if (far <= 0) {
                throw 'far <= 0';
            }
            rw = 1 / (right - left);
            rh = 1 / (top - bottom);
            rd = 1 / (far - near);
            e = this._value;
            e[0] = 2 * near * rw;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 0;
            e[5] = 2 * near * rh;
            e[6] = 0;
            e[7] = 0;
            e[8] = (right + left) * rw;
            e[9] = (top + bottom) * rh;
            e[10] = -(far + near) * rd;
            e[11] = -1;
            e[12] = 0;
            e[13] = 0;
            e[14] = -2 * near * far * rd;
            e[15] = 0;
            return this;
        };
        Matrix4.prototype.setPerspective = function (fovy, aspect, near, far) {
            var e, rd, s, ct;
            if (near === far || aspect === 0) {
                throw 'null frustum';
            }
            if (near <= 0) {
                throw 'near <= 0';
            }
            if (far <= 0) {
                throw 'far <= 0';
            }
            fovy = Math.PI * fovy / 180 / 2;
            s = Math.sin(fovy);
            if (s === 0) {
                throw 'null frustum';
            }
            rd = 1 / (far - near);
            ct = Math.cos(fovy) / s;
            e = this._value;
            e[0] = ct / aspect;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 0;
            e[5] = ct;
            e[6] = 0;
            e[7] = 0;
            e[8] = 0;
            e[9] = 0;
            e[10] = -(far + near) * rd;
            e[11] = -1;
            e[12] = 0;
            e[13] = 0;
            e[14] = -2 * near * far * rd;
            e[15] = 0;
            return this;
        };
        Matrix4.prototype.scale = function (x, y, z) {
            var e = this._value;
            e[0] *= x;
            e[4] *= y;
            e[8] *= z;
            e[1] *= x;
            e[5] *= y;
            e[9] *= z;
            e[2] *= x;
            e[6] *= y;
            e[10] *= z;
            e[3] *= x;
            e[7] *= y;
            e[11] *= z;
            return this;
        };
        Matrix4.prototype.translate = function (x, y, z) {
            var e = this._value;
            e[12] += e[0] * x + e[4] * y + e[8] * z;
            e[13] += e[1] * x + e[5] * y + e[9] * z;
            e[14] += e[2] * x + e[6] * y + e[10] * z;
            e[15] += e[3] * x + e[7] * y + e[11] * z;
            return this;
        };
        Matrix4.prototype.rotate = function (angle, x, y, z) {
            var len = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
            if (len === 0)
                return this;
            var rad = angle / 180 * Math.PI;
            var a = this._value;
            var s, c, t;
            var a00, a01, a02, a03;
            var a10, a11, a12, a13;
            var a20, a21, a22, a23;
            var b00, b01, b02;
            var b10, b11, b12;
            var b20, b21, b22;
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
            s = Math.sin(rad);
            c = Math.cos(rad);
            t = 1 - c;
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            b00 = x * x * t + c;
            b01 = y * x * t + z * s;
            b02 = z * x * t - y * s;
            b10 = x * y * t - z * s;
            b11 = y * y * t + c;
            b12 = z * y * t + x * s;
            b20 = x * z * t + y * s;
            b21 = y * z * t - x * s;
            b22 = z * z * t + c;
            a[0] = a00 * b00 + a10 * b01 + a20 * b02;
            a[1] = a01 * b00 + a11 * b01 + a21 * b02;
            a[2] = a02 * b00 + a12 * b01 + a22 * b02;
            a[3] = a03 * b00 + a13 * b01 + a23 * b02;
            a[4] = a00 * b10 + a10 * b11 + a20 * b12;
            a[5] = a01 * b10 + a11 * b11 + a21 * b12;
            a[6] = a02 * b10 + a12 * b11 + a22 * b12;
            a[7] = a03 * b10 + a13 * b11 + a23 * b12;
            a[8] = a00 * b20 + a10 * b21 + a20 * b22;
            a[9] = a01 * b20 + a11 * b21 + a21 * b22;
            a[10] = a02 * b20 + a12 * b21 + a22 * b22;
            a[11] = a03 * b20 + a13 * b21 + a23 * b22;
            return this;
        };
        Matrix4.prototype.setLookAt = function (eye, center, up) {
            if (eye.length !== 3 || center.length !== 3 || up.length !== 3) {
                console.error('鏁版嵁鏍煎紡閿欒');
                return this;
            }
            var eyeX = eye[0], eyeY = eye[1], eyeZ = eye[2];
            var centerX = center[0], centerY = center[1], centerZ = center[2];
            var upX = up[0], upY = up[1], upZ = up[2];
            var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;
            fx = centerX - eyeX;
            fy = centerY - eyeY;
            fz = centerZ - eyeZ;
            rlf = 1 / Math.sqrt(fx * fx + fy * fy + fz * fz);
            fx *= rlf;
            fy *= rlf;
            fz *= rlf;
            sx = fy * upZ - fz * upY;
            sy = fz * upX - fx * upZ;
            sz = fx * upY - fy * upX;
            rls = 1 / Math.sqrt(sx * sx + sy * sy + sz * sz);
            sx *= rls;
            sy *= rls;
            sz *= rls;
            ux = sy * fz - sz * fy;
            uy = sz * fx - sx * fz;
            uz = sx * fy - sy * fx;
            e = this._value;
            e[0] = sx;
            e[1] = ux;
            e[2] = -fx;
            e[3] = 0;
            e[4] = sy;
            e[5] = uy;
            e[6] = -fy;
            e[7] = 0;
            e[8] = sz;
            e[9] = uz;
            e[10] = -fz;
            e[11] = 0;
            e[12] = 0;
            e[13] = 0;
            e[14] = 0;
            e[15] = 1;
            this.translate(-eyeX, -eyeY, -eyeZ);
            return this;
        };
        Matrix4.prototype.dropShadow = function (plane, light) {
            var mat = new Matrix4();
            var e = mat._value;
            var dot = plane[0] * light[0] + plane[1] * light[1] + plane[2] * light[2] + plane[3] * light[3];
            e[0] = dot - light[0] * plane[0];
            e[1] = -light[1] * plane[0];
            e[2] = -light[2] * plane[0];
            e[3] = -light[3] * plane[0];
            e[4] = -light[0] * plane[1];
            e[5] = dot - light[1] * plane[1];
            e[6] = -light[2] * plane[1];
            e[7] = -light[3] * plane[1];
            e[8] = -light[0] * plane[2];
            e[9] = -light[1] * plane[2];
            e[10] = dot - light[2] * plane[2];
            e[11] = -light[3] * plane[2];
            e[12] = -light[0] * plane[3];
            e[13] = -light[1] * plane[3];
            e[14] = -light[2] * plane[3];
            e[15] = dot - light[3] * plane[3];
            return this.multiply(mat);
        };
        Matrix4.prototype.getValue = function () {
            return this._value;
        };
        Matrix4.prototype.clone = function () {
            return new Matrix4(this._value);
        };
        Matrix4.prototype.makeRotationFromEuler = function (x, y, z, order) {
            if (x == null || y == null || z == null) {
                return;
            }
            var te = this._value;
            var a = Math.cos(x), b = Math.sin(x);
            var c = Math.cos(y), d = Math.sin(y);
            var e = Math.cos(z), f = Math.sin(z);
            if (order === 'XYZ') {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            }
            else if (order === 'YXZ') {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            }
            else if (order === 'ZXY') {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b;
                te[4] = -a * f;
                te[8] = de + cf * b;
                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
            }
            else if (order === 'ZYX') {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;
                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
            }
            else if (order === 'YZX') {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;
                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            }
            else if (order === 'XZY') {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;
                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;
                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;
            }
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        };
        return Matrix4;
    }());

    var Point = (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        Point.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        Point.prototype.add = function (point) {
            this.x += point.x;
            this.y += point.y;
            return this;
        };
        Point.prototype.subtract = function (point) {
            this.x -= point.x;
            this.y -= point.y;
            return this;
        };
        Point.prototype.divide = function (num) {
            this.x /= num;
            this.y /= num;
            return this;
        };
        Point.prototype.equal = function (point) {
            return this.x === point.x && this.y === point.y;
        };
        Point.prototype.clone = function () {
            return new Point(this.x, this.y);
        };
        Point.prototype.distanceTo = function (point) {
            return Math.sqrt(Math.pow((this.x - point.x), 2) + Math.pow((this.y - point.y), 2));
        };
        Point.prototype.rotate = function (angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var x = cos * this.x - sin * this.y;
            var y = sin * this.x + cos * this.y;
            this.x = x;
            this.y = y;
            return this;
        };
        Point.prototype.multiply = function (num) {
            this.x *= num;
            this.y *= num;
            return this;
        };
        Point.prototype.getLength = function () {
            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
        };
        Point.prototype.floor = function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        };
        Point.prototype.ceil = function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        };
        Point.prototype.round = function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        };
        return Point;
    }());

    var Vector4 = (function () {
        function Vector4(start, end) {
            if (end) {
                this.x = end[0] - start[0];
                this.y = end[1] - start[1];
                this.z = end[2] - start[2];
                this.w = end[3] - start[3];
            }
            else {
                this.x = start[0];
                this.y = start[1];
                this.z = start[2];
                this.w = start[3];
            }
        }
        Vector4.prototype.unit = function () {
            var len = this.getLength();
            return new Vector4([this.x / len, this.y / len, this.z / len, this.w / len]);
        };
        Vector4.prototype.divide = function (num) {
            this.x /= num;
            this.y /= num;
            this.z /= num;
            this.w /= num;
            return this;
        };
        Vector4.prototype.getLength = function () {
            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2) + Math.pow(this.w, 2));
        };
        Vector4.prototype.multiplyMat4 = function (matrix) {
            var m = matrix.getValue();
            var x = this.x;
            var y = this.y;
            var z = this.z;
            var w = this.w;
            var resultX = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
            var resultY = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
            var resultZ = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
            var resultW = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
            return new Vector4([resultX, resultY, resultZ, resultW]);
        };
        Vector4.prototype.clone = function () {
            return new Vector4([this.x, this.y, this.z, this.w]);
        };
        Vector4.prototype.subtract = function (other) {
            this.x -= other.x;
            this.y -= other.y;
            this.z -= other.z;
            this.w -= other.w;
        };
        return Vector4;
    }());

    function rodrigo(t, k, r) {
        var u = t[0], v = t[1], w = t[2];
        var x = k[0], y = k[1], z = k[2];
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        var m = (x * u + y * v + z * w) * (1 - cos);
        var result = [
            u * cos + (y * w - z * v) * sin + x * m,
            v * cos + (z * u - x * w) * sin + y * m,
            w * cos + (x * v - y * u) * sin + z * m,
        ];
        return result;
    }

    var AbstractCamera = (function () {
        function AbstractCamera(width, height) {
            this._viewMatrix = new Matrix4$1();
            this._projectionMatrix = new Matrix4$1();
            this._pixelMatrix = new Matrix4$1();
            this._pixelInvertMatrix = new Matrix4$1();
            this._tileMatrix = new Matrix4$1();
            this._tileSize = 256;
            this._far = 20000;
            this._fov = 36.86989764584402;
            this._near = 0.5;
            this._center = new Point(0, 0);
            this._zoom = 10;
            this._pitch = 0;
            this._rotate = 0;
            this._z = 0;
            this._target = [0, 0, 0];
            this._eye = [0, 0, 0];
            this._up = [0, 0, 0];
            this._offset = [0, 0];
            this._width = width;
            this._height = height;
            var tan = 2 * Math.tan(this._fov / 2 / 180 * Math.PI);
            this._NATIVE_ZOOM = Math.log2(this._height * 1.1943285669940151 / tan) + 16;
            this._tileRatio = tan * this._tileSize / this._height;
            this._calcProjectionMatrix();
        }
        AbstractCamera.prototype.GetMVP = function () {
            return this._projectionMatrix.clone().multiply(this._viewMatrix);
        };
        AbstractCamera.prototype.getTileRatio = function () {
            return this._tileRatio;
        };
        AbstractCamera.prototype.getPixelRatioByZoom = function (zoom) {
            var focalLength = Math.pow(2, (this._NATIVE_ZOOM - zoom));
            var top = Math.tan(this._fov / 2 / 180 * Math.PI) * focalLength;
            return top * 2 / this._height;
        };
        AbstractCamera.prototype._calcProjectionMatrix = function () {
            this._far = 2E9;
            this._near = 2.0;
            this._projectionMatrix.setPerspective(this._fov, this._width / this._height, this._near, this._far);
        };
        AbstractCamera.prototype._calcViewMatrix = function () {
            var focalLength = Math.pow(2, (this._NATIVE_ZOOM - this._zoom));
            if (focalLength > this._far) {
                this._far = focalLength + 100;
                this._calcProjectionMatrix();
            }
            var center = { x: this._center.x + this._offset[0], y: this._center.y + this._offset[1] };
            var _a = AbstractCamera.calcEyeTargetUp(this._rotate, this._pitch, focalLength), eye = _a.eye, target = _a.target, up = _a.up;
            this._up = up;
            this._eye = [eye[0] + center.x, eye[1] + center.y, eye[2] + this._z];
            this._target = [target[0] + center.x, target[1] + center.y, target[2] + this._z];
            this._viewMatrix.setLookAt(this._eye, this._target, up);
            var matrix = new Matrix4$1();
            var tileView = AbstractCamera.calcEyeTargetUp(this._rotate, this._pitch, this._tileSize);
            matrix.setLookAt(tileView.eye, tileView.target, tileView.up);
            this._tileMatrix = this._projectionMatrix.clone().multiply(matrix);
            this._pixelMatrix = this._projectionMatrix.clone().multiply(this._viewMatrix);
            this._pixelInvertMatrix = this._pixelMatrix.clone().invert();
        };
        Object.defineProperty(AbstractCamera.prototype, "pixelMatrix", {
            get: function () {
                return this._pixelMatrix.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractCamera.prototype, "viewMatrix", {
            get: function () {
                return this._viewMatrix.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractCamera.prototype, "projectionMatrix", {
            get: function () {
                return this._projectionMatrix.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractCamera.prototype, "tileMatrix", {
            get: function () {
                return this._tileMatrix.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AbstractCamera.prototype, "centerPoint", {
            get: function () {
                return new Point(this._width / 2, this._height / 2);
            },
            enumerable: false,
            configurable: true
        });
        AbstractCamera.prototype.getCenter = function () {
            return this._center.clone();
        };
        AbstractCamera.prototype.getPitch = function () {
            return this._pitch;
        };
        AbstractCamera.prototype.getRotate = function () {
            return this._rotate;
        };
        AbstractCamera.prototype.getZoom = function () {
            return this._zoom;
        };
        AbstractCamera.prototype.getFov = function () {
            return this._fov;
        };
        AbstractCamera.prototype.getFar = function () {
            return this._far;
        };
        AbstractCamera.prototype.getNear = function () {
            return this._near;
        };
        AbstractCamera.prototype.getOffset = function () {
            return [this._offset[0], this._offset[1]];
        };
        AbstractCamera.prototype.setOffset = function (offset) {
            this._offset = offset;
            this._calcViewMatrix();
        };
        AbstractCamera.prototype.getZ = function () {
            return this._z;
        };
        AbstractCamera.prototype.setZ = function (z) {
            this._z = z;
            this._calcViewMatrix();
        };
        AbstractCamera.prototype.getEye = function () {
            return this._eye;
        };
        AbstractCamera.prototype.getTarget = function () {
            return this._target;
        };
        AbstractCamera.prototype.getUp = function () {
            return this._up;
        };
        AbstractCamera.prototype.getWidth = function () {
            return this._width;
        };
        AbstractCamera.prototype.getHeight = function () {
            return this._height;
        };
        AbstractCamera.prototype.worldToScreenCoordinate = function (worldX, worldY) {
            var point = new Vector4([worldX + this._offset[0], worldY + this._offset[1], this._z, 1]);
            var worldVector = point.multiplyMat4(this._pixelMatrix);
            var x = (worldVector.x + worldVector.w) / (worldVector.w * 2);
            var y = 1 - ((worldVector.y + worldVector.w) / (worldVector.w * 2));
            var screenX = x * this._width;
            var screenY = y * this._height;
            return new Point(screenX, screenY);
        };
        AbstractCamera.prototype.worldToScreenCoordinate2 = function (worldX, worldY, worldZ) {
            var point = new Vector4([worldX + this._offset[0], worldY + this._offset[1], worldZ, 1]);
            var worldVector = point.multiplyMat4(this._pixelMatrix);
            var x = (worldVector.x + worldVector.w) / (worldVector.w * 2);
            var y = 1 - ((worldVector.y + worldVector.w) / (worldVector.w * 2));
            var screenX = x * this._width;
            var screenY = y * this._height;
            return new Point(screenX, screenY);
        };
        AbstractCamera.prototype.screenToWorldCoordinate = function (screenX, screenY) {
            var tempTenWorldPoint = new Vector4([0, 0, -10, 1]);
            var tempOneWorldPoint = new Vector4([0, 0, -1, 1]);
            var _a = tempTenWorldPoint.multiplyMat4(this._projectionMatrix), tenProjZ = _a.z, tenProjW = _a.w;
            var _b = tempOneWorldPoint.multiplyMat4(this._projectionMatrix), oneProjZ = _b.z, oneProjW = _b.w;
            var halfWidth = this._width / 2;
            var halfHeight = this._height / 2;
            var tenProjX = (screenX - halfWidth) / halfWidth * tenProjW;
            var tenProjY = (halfHeight - screenY) / halfHeight * tenProjW;
            var tenProjPoint = new Vector4([tenProjX, tenProjY, tenProjZ, tenProjW]);
            var tenWorldPoint = tenProjPoint.multiplyMat4(this._pixelInvertMatrix);
            var oneProjX = (screenX - halfWidth) / halfWidth * oneProjW;
            var oneProjY = (halfHeight - screenY) / halfHeight * oneProjW;
            var oneProjPoint = new Vector4([oneProjX, oneProjY, oneProjZ, oneProjW]);
            var oneWorldPoint = oneProjPoint.multiplyMat4(this._pixelInvertMatrix);
            var resultX = (this._z - tenWorldPoint.z) * (tenWorldPoint.x - oneWorldPoint.x) / (tenWorldPoint.z - oneWorldPoint.z) + tenWorldPoint.x;
            var resultY = (this._z - tenWorldPoint.z) * (tenWorldPoint.y - oneWorldPoint.y) / (tenWorldPoint.z - oneWorldPoint.z) + tenWorldPoint.y;
            return new Point(resultX - this._offset[0], resultY - this._offset[1]);
        };
        AbstractCamera.calcEyeTargetUp = function (rotate, pitch, focalLength) {
            var target = [0, 0, 0];
            var p = -pitch / 180 * Math.PI;
            var r = -rotate / 180 * Math.PI;
            var k = [0, 0, 1];
            var vy = focalLength * Math.sin(p);
            var vz = focalLength * Math.cos(p);
            var eye = rodrigo([0, vy, vz], k, r);
            var up = rodrigo([0, vz, -vy], k, r);
            return { eye: eye, target: target, up: up };
        };
        AbstractCamera.processRotate = function (rotate) {
            var max = 180, min = -180;
            var d = max - min;
            var w = ((rotate - min) % d + d) % d + min;
            return (w === min) ? max : w;
        };
        AbstractCamera.processPitch = function (pitch) {
            if (pitch < AbstractCamera.MIN_PITCH) {
                return AbstractCamera.MIN_PITCH;
            }
            else if (pitch < AbstractCamera.MAX_PITCH) {
                return pitch;
            }
            return AbstractCamera.MAX_PITCH;
        };
        AbstractCamera.normalizeRotate = function (rotate, curRotate) {
            var result = AbstractCamera.processRotate(rotate);
            var diff = Math.abs(result - curRotate);
            if (Math.abs(result - 360 - curRotate) < diff) {
                result -= 360;
            }
            if (Math.abs(result + 360 - curRotate) < diff) {
                result += 360;
            }
            return result;
        };
        AbstractCamera.MIN_PITCH = 0;
        AbstractCamera.MAX_PITCH = 60;
        return AbstractCamera;
    }());

    var Camera = (function (_super) {
        __extends$1(Camera, _super);
        function Camera(width, height, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, width, height) || this;
            _this._onePixelToWorld = 0;
            _this._rotateMatrix = new Matrix4$1();
            _this._pitchMatrix = new Matrix4$1();
            _this._maxBounds = null;
            if (typeof options.zoom === 'number') {
                _this._zoom = options.zoom;
            }
            if (typeof options.rotate === 'number') {
                _this._rotate = options.rotate;
            }
            if (typeof options.pitch === 'number') {
                _this._pitch = Camera.processPitch(options.pitch);
            }
            _this._calcProjectionMatrix();
            _this._calcViewMatrix();
            _this._calcRotateMatrix();
            _this._calcOnePixelToWorld();
            _this._calcPitchMatrix();
            return _this;
        }
        Camera.prototype.setMaxBounds = function (maxBounds) {
            this._maxBounds = maxBounds;
            this._constrain();
        };
        Camera.prototype.getMaxBounds = function () {
            return this._maxBounds;
        };
        Camera.prototype.resize = function (width, height) {
            this._width = width;
            this._height = height;
            var tan = 2 * Math.tan(this._fov / 2 / 180 * Math.PI);
            this._NATIVE_ZOOM = Math.log2(this._height * 1.174 / tan) + 16;
            this._tileRatio = tan * this._tileSize / this._height;
            this._calcProjectionMatrix();
            this._calcViewMatrix();
            this._calcRotateMatrix();
            this._calcOnePixelToWorld();
            this._calcPitchMatrix();
        };
        Camera.prototype.set = function (params) {
            var zoom = params.zoom, rotate = params.rotate, pitch = params.pitch, center = params.center;
            if (typeof zoom === 'number' && zoom > 0) {
                this._zoom = zoom;
            }
            if (typeof rotate === 'number') {
                this._rotate = Camera.processRotate(rotate);
            }
            if (typeof pitch === 'number') {
                this._pitch = Camera.processPitch(pitch);
            }
            if (center) {
                this._center.set(center.x, center.y);
                this._constrain();
            }
            this._calcViewMatrix();
            zoom !== undefined && zoom > 0 && this._calcOnePixelToWorld();
            rotate !== undefined && this._calcRotateMatrix();
            pitch !== undefined && this._calcPitchMatrix();
        };
        Camera.prototype.setCenterAtPoint = function (coordinate, point) {
            var a = this.screenToWorldCoordinate(point.x, point.y);
            var x = coordinate.x - (a.x - this._center.x);
            var y = coordinate.y - (a.y - this._center.y);
            this._center.set(x, y);
            this._constrain();
            this._calcViewMatrix();
        };
        Object.defineProperty(Camera.prototype, "rotateMatrix", {
            get: function () {
                return this._rotateMatrix.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "pitchMatrix", {
            get: function () {
                return this._pitchMatrix.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Camera.prototype.getOnePixelToWorld = function () {
            return this._onePixelToWorld;
        };
        Camera.prototype._constrain = function () {
            var point = this._center;
            if (!this._maxBounds) {
                var yNum = 20037508.34 - this._height / 2 * this._onePixelToWorld;
                this._center.set(point.x, clamp(point.y, -yNum, yNum));
                return;
            }
            var w = this._width / 2 * this._onePixelToWorld;
            var h = this._height / 2 * this._onePixelToWorld;
            var minX = this._maxBounds.topLeft.x - w;
            var maxX = this._maxBounds.bottomRight.x + w;
            var minY = this._maxBounds.bottomRight.y - h;
            var maxY = this._maxBounds.topLeft.y + h;
            this._center.set(clamp(point.x, minX, maxX), clamp(point.y, minY, maxY));
        };
        Camera.prototype._calcPitchMatrix = function () {
            this._pitchMatrix = new Matrix4$1();
            this._pitchMatrix.rotate(this._pitch, 1, 0, 0);
        };
        Camera.prototype._calcRotateMatrix = function () {
            this._rotateMatrix = new Matrix4$1();
            this._rotateMatrix.rotate(-this._rotate, 0, 0, 1);
        };
        Camera.prototype._calcOnePixelToWorld = function () {
            this._onePixelToWorld = this.getPixelRatioByZoom(this._zoom);
        };
        Camera.prototype.getZ = function () {
            return this._z;
        };
        return Camera;
    }(AbstractCamera));

    var Program = (function () {
        function Program(gl, shaderSource) {
            this._attributes = new Map();
            this._uniforms = new Map();
            this._gl = gl;
            var program = gl.createProgram();
            if (!program) {
                throw new Error('gl: createProgram failed');
            }
            this._program = program;
            var vertex = shaderSource.vertex, fragment = shaderSource.fragment;
            this._initShader(this._gl.VERTEX_SHADER, vertex);
            this._initShader(this._gl.FRAGMENT_SHADER, fragment);
            this._gl.linkProgram(this._program);
        }
        Program.prototype._initShader = function (type, source) {
            var shader = this._gl.createShader(type);
            if (!shader) {
                console.error('Shader: createShader failed');
                return;
            }
            this._gl.shaderSource(shader, source);
            this._gl.compileShader(shader);
            this._gl.attachShader(this._program, shader);
        };
        Program.prototype.getAttribLocation = function (locationName) {
            if (this._attributes.has(locationName)) {
                return this._attributes.get(locationName);
            }
            var locationValue = this._gl.getAttribLocation(this._program, locationName);
            this._attributes.set(locationName, locationValue);
            return locationValue;
        };
        Program.prototype.getUniformLocation = function (locationName) {
            if (this._uniforms.has(locationName)) {
                return this._uniforms.get(locationName);
            }
            var locationValue = this._gl.getUniformLocation(this._program, locationName);
            locationValue && this._uniforms.set(locationName, locationValue);
            return locationValue;
        };
        Program.prototype.getProgram = function () {
            return this._program;
        };
        return Program;
    }());

    var fillExtrusionVertex = "precision highp float;attribute vec4 a_position;attribute vec2 a_texCoord;attribute vec4 a_normal;uniform bool u_drawLine;uniform float u_height;uniform float u_base;uniform mat4 u_viewMatrix;uniform mat4 u_projectionMatrix;uniform mat4 u_shadowMatrix;uniform vec4 u_color;uniform mat4 u_normalMatrix;uniform vec3 u_lightPos;uniform vec4 u_pointLightFactor;uniform vec3 u_pointLightPos1;uniform vec3 u_pointLightDiffuse1;uniform vec3 u_pointLightPos2;uniform vec3 u_pointLightDiffuse2;uniform vec3 u_pointLightPos3;uniform vec3 u_pointLightDiffuse3;uniform vec3 u_pointLightPos4;uniform vec3 u_pointLightDiffuse4;uniform vec3 u_ambientColor;uniform vec3 u_ambientMaterial;uniform vec3 u_diffuseColor;uniform vec3 u_diffuseMaterial;varying vec4 v_color;varying vec2 v_texCoord;varying float v_diffuseIntentsity;varying vec3 v_pointLightDiffuse;varying vec4 v_shadowScreenPos;void main(){vec4 localNormal=vec4(a_normal.x,a_normal.y,a_normal.z,a_normal.w);localNormal.z=a_position.z;bool isTopFace=mod(localNormal.z,2.0)>0.0&&localNormal.z>1.0;float height;vec4 originNormal;if(mod(localNormal.z,2.0)>0.0){height=u_height+u_base;if(u_drawLine){height+=0.01;}originNormal=vec4(localNormal.xy,localNormal.z,1.0);}else{height=u_base;originNormal=localNormal;}gl_Position=u_projectionMatrix*u_viewMatrix*vec4(a_position.xy,height,1.0);v_shadowScreenPos=u_shadowMatrix*vec4(a_position.xy,height,1.0);vec3 normal=normalize(vec3(u_normalMatrix*originNormal));vec3 lightPos=normalize(u_lightPos);vec3 ambientColor=u_color.rgb*u_ambientColor*u_ambientMaterial;float diffuseIntentsity=max(0.0,dot(lightPos,normal));diffuseIntentsity=0.5;v_diffuseIntentsity=diffuseIntentsity;vec3 diffuseColor=u_color.rgb*u_diffuseColor*u_diffuseMaterial*diffuseIntentsity;vec3 pointLightVec=vec3(a_position.xyz-u_pointLightPos1);vec3 pointLightDir=normalize(pointLightVec);float pointLightDis=length(pointLightVec);float pointLightIntentsity=min(1.0,max(0.0,1.0-(pointLightDis*pointLightDis/400.0)));float pointLightDirIntentsity=max(0.0,dot(pointLightDir,normal));vec3 pointLightDiffuse1=u_pointLightDiffuse1*pointLightDirIntentsity*pointLightIntentsity;pointLightVec=vec3(a_position.xyz-u_pointLightPos2);pointLightDir=normalize(pointLightVec);pointLightDis=length(pointLightVec);pointLightIntentsity=min(1.0,max(0.0,1.0-(pointLightDis*pointLightDis/400.0)));pointLightDirIntentsity=max(0.0,dot(pointLightDir,normal));vec3 pointLightDiffuse2=u_pointLightDiffuse2*pointLightDirIntentsity*pointLightIntentsity;pointLightVec=vec3(a_position.xyz-u_pointLightPos3);pointLightDir=normalize(pointLightVec);pointLightDis=length(pointLightVec);pointLightIntentsity=min(1.0,max(0.0,1.0-(pointLightDis*pointLightDis/400.0)));pointLightDirIntentsity=max(0.0,dot(pointLightDir,normal));vec3 pointLightDiffuse3=u_pointLightDiffuse3*pointLightDirIntentsity*pointLightIntentsity;pointLightVec=vec3(a_position.xyz-u_pointLightPos4);pointLightDir=normalize(pointLightVec);pointLightDis=length(pointLightVec);pointLightIntentsity=min(1.0,max(0.0,1.0-(pointLightDis*pointLightDis/400.0)));pointLightDirIntentsity=max(0.0,dot(pointLightDir,normal));vec3 pointLightDiffuse4=u_pointLightDiffuse4*pointLightDirIntentsity*pointLightIntentsity;v_pointLightDiffuse=pointLightDiffuse1*u_pointLightFactor.x+pointLightDiffuse2*u_pointLightFactor.y+pointLightDiffuse3*u_pointLightFactor.z+pointLightDiffuse4*u_pointLightFactor.w;v_color=isTopFace ? u_color : vec4(ambientColor+diffuseColor,u_color.a);v_texCoord=a_texCoord;}";

    var fillExtrusionFragment = "precision highp float;varying vec4 v_color;varying vec2 v_texCoord;varying float v_diffuseIntentsity;varying vec3 v_pointLightDiffuse;varying vec4 v_shadowScreenPos;uniform float u_opacity;uniform float u_textureFactor;uniform sampler2D u_sampler;uniform sampler2D u_shadowSampler;uniform float u_timer;uniform bool u_drawLine;uniform float u_brightness;uniform float u_saturation;uniform float u_contrast;uniform float u_texCoordFactor;void main(){vec4 result=vec4(0.0,0.0,0.0,0.0);vec3 shadowCoord=(v_shadowScreenPos.xyz/v_shadowScreenPos.w)/2.0+0.5;vec4 rgbaDepth=texture2D(u_shadowSampler,shadowCoord.xy);float depth=rgbaDepth.r+rgbaDepth.g/255.0+rgbaDepth.b/255.0/255.0;float visibility=(shadowCoord.z>depth+0.075)? 0.7 : 1.0;if(shadowCoord.x<0.0||shadowCoord.x>1.0||shadowCoord.y<0.0||shadowCoord.y>1.0){visibility=1.0;}visibility=1.0;if(false&&u_drawLine){result=v_color*u_opacity;}else{vec2 texCoord=v_texCoord*u_texCoordFactor;vec4 texColor=vec4(texture2D(u_sampler,texCoord).xyz*0.7+v_diffuseIntentsity*0.2+v_pointLightDiffuse.xyz*0.35,1.0);result=vec4(texColor.rgb*u_textureFactor+v_color.rgb*(1.0-u_textureFactor),1.0)*u_opacity;float alpha=result.a;vec3 finalCol=vec3(result.rgb*u_brightness);float luminance=0.2125*result.r+0.7154*result.g+0.0721*result.b;vec3 luminanceCol=vec3(luminance,luminance,luminance);finalCol=mix(luminanceCol,finalCol.rgb,u_saturation);vec3 avgCol=vec3(0.5,0.5,0.5);finalCol=mix(avgCol.rgb,finalCol.rgb,u_contrast);result=vec4(finalCol.rgb,alpha);}result=vec4(result.rgb*visibility,result.a);gl_FragColor=result;}";

    var fillExtrusionVertex2 = "attribute vec4 a_position;attribute vec4 a_normal;uniform bool u_drawLine;uniform float u_height;uniform float u_base;uniform mat4 u_viewMatrix;uniform mat4 u_projectionMatrix;uniform vec4 u_color;uniform mat4 u_normalMatrix;uniform vec3 u_lightPos;uniform vec3 u_ambientColor;uniform vec3 u_ambientMaterial;uniform vec3 u_diffuseColor;uniform vec3 u_diffuseMaterial;varying vec4 v_color;void main(){bool isTopFace=mod(a_normal.z,2.0)>0.0&&a_normal.z>1.0;float height;vec4 originNormal;if(mod(a_normal.z,2.0)>0.0){height=u_height+u_base;if(u_drawLine){height+=0.01;}originNormal=vec4(a_normal.xy,a_normal.z-1.0,1.0);}else{height=u_base;originNormal=a_normal;}gl_Position=u_projectionMatrix*u_viewMatrix*vec4(a_position.xy,height,1.0);vec3 normal=normalize(vec3(u_normalMatrix*originNormal));vec3 lightPos=normalize(u_lightPos);vec3 ambientColor=u_color.rgb*u_ambientColor*u_ambientMaterial;float diffuseIntentsity=max(0.0,dot(lightPos,normal));vec3 diffuseColor=u_color.rgb*u_diffuseColor*u_diffuseMaterial*diffuseIntentsity;v_color=isTopFace ? u_color : vec4(ambientColor+diffuseColor,u_color.a);}";

    var fillExtrusionFragment2 = "precision highp float;varying vec4 v_color;uniform float u_opacity;void main(){gl_FragColor=v_color*u_opacity;}";

    var fillExtrusionVertexOrigion = "attribute vec4 a_position;attribute vec4 a_normal;uniform bool u_drawLine;uniform float u_height;uniform float u_base;uniform mat4 u_viewMatrix;uniform mat4 u_projectionMatrix;uniform vec4 u_color;uniform mat4 u_normalMatrix;uniform vec3 u_lightPos;uniform vec3 u_ambientColor;uniform vec3 u_ambientMaterial;uniform vec3 u_diffuseColor;uniform vec3 u_diffuseMaterial;varying vec4 v_color;void main(){bool isTopFace=mod(a_normal.z,2.0)>0.0&&a_normal.z>1.0;float height;vec4 originNormal;if(mod(a_normal.z,2.0)>0.0){height=u_height+u_base;if(u_drawLine){height+=0.01;}originNormal=vec4(a_normal.xy,a_normal.z-1.0,1.0);}else{height=u_base;originNormal=a_normal;}gl_Position=u_projectionMatrix*u_viewMatrix*vec4(a_position.xy,height,1.0);vec3 normal=normalize(vec3(u_normalMatrix*originNormal));vec3 lightPos=normalize(u_lightPos);vec3 ambientColor=u_color.rgb*u_ambientColor*u_ambientMaterial;float diffuseIntentsity=max(0.0,dot(lightPos,normal));vec3 diffuseColor=u_color.rgb*u_diffuseColor*u_diffuseMaterial*diffuseIntentsity;v_color=isTopFace ? u_color : vec4(ambientColor+diffuseColor,u_color.a);}";

    var fillExtrusionFragmentOrigion = "precision highp float;varying vec4 v_color;uniform float u_opacity;void main(){gl_FragColor=v_color*u_opacity;}";

    var fillVertex = "attribute vec4 a_position;attribute vec2 a_texCoord;uniform mat4 u_viewMatrix;uniform mat4 u_projectionMatrix;uniform float u_base;uniform mat4 u_shadowMatrix;varying vec4 v_shadowScreenPos;varying vec2 v_texCoord;void main(){gl_Position=u_projectionMatrix*u_viewMatrix*vec4(a_position.xy,u_base,1.0);v_shadowScreenPos=u_shadowMatrix*vec4(a_position.xy,u_base,1.0);v_texCoord=a_texCoord;}";

    var fillFragment = "precision highp float;uniform vec4 u_color;uniform float u_opacity;uniform float u_brightness;uniform float u_saturation;uniform float u_contrast;uniform float u_textureFactor;uniform float u_texCoordFactor;uniform sampler2D u_texture;uniform sampler2D u_shadowSampler;varying vec4 v_shadowScreenPos;varying vec2 v_texCoord;void main(){vec4 result=vec4(0.0,0.0,0.0,0.0);result=u_color*(1.0-u_textureFactor)+texture2D(u_texture,v_texCoord*u_texCoordFactor)*u_textureFactor;result.a=u_opacity;vec3 shadowCoord=(v_shadowScreenPos.xyz/v_shadowScreenPos.w)/2.0+0.5;vec4 rgbaDepth=texture2D(u_shadowSampler,shadowCoord.xy);float depth=rgbaDepth.r+rgbaDepth.g/255.0+rgbaDepth.b/255.0/255.0;float visibility=(shadowCoord.z>depth)? 0.7 : 1.0;if(shadowCoord.x<0.0||shadowCoord.x>1.0||shadowCoord.y<0.0||shadowCoord.y>1.0){visibility=1.0;}visibility=1.0;float alpha=result.a;vec3 finalCol=vec3(result.rgb*u_brightness);float luminance=0.2125*result.r+0.7154*result.g+0.0721*result.b;vec3 luminanceCol=vec3(luminance,luminance,luminance);finalCol=mix(luminanceCol,finalCol.rgb,u_saturation);vec3 avgCol=vec3(0.5,0.5,0.5);finalCol=mix(avgCol.rgb,finalCol.rgb,u_contrast);result=vec4(finalCol.rgb*visibility,alpha);gl_FragColor=result;}";

    var lineVertex = "attribute vec4 a_position;attribute vec2 a_normal;attribute vec2 a_texCoord;attribute vec3 a_deviation;uniform float u_lineWidth;uniform float u_onePixelToWorld;uniform vec2 u_imgSize;uniform float u_base;uniform mat4 u_viewMatrix;uniform mat4 u_projectionMatrix;varying vec2 v_texCoord;void main(){float halfWidth=u_lineWidth/2.0;vec2 normal=a_normal*halfWidth*u_onePixelToWorld;vec2 deviation=a_deviation.xy*halfWidth*u_onePixelToWorld;if(a_deviation.z!=0.0){float num=length(deviation);if(num>=a_deviation.z){deviation*=0.0;}}vec2 texCoord=a_texCoord.xy;if(a_texCoord.x!=0.0){float lineNum=a_texCoord.x/u_onePixelToWorld/u_imgSize.y;float x=lineNum*(u_imgSize.y/u_imgSize.x)*(u_imgSize.y/u_lineWidth/2.0);texCoord=vec2(x,a_texCoord.y);}v_texCoord=texCoord;vec4 position=vec4(a_position.xy+deviation+normal,u_base,1.0);gl_Position=u_projectionMatrix*u_viewMatrix*position;}";

    var lineFragment = "precision highp float;uniform vec4 u_color;uniform sampler2D u_sampler;uniform bool u_useTexture;uniform float u_opacity;uniform float u_time;varying vec2 v_texCoord;void main(){vec2 texCoord=vec2(v_texCoord.x-u_time*0.4,v_texCoord.y);vec4 color=u_useTexture ? texture2D(u_sampler,texCoord): u_color;gl_FragColor=color*u_opacity;}";

    var symbolVertex = "uniform mat4 u_projectionMatrix;uniform mat4 u_viewMatrix;uniform mat4 u_rotateMatrix;uniform mat4 u_pitchMatrix;uniform vec2 u_position;uniform vec2 u_offset;uniform vec2 u_resolution;uniform float u_base;attribute vec4 a_position;attribute vec2 a_texCoord;varying vec2 v_texCoord;mat4 translate(mat4 matrix,float x,float y,float z){matrix[3].x+=matrix[0].x*x+matrix[1].x*y+matrix[2].x*z;matrix[3].y+=matrix[0].y*x+matrix[1].y*y+matrix[2].y*z;matrix[3].z+=matrix[0].z*x+matrix[1].z*y+matrix[2].z*z;matrix[3].w+=matrix[0].w*x+matrix[1].w*y+matrix[2].w*z;return matrix;}mat4 scale(mat4 matrix,float x,float y,float z){matrix[0].x*=x;matrix[1].x*=y;matrix[2].x*=z;matrix[0].y*=x;matrix[1].y*=y;matrix[2].y*=z;matrix[0].z*=x;matrix[1].z*=y;matrix[2].z*=z;matrix[0].w*=x;matrix[1].w*=y;matrix[2].w*=z;return matrix;}void main(){mat4 modelMatrix=mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0);modelMatrix=translate(modelMatrix,u_position.x,u_position.y,u_base);vec4 pos=u_viewMatrix*vec4(u_position.xy,u_base,1.0);float scaleNum=pos.z/u_resolution.y*-0.6666667;mat4 prMatrix=u_rotateMatrix*u_pitchMatrix;modelMatrix=modelMatrix*scale(prMatrix,scaleNum,scaleNum,scaleNum);modelMatrix=translate(modelMatrix,-u_position.x,-u_position.y,-u_base);mat4 pvm=u_projectionMatrix*u_viewMatrix*modelMatrix;gl_Position=pvm*vec4(a_position.xy+u_offset,a_position.z+u_base,a_position.w);v_texCoord=a_texCoord;}";

    var symbolFragment = "precision highp float;uniform sampler2D u_sampler;uniform float u_opacity;varying vec2 v_texCoord;void main(){vec4 color=texture2D(u_sampler,v_texCoord);gl_FragColor=vec4(color.rgb,color.a*u_opacity);}";

    var trackVertex = "attribute vec4 a_position;uniform float u_base;uniform mat4 u_viewMatrix;uniform mat4 u_projectionMatrix;varying vec4 v_shadowScreenPos;uniform mat4 u_shadowMatrix;void main(){gl_Position=u_projectionMatrix*u_viewMatrix*vec4(a_position.xy,u_base,1.0);gl_PointSize=10.0;v_shadowScreenPos=u_shadowMatrix*vec4(a_position.xy,u_base,1.0);}";

    var trackFragment = "precision highp float;uniform highp vec4 u_color;uniform float u_opacity;varying vec4 v_shadowScreenPos;void main(){gl_FragColor=u_color*u_opacity;}";

    var modelVertex = "attribute vec4 a_position;attribute vec2 a_texCoord;attribute vec4 a_normal;uniform mat4 u_projectionMatrix;uniform mat4 u_viewMatrix;uniform vec2 u_position;uniform float u_base;uniform mat4 u_modelMatrix;uniform mat4 u_shadowMatrix;varying vec2 v_texCoord;varying float v_diffuseIntentsity;varying vec4 v_shadowScreenPos;uniform mat4 u_normalMatrix;uniform vec3 u_lightPos;uniform float u_zScale;void main(){mat4 modelMatrix=mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,u_zScale,0.0,u_position.x,u_position.y,u_base,1.0);modelMatrix*=u_modelMatrix;mat4 pvm=u_projectionMatrix*u_viewMatrix*modelMatrix;gl_Position=pvm*a_position;v_shadowScreenPos=u_shadowMatrix*modelMatrix*a_position;vec3 normal=normalize(vec3(u_normalMatrix*a_normal));vec3 lightPos=normalize(u_lightPos);float diffuseIntentsity=max(0.0,dot(lightPos,normal));v_diffuseIntentsity=diffuseIntentsity;v_texCoord=a_texCoord;}";

    var modelFragment = "precision highp float;uniform bool u_useTexture;uniform sampler2D u_sampler;uniform sampler2D u_shadowSampler;uniform vec4 u_color;uniform float u_opacity;varying vec2 v_texCoord;varying float v_diffuseIntentsity;varying vec4 v_shadowScreenPos;uniform vec3 u_ambientColor;uniform vec3 u_ambientMaterial;uniform vec3 u_diffuseColor;uniform vec3 u_diffuseMaterial;uniform float u_brightness;uniform float u_saturation;uniform float u_contrast;void main(){vec4 color=u_useTexture ? texture2D(u_sampler,v_texCoord): u_color;vec3 ambientColor=color.rgb*u_ambientColor*u_ambientMaterial;vec3 diffuseColor=color.rgb*u_diffuseColor*u_diffuseMaterial*v_diffuseIntentsity;vec4 result=vec4(ambientColor+diffuseColor,color.a)*u_opacity;result=vec4(result.rgb*u_brightness,result.a);gl_FragColor=result;}";

    var circleVertex = "attribute vec2 a_normal;uniform mat4 u_projectionMatrix;uniform mat4 u_viewMatrix;uniform vec2 u_position;uniform vec2 u_resolution;uniform float u_base;uniform float u_radius;void main(){vec4 pos=u_viewMatrix*vec4(u_position.xy,u_base,1.0);float scaleNum=pos.z/u_resolution.y*-0.6666667*u_radius;mat4 pvm=u_projectionMatrix*u_viewMatrix;vec4 position=vec4(u_position+a_normal*scaleNum,u_base,1.0);gl_Position=pvm*position;}";

    var circleFragment = "precision highp float;uniform vec4 u_color;uniform float u_opacity;void main(){gl_FragColor=u_color*u_opacity;}";

    var pictureVertex = "uniform mat4 u_projectionMatrix;uniform mat4 u_viewMatrix;uniform vec2 u_position;uniform float u_base;uniform float u_rotate;attribute vec4 a_position;attribute vec2 a_texCoord;varying vec2 v_texCoord;void main(){float originX=a_position.x-u_position.x;float originY=a_position.y-u_position.y;float rad=radians(u_rotate);float cosNum=cos(rad);float sinNum=sin(rad);float x=cosNum*originX-sinNum*originY;float y=sinNum*originX+cosNum*originY;x=u_position.x+x;y=u_position.y+y;mat4 pvm=u_projectionMatrix*u_viewMatrix;gl_Position=pvm*vec4(x,y,a_position.z+u_base,a_position.w);v_texCoord=a_texCoord;}";

    var pictureFragment = "precision highp float;uniform sampler2D u_sampler;uniform float u_opacity;varying vec2 v_texCoord;void main(){gl_FragColor=texture2D(u_sampler,v_texCoord)*u_opacity;}";

    var heatmapVertex = "attribute vec2 a_normal;uniform mat4 u_projectionMatrix;uniform mat4 u_viewMatrix;uniform vec2 u_position;uniform vec2 u_resolution;uniform float u_radius;varying vec4 v_color;void main(){vec4 pos=u_viewMatrix*vec4(u_position.xy,0.0,1.0);float scaleNum=pos.z/u_resolution.y*-0.6666667*u_radius;mat4 pvm=u_projectionMatrix*u_viewMatrix;vec4 position=vec4(u_position+a_normal*scaleNum,0.0,1.0);gl_Position=pvm*position;v_color=vec4(0.0,0.0,0.0,0.0);if(a_normal.x==0.0&&a_normal.y==0.0){v_color=vec4(0.0,0.0,0.0,1.0);}}";

    var heatmapFragment = "precision highp float;varying vec4 v_color;void main(){gl_FragColor=v_color;}";

    var heatmapTextureVertex = "attribute vec4 a_position;void main(){gl_Position=a_position;}";

    var heatmapTextureFragment = "precision highp float;uniform vec2 u_resolution;uniform float u_opacity;uniform sampler2D u_sampler;vec3 getColorByAlpha(float alpha){vec3 color=vec3(0.0,0.0,alpha);if(alpha>0.85){return vec3(1.0,1.0-(alpha-0.85)/0.15,0.0);}else if(alpha>0.55){return vec3((alpha-0.55)/0.3,1.0,0.0);}else if(alpha>0.25){return vec3(0.0,(alpha-0.25)/0.3,1.0-(alpha-0.25)/0.3);}else if(alpha>0.0){return vec3(0.0,0.0,1.0);}return color;}void main(){vec2 texCoord=gl_FragCoord.xy/u_resolution;vec4 color=texture2D(u_sampler,texCoord);gl_FragColor=vec4(getColorByAlpha(color.a),color.a)*u_opacity;}";

    var connectionVertex = "attribute vec4 a_position;attribute vec2 a_normal;attribute vec2 a_texCoord;uniform mat4 u_viewMatrix;uniform mat4 u_projectionMatrix;uniform mat4 u_modelMatrix;uniform float u_base;uniform float u_onePixelToWorld;uniform float u_width;uniform vec2 u_imgSize;varying vec2 v_texCoord;mat4 translate(mat4 matrix,float x,float y,float z){matrix[3].x+=matrix[0].x*x+matrix[1].x*y+matrix[2].x*z;matrix[3].y+=matrix[0].y*x+matrix[1].y*y+matrix[2].y*z;matrix[3].z+=matrix[0].z*x+matrix[1].z*y+matrix[2].z*z;matrix[3].w+=matrix[0].w*x+matrix[1].w*y+matrix[2].w*z;return matrix;}void main(){mat4 modelMatrix=mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0);modelMatrix=translate(modelMatrix,a_position.x,a_position.y,u_base);modelMatrix*=u_modelMatrix;modelMatrix=translate(modelMatrix,-a_position.x,-a_position.y,-u_base);mat4 pvm=u_projectionMatrix*u_viewMatrix*modelMatrix;vec2 normal=a_normal*u_onePixelToWorld*u_width/2.0;gl_Position=pvm*vec4(a_position.x+normal.x,a_position.y,a_position.z+u_base+normal.y,a_position.w);gl_PointSize=10.0;vec2 texCoord=a_texCoord;if(a_texCoord.x!=0.0){float lineNum=a_texCoord.x/u_onePixelToWorld/u_imgSize.y;float x=lineNum*(u_imgSize.y/u_imgSize.x)*(u_imgSize.y/u_width/2.0);texCoord=vec2(x,a_texCoord.y);}v_texCoord=texCoord;}";

    var connectionFragment = "precision highp float;uniform vec4 u_color;uniform float u_opacity;uniform sampler2D u_sampler;uniform sampler2D u_sampler2;uniform bool u_useTexture;uniform float u_time;varying vec2 v_texCoord;void main(){vec2 texCoord=v_texCoord;texCoord.x=texCoord.x-u_time;vec4 texColor1=texture2D(u_sampler,texCoord);vec4 texColor2=texture2D(u_sampler2,texCoord);vec4 color=u_useTexture ?(texColor1*1.2+texColor2*0.0): u_color;gl_FragColor=color*u_opacity;}";

    var tileVertex = "uniform mat4 u_matrix;uniform vec2 u_offset;uniform float u_scale;attribute vec4 a_position;attribute vec2 a_texCoord;varying vec2 v_texCoord;uniform mat4 u_shadowMatrix;varying vec4 v_shadowScreenPos;void main(){vec2 position=a_position.xy*u_scale+u_offset;gl_Position=u_matrix*vec4(position,a_position.z,a_position.w);v_texCoord=a_texCoord;}";

    var tileFragment = "precision highp float;uniform sampler2D u_sampler;uniform float u_opacity;uniform sampler2D u_shadowSampler;varying vec2 v_texCoord;varying vec4 v_shadowScreenPos;void main(){vec4 color=texture2D(u_sampler,v_texCoord);vec3 shadowCoord=(v_shadowScreenPos.xyz/v_shadowScreenPos.w)/2.0+0.5;vec4 rgbaDepth=texture2D(u_shadowSampler,shadowCoord.xy);float depth=rgbaDepth.r;float visibility=(shadowCoord.z>depth+0.01)? 0.7 : 1.0;gl_FragColor=vec4(color.rgb*visibility,color.a*u_opacity);}";

    var shadowMapVertex = "attribute vec4 a_position;attribute vec2 a_texCoord;attribute vec4 a_normal;uniform bool u_drawLine;uniform float u_height;uniform float u_base;uniform mat4 u_viewMatrix;uniform mat4 u_projectionMatrix;varying vec4 v_shadowScreenPos;void main(){bool isTopFace=mod(a_normal.z,2.0)>0.0&&a_normal.z>1.0;float height;vec4 originNormal;if(mod(a_normal.z,2.0)>0.0){height=u_height+u_base;if(u_drawLine){height+=0.01;}originNormal=vec4(a_normal.xy,a_normal.z,1.0);}else{height=u_base;originNormal=a_normal;}gl_Position=u_projectionMatrix*u_viewMatrix*vec4(a_position.xy,height,1.0);v_shadowScreenPos=u_projectionMatrix*u_viewMatrix*vec4(a_position.xy,height,1.0);}";

    var shadowMapFragment = "precision highp float;varying vec4 v_shadowScreenPos;void main(){float zDepth=v_shadowScreenPos.z/v_shadowScreenPos.w;gl_FragColor=vec4(zDepth,floor(zDepth*255.0),floor(zDepth*255.0*255.0),1.0);}";

    var ShaderSource = {
        fillExtrusion: { vertex: fillExtrusionVertex, fragment: fillExtrusionFragment },
        fillExtrusion2: { vertex: fillExtrusionVertex2, fragment: fillExtrusionFragment2 },
        fillExtrusionOrigion: { vertex: fillExtrusionVertexOrigion, fragment: fillExtrusionFragmentOrigion },
        fill: { vertex: fillVertex, fragment: fillFragment },
        line: { vertex: lineVertex, fragment: lineFragment },
        symbol: { vertex: symbolVertex, fragment: symbolFragment },
        track: { vertex: trackVertex, fragment: trackFragment },
        model: { vertex: modelVertex, fragment: modelFragment },
        circle: { vertex: circleVertex, fragment: circleFragment },
        picture: { vertex: pictureVertex, fragment: pictureFragment },
        heatmap: { vertex: heatmapVertex, fragment: heatmapFragment },
        heatmapTexture: { vertex: heatmapTextureVertex, fragment: heatmapTextureFragment },
        connection: { vertex: connectionVertex, fragment: connectionFragment },
        tile: { vertex: tileVertex, fragment: tileFragment },
        shadowMap: { vertex: shadowMapVertex, fragment: shadowMapFragment },
    };

    var GLContext = (function () {
        function GLContext(gl, options) {
            this._programMap = new Map();
            this._isEnableDepthTest = false;
            this._isEnableAlpha = false;
            this._gl = gl;
            this._options = options;
            this._gl.activeTexture(this._gl.TEXTURE0);
            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
        }
        GLContext.prototype.resize = function (width, height) {
            this._options.width = width;
            this._options.height = height;
            if (this._frameBuffer && this._frameTexture) {
                this._initFrameBuffer();
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
                this._gl.bindTexture(this._gl.TEXTURE_2D, null);
            }
        };
        GLContext.prototype._initFrameBuffer = function () {
            var gl = this._gl;
            this._frameBuffer = this._gl.createFramebuffer();
            this._frameTexture = this._gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this._frameTexture);
            var _a = this._options, width = _a.width, height = _a.height;
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            var renderBuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._frameTexture, 0);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        };
        GLContext.prototype.enableFrameBuffer = function () {
            if (!this._frameBuffer || !this._frameTexture) {
                this._initFrameBuffer();
            }
            else {
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._frameTexture);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer);
            }
        };
        GLContext.prototype.use = function (name) {
            if (this._activeProgramName === name)
                return;
            this._activeProgramName = name;
            var program = this._programMap.get(name);
            if (!program) {
                program = new Program(this._gl, ShaderSource[name]);
                this._programMap.set(name, program);
            }
            this._gl.useProgram(program.getProgram());
        };
        GLContext.prototype.getActiveProgram = function () {
            var result = null;
            if (this._activeProgramName) {
                result = this._programMap.get(this._activeProgramName);
                if (result === undefined) {
                    return null;
                }
                else {
                    return result;
                }
            }
            return null;
        };
        GLContext.prototype.clear = function () {
            if (this._frameBuffer) {
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer);
                this._gl.clear(this._gl.DEPTH_BUFFER_BIT | this._gl.COLOR_BUFFER_BIT);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
            }
            this._gl.clear(this._gl.DEPTH_BUFFER_BIT | this._gl.COLOR_BUFFER_BIT);
        };
        GLContext.prototype.enableAlpha = function () {
            !this._isEnableAlpha && this._gl.enable(this._gl.BLEND);
            this._isEnableAlpha = true;
        };
        GLContext.prototype.disableAlpha = function () {
            if (!this._isEnableAlpha)
                return;
            this._isEnableAlpha = false;
            this._gl.disable(this._gl.BLEND);
        };
        GLContext.prototype.initArrayBuffer = function (location, data, size) {
            if (location === -1)
                return;
            var buffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer);
            this._gl.bufferData(this._gl.ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
            var FSIZE = data.BYTES_PER_ELEMENT;
            this._gl.vertexAttribPointer(location, size, this._gl.FLOAT, false, size * FSIZE, 0);
            this._gl.enableVertexAttribArray(location);
        };
        GLContext.prototype.initIndexBuffer = function (indices) {
            var uint16 = new Uint16Array(indices);
            var buffer = this._gl.createBuffer();
            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, buffer);
            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, uint16, this._gl.STATIC_DRAW);
        };
        GLContext.prototype.enableDepthTest = function () {
            if (this._isEnableDepthTest)
                return;
            this._isEnableDepthTest = true;
            this._gl.enable(this._gl.DEPTH_TEST);
        };
        GLContext.prototype.disableDepthTest = function () {
            if (!this._isEnableDepthTest)
                return;
            this._isEnableDepthTest = false;
            this._gl.disable(this._gl.DEPTH_TEST);
        };
        GLContext.prototype.getViewRect = function () {
            return {
                width: this._options.width,
                height: this._options.height,
            };
        };
        return GLContext;
    }());

    var ArraySet = (function () {
        function ArraySet(values) {
            this._idMap = new Map();
            this._list = [];
            if (values) {
                this._list = values;
                for (var i = 0; i < values.length; i += 1) {
                    this._idMap.set(values[i].id, i);
                }
            }
        }
        ArraySet.prototype.set = function (item) {
            var index = this._idMap.get(item.id);
            if (typeof index === 'number') {
                this._list[index] = item;
            }
            else {
                this._list.push(item);
                this._idMap.set(item.id, this._list.length - 1);
            }
        };
        ArraySet.prototype.delete = function (item) {
            var id = item.id;
            var index = this._idMap.get(id);
            if (typeof index === 'number') {
                this._list.splice(index, 1);
                this._idMap.delete(id);
                this._updateIndex(index);
            }
        };
        ArraySet.prototype._updateIndex = function (startIndex) {
            for (var i = startIndex; i < this._list.length; i += 1) {
                this._idMap.set(this._list[i].id, i);
            }
        };
        ArraySet.prototype.size = function () {
            return this._list.length;
        };
        ArraySet.prototype.has = function (item) {
            return this._idMap.has(item.id);
        };
        ArraySet.prototype.getValues = function () {
            return this._list;
        };
        ArraySet.prototype.getById = function (id) {
            var index = this._idMap.get(id);
            if (typeof index === 'number') {
                return this._list[index];
            }
        };
        ArraySet.prototype.clear = function () {
            this._idMap.clear();
            this._list.length = 0;
        };
        ArraySet.prototype.shift = function () {
            var item = this._list.shift();
            if (item) {
                this._idMap.delete(item.id);
                this._updateIndex(0);
            }
            return item;
        };
        ArraySet.prototype.pop = function () {
            var item = this._list.pop();
            if (item) {
                this._idMap.delete(item.id);
            }
            return item;
        };
        ArraySet.prototype.valuesConcat = function (set) {
            return this._list.concat(set._list);
        };
        ArraySet.prototype.get = function (index) {
            return this._list[index];
        };
        return ArraySet;
    }());

    function createWorker$1(file) {
        var WebWorker = (function () {
            function WebWorker() {
                this._url = URL.createObjectURL(new Blob([file]));
                this._worker = new Worker(this._url);
            }
            WebWorker.prototype.addEventListener = function (type, listener) {
                this._worker.addEventListener(type, listener);
            };
            WebWorker.prototype.removeEventListener = function (type, listener) {
                this._worker.removeEventListener(type, listener);
            };
            WebWorker.prototype.terminate = function () {
                this._worker.terminate();
                URL.revokeObjectURL(this._url);
            };
            WebWorker.prototype.postMessage = function (message, options) {
                this._worker.postMessage(message, options);
            };
            Object.defineProperty(WebWorker.prototype, "onmessage", {
                get: function () {
                    return this._worker.onmessage;
                },
                set: function (listener) {
                    this._worker.onmessage = listener;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(WebWorker.prototype, "onerror", {
                get: function () {
                    return this._worker.onerror;
                },
                set: function (listener) {
                    this._worker.onerror = listener;
                },
                enumerable: false,
                configurable: true
            });
            return WebWorker;
        }());
        return WebWorker;
    }

    var Worker$2 = createWorker$1("(function () {\n    'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __spreadArrays() {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    }\n\n    var Matrix4 = (function () {\r\n        function Matrix4(value) {\r\n            this._value = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\r\n            if (value) {\r\n                for (var i = 0; i < value.length; i += 1) {\r\n                    this._value[i] = value[i];\r\n                }\r\n            }\r\n        }\r\n        Matrix4.prototype.setIdentity = function () {\r\n            var e = this._value;\r\n            e[0] = 1;\r\n            e[4] = 0;\r\n            e[8] = 0;\r\n            e[12] = 0;\r\n            e[1] = 0;\r\n            e[5] = 1;\r\n            e[9] = 0;\r\n            e[13] = 0;\r\n            e[2] = 0;\r\n            e[6] = 0;\r\n            e[10] = 1;\r\n            e[14] = 0;\r\n            e[3] = 0;\r\n            e[7] = 0;\r\n            e[11] = 0;\r\n            e[15] = 1;\r\n            return this;\r\n        };\r\n        Matrix4.prototype.multiply = function (other) {\r\n            var i, e, a, b, ai0, ai1, ai2, ai3;\r\n            e = this._value;\r\n            a = this._value;\r\n            b = other._value;\r\n            if (e === b) {\r\n                b = [];\r\n                for (i = 0; i < 16; ++i) {\r\n                    b[i] = e[i];\r\n                }\r\n            }\r\n            for (i = 0; i < 4; i++) {\r\n                ai0 = a[i];\r\n                ai1 = a[i + 4];\r\n                ai2 = a[i + 8];\r\n                ai3 = a[i + 12];\r\n                e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];\r\n                e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];\r\n                e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];\r\n                e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];\r\n            }\r\n            return this;\r\n        };\r\n        Matrix4.prototype.transpose = function () {\r\n            var e, t;\r\n            e = this._value;\r\n            t = e[1];\r\n            e[1] = e[4];\r\n            e[4] = t;\r\n            t = e[2];\r\n            e[2] = e[8];\r\n            e[8] = t;\r\n            t = e[3];\r\n            e[3] = e[12];\r\n            e[12] = t;\r\n            t = e[6];\r\n            e[6] = e[9];\r\n            e[9] = t;\r\n            t = e[7];\r\n            e[7] = e[13];\r\n            e[13] = t;\r\n            t = e[11];\r\n            e[11] = e[14];\r\n            e[14] = t;\r\n            return this;\r\n        };\r\n        Matrix4.prototype.invert = function () {\r\n            var i, s, d, inv, det;\r\n            s = this._value;\r\n            d = this._value;\r\n            inv = [];\r\n            inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15]\r\n                + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];\r\n            inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15]\r\n                - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];\r\n            inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15]\r\n                + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];\r\n            inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14]\r\n                - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];\r\n            inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15]\r\n                - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];\r\n            inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15]\r\n                + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];\r\n            inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15]\r\n                - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];\r\n            inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14]\r\n                + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];\r\n            inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15]\r\n                + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];\r\n            inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15]\r\n                - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];\r\n            inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15]\r\n                + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];\r\n            inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14]\r\n                - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];\r\n            inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11]\r\n                - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];\r\n            inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11]\r\n                + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];\r\n            inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11]\r\n                - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];\r\n            inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10]\r\n                + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];\r\n            det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];\r\n            if (det === 0) {\r\n                return this;\r\n            }\r\n            det = 1 / det;\r\n            for (i = 0; i < 16; i++) {\r\n                d[i] = inv[i] * det;\r\n            }\r\n            return this;\r\n        };\r\n        Matrix4.prototype.setOrtho = function (left, right, bottom, top, near, far) {\r\n            var e, rw, rh, rd;\r\n            if (left === right || bottom === top || near === far) {\r\n                throw 'null frustum';\r\n            }\r\n            rw = 1 / (right - left);\r\n            rh = 1 / (top - bottom);\r\n            rd = 1 / (far - near);\r\n            e = this._value;\r\n            e[0] = 2 * rw;\r\n            e[1] = 0;\r\n            e[2] = 0;\r\n            e[3] = 0;\r\n            e[4] = 0;\r\n            e[5] = 2 * rh;\r\n            e[6] = 0;\r\n            e[7] = 0;\r\n            e[8] = 0;\r\n            e[9] = 0;\r\n            e[10] = -2 * rd;\r\n            e[11] = 0;\r\n            e[12] = -(right + left) * rw;\r\n            e[13] = -(top + bottom) * rh;\r\n            e[14] = -(far + near) * rd;\r\n            e[15] = 1;\r\n            return this;\r\n        };\r\n        Matrix4.prototype.setFrustum = function (left, right, bottom, top, near, far) {\r\n            var e, rw, rh, rd;\r\n            if (left === right || top === bottom || near === far) {\r\n                throw 'null frustum';\r\n            }\r\n            if (near <= 0) {\r\n                throw 'near <= 0';\r\n            }\r\n            if (far <= 0) {\r\n                throw 'far <= 0';\r\n            }\r\n            rw = 1 / (right - left);\r\n            rh = 1 / (top - bottom);\r\n            rd = 1 / (far - near);\r\n            e = this._value;\r\n            e[0] = 2 * near * rw;\r\n            e[1] = 0;\r\n            e[2] = 0;\r\n            e[3] = 0;\r\n            e[4] = 0;\r\n            e[5] = 2 * near * rh;\r\n            e[6] = 0;\r\n            e[7] = 0;\r\n            e[8] = (right + left) * rw;\r\n            e[9] = (top + bottom) * rh;\r\n            e[10] = -(far + near) * rd;\r\n            e[11] = -1;\r\n            e[12] = 0;\r\n            e[13] = 0;\r\n            e[14] = -2 * near * far * rd;\r\n            e[15] = 0;\r\n            return this;\r\n        };\r\n        Matrix4.prototype.setPerspective = function (fovy, aspect, near, far) {\r\n            var e, rd, s, ct;\r\n            if (near === far || aspect === 0) {\r\n                throw 'null frustum';\r\n            }\r\n            if (near <= 0) {\r\n                throw 'near <= 0';\r\n            }\r\n            if (far <= 0) {\r\n                throw 'far <= 0';\r\n            }\r\n            fovy = Math.PI * fovy / 180 / 2;\r\n            s = Math.sin(fovy);\r\n            if (s === 0) {\r\n                throw 'null frustum';\r\n            }\r\n            rd = 1 / (far - near);\r\n            ct = Math.cos(fovy) / s;\r\n            e = this._value;\r\n            e[0] = ct / aspect;\r\n            e[1] = 0;\r\n            e[2] = 0;\r\n            e[3] = 0;\r\n            e[4] = 0;\r\n            e[5] = ct;\r\n            e[6] = 0;\r\n            e[7] = 0;\r\n            e[8] = 0;\r\n            e[9] = 0;\r\n            e[10] = -(far + near) * rd;\r\n            e[11] = -1;\r\n            e[12] = 0;\r\n            e[13] = 0;\r\n            e[14] = -2 * near * far * rd;\r\n            e[15] = 0;\r\n            return this;\r\n        };\r\n        Matrix4.prototype.scale = function (x, y, z) {\r\n            var e = this._value;\r\n            e[0] *= x;\r\n            e[4] *= y;\r\n            e[8] *= z;\r\n            e[1] *= x;\r\n            e[5] *= y;\r\n            e[9] *= z;\r\n            e[2] *= x;\r\n            e[6] *= y;\r\n            e[10] *= z;\r\n            e[3] *= x;\r\n            e[7] *= y;\r\n            e[11] *= z;\r\n            return this;\r\n        };\r\n        Matrix4.prototype.translate = function (x, y, z) {\r\n            var e = this._value;\r\n            e[12] += e[0] * x + e[4] * y + e[8] * z;\r\n            e[13] += e[1] * x + e[5] * y + e[9] * z;\r\n            e[14] += e[2] * x + e[6] * y + e[10] * z;\r\n            e[15] += e[3] * x + e[7] * y + e[11] * z;\r\n            return this;\r\n        };\r\n        Matrix4.prototype.rotate = function (angle, x, y, z) {\r\n            var len = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));\r\n            if (len === 0)\r\n                return this;\r\n            var rad = angle / 180 * Math.PI;\r\n            var a = this._value;\r\n            var s, c, t;\r\n            var a00, a01, a02, a03;\r\n            var a10, a11, a12, a13;\r\n            var a20, a21, a22, a23;\r\n            var b00, b01, b02;\r\n            var b10, b11, b12;\r\n            var b20, b21, b22;\r\n            len = 1 / len;\r\n            x *= len;\r\n            y *= len;\r\n            z *= len;\r\n            s = Math.sin(rad);\r\n            c = Math.cos(rad);\r\n            t = 1 - c;\r\n            a00 = a[0];\r\n            a01 = a[1];\r\n            a02 = a[2];\r\n            a03 = a[3];\r\n            a10 = a[4];\r\n            a11 = a[5];\r\n            a12 = a[6];\r\n            a13 = a[7];\r\n            a20 = a[8];\r\n            a21 = a[9];\r\n            a22 = a[10];\r\n            a23 = a[11];\r\n            b00 = x * x * t + c;\r\n            b01 = y * x * t + z * s;\r\n            b02 = z * x * t - y * s;\r\n            b10 = x * y * t - z * s;\r\n            b11 = y * y * t + c;\r\n            b12 = z * y * t + x * s;\r\n            b20 = x * z * t + y * s;\r\n            b21 = y * z * t - x * s;\r\n            b22 = z * z * t + c;\r\n            a[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n            a[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n            a[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n            a[3] = a03 * b00 + a13 * b01 + a23 * b02;\r\n            a[4] = a00 * b10 + a10 * b11 + a20 * b12;\r\n            a[5] = a01 * b10 + a11 * b11 + a21 * b12;\r\n            a[6] = a02 * b10 + a12 * b11 + a22 * b12;\r\n            a[7] = a03 * b10 + a13 * b11 + a23 * b12;\r\n            a[8] = a00 * b20 + a10 * b21 + a20 * b22;\r\n            a[9] = a01 * b20 + a11 * b21 + a21 * b22;\r\n            a[10] = a02 * b20 + a12 * b21 + a22 * b22;\r\n            a[11] = a03 * b20 + a13 * b21 + a23 * b22;\r\n            return this;\r\n        };\r\n        Matrix4.prototype.setLookAt = function (eye, center, up) {\r\n            if (eye.length !== 3 || center.length !== 3 || up.length !== 3) {\r\n                console.error('鏁版嵁鏍煎紡閿欒');\r\n                return this;\r\n            }\r\n            var eyeX = eye[0], eyeY = eye[1], eyeZ = eye[2];\r\n            var centerX = center[0], centerY = center[1], centerZ = center[2];\r\n            var upX = up[0], upY = up[1], upZ = up[2];\r\n            var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\r\n            fx = centerX - eyeX;\r\n            fy = centerY - eyeY;\r\n            fz = centerZ - eyeZ;\r\n            rlf = 1 / Math.sqrt(fx * fx + fy * fy + fz * fz);\r\n            fx *= rlf;\r\n            fy *= rlf;\r\n            fz *= rlf;\r\n            sx = fy * upZ - fz * upY;\r\n            sy = fz * upX - fx * upZ;\r\n            sz = fx * upY - fy * upX;\r\n            rls = 1 / Math.sqrt(sx * sx + sy * sy + sz * sz);\r\n            sx *= rls;\r\n            sy *= rls;\r\n            sz *= rls;\r\n            ux = sy * fz - sz * fy;\r\n            uy = sz * fx - sx * fz;\r\n            uz = sx * fy - sy * fx;\r\n            e = this._value;\r\n            e[0] = sx;\r\n            e[1] = ux;\r\n            e[2] = -fx;\r\n            e[3] = 0;\r\n            e[4] = sy;\r\n            e[5] = uy;\r\n            e[6] = -fy;\r\n            e[7] = 0;\r\n            e[8] = sz;\r\n            e[9] = uz;\r\n            e[10] = -fz;\r\n            e[11] = 0;\r\n            e[12] = 0;\r\n            e[13] = 0;\r\n            e[14] = 0;\r\n            e[15] = 1;\r\n            this.translate(-eyeX, -eyeY, -eyeZ);\r\n            return this;\r\n        };\r\n        Matrix4.prototype.dropShadow = function (plane, light) {\r\n            var mat = new Matrix4();\r\n            var e = mat._value;\r\n            var dot = plane[0] * light[0] + plane[1] * light[1] + plane[2] * light[2] + plane[3] * light[3];\r\n            e[0] = dot - light[0] * plane[0];\r\n            e[1] = -light[1] * plane[0];\r\n            e[2] = -light[2] * plane[0];\r\n            e[3] = -light[3] * plane[0];\r\n            e[4] = -light[0] * plane[1];\r\n            e[5] = dot - light[1] * plane[1];\r\n            e[6] = -light[2] * plane[1];\r\n            e[7] = -light[3] * plane[1];\r\n            e[8] = -light[0] * plane[2];\r\n            e[9] = -light[1] * plane[2];\r\n            e[10] = dot - light[2] * plane[2];\r\n            e[11] = -light[3] * plane[2];\r\n            e[12] = -light[0] * plane[3];\r\n            e[13] = -light[1] * plane[3];\r\n            e[14] = -light[2] * plane[3];\r\n            e[15] = dot - light[3] * plane[3];\r\n            return this.multiply(mat);\r\n        };\r\n        Matrix4.prototype.getValue = function () {\r\n            return this._value;\r\n        };\r\n        Matrix4.prototype.clone = function () {\r\n            return new Matrix4(this._value);\r\n        };\r\n        Matrix4.prototype.makeRotationFromEuler = function (x, y, z, order) {\r\n            if (x == null || y == null || z == null) {\r\n                return;\r\n            }\r\n            var te = this._value;\r\n            var a = Math.cos(x), b = Math.sin(x);\r\n            var c = Math.cos(y), d = Math.sin(y);\r\n            var e = Math.cos(z), f = Math.sin(z);\r\n            if (order === 'XYZ') {\r\n                var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n                te[0] = c * e;\r\n                te[4] = -c * f;\r\n                te[8] = d;\r\n                te[1] = af + be * d;\r\n                te[5] = ae - bf * d;\r\n                te[9] = -b * c;\r\n                te[2] = bf - ae * d;\r\n                te[6] = be + af * d;\r\n                te[10] = a * c;\r\n            }\r\n            else if (order === 'YXZ') {\r\n                var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n                te[0] = ce + df * b;\r\n                te[4] = de * b - cf;\r\n                te[8] = a * d;\r\n                te[1] = a * f;\r\n                te[5] = a * e;\r\n                te[9] = -b;\r\n                te[2] = cf * b - de;\r\n                te[6] = df + ce * b;\r\n                te[10] = a * c;\r\n            }\r\n            else if (order === 'ZXY') {\r\n                var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n                te[0] = ce - df * b;\r\n                te[4] = -a * f;\r\n                te[8] = de + cf * b;\r\n                te[1] = cf + de * b;\r\n                te[5] = a * e;\r\n                te[9] = df - ce * b;\r\n                te[2] = -a * d;\r\n                te[6] = b;\r\n                te[10] = a * c;\r\n            }\r\n            else if (order === 'ZYX') {\r\n                var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n                te[0] = c * e;\r\n                te[4] = be * d - af;\r\n                te[8] = ae * d + bf;\r\n                te[1] = c * f;\r\n                te[5] = bf * d + ae;\r\n                te[9] = af * d - be;\r\n                te[2] = -d;\r\n                te[6] = b * c;\r\n                te[10] = a * c;\r\n            }\r\n            else if (order === 'YZX') {\r\n                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n                te[0] = c * e;\r\n                te[4] = bd - ac * f;\r\n                te[8] = bc * f + ad;\r\n                te[1] = f;\r\n                te[5] = a * e;\r\n                te[9] = -b * e;\r\n                te[2] = -d * e;\r\n                te[6] = ad * f + bc;\r\n                te[10] = ac - bd * f;\r\n            }\r\n            else if (order === 'XZY') {\r\n                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n                te[0] = c * e;\r\n                te[4] = -f;\r\n                te[8] = d * e;\r\n                te[1] = ac * f + bd;\r\n                te[5] = a * e;\r\n                te[9] = ad * f - bc;\r\n                te[2] = bc * f - ad;\r\n                te[6] = b * e;\r\n                te[10] = bd * f + ac;\r\n            }\r\n            te[3] = 0;\r\n            te[7] = 0;\r\n            te[11] = 0;\r\n            te[12] = 0;\r\n            te[13] = 0;\r\n            te[14] = 0;\r\n            te[15] = 1;\r\n            return this;\r\n        };\r\n        return Matrix4;\r\n    }());\n\n    var Vector4 = (function () {\r\n        function Vector4(start, end) {\r\n            if (end) {\r\n                this.x = end[0] - start[0];\r\n                this.y = end[1] - start[1];\r\n                this.z = end[2] - start[2];\r\n                this.w = end[3] - start[3];\r\n            }\r\n            else {\r\n                this.x = start[0];\r\n                this.y = start[1];\r\n                this.z = start[2];\r\n                this.w = start[3];\r\n            }\r\n        }\r\n        Vector4.prototype.unit = function () {\r\n            var len = this.getLength();\r\n            return new Vector4([this.x / len, this.y / len, this.z / len, this.w / len]);\r\n        };\r\n        Vector4.prototype.divide = function (num) {\r\n            this.x /= num;\r\n            this.y /= num;\r\n            this.z /= num;\r\n            this.w /= num;\r\n            return this;\r\n        };\r\n        Vector4.prototype.getLength = function () {\r\n            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2) + Math.pow(this.w, 2));\r\n        };\r\n        Vector4.prototype.multiplyMat4 = function (matrix) {\r\n            var m = matrix.getValue();\r\n            var x = this.x;\r\n            var y = this.y;\r\n            var z = this.z;\r\n            var w = this.w;\r\n            var resultX = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\r\n            var resultY = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\r\n            var resultZ = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\r\n            var resultW = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\r\n            return new Vector4([resultX, resultY, resultZ, resultW]);\r\n        };\r\n        Vector4.prototype.clone = function () {\r\n            return new Vector4([this.x, this.y, this.z, this.w]);\r\n        };\r\n        Vector4.prototype.subtract = function (other) {\r\n            this.x -= other.x;\r\n            this.y -= other.y;\r\n            this.z -= other.z;\r\n            this.w -= other.w;\r\n        };\r\n        return Vector4;\r\n    }());\n\n    function createRect(point, width, height, anchor) {\r\n        if (anchor === void 0) { anchor = 'center'; }\r\n        var AnchorMap = {\r\n            center: [0.5, 0.5],\r\n            top: [0.5, 1],\r\n            bottom: [0.5, 0],\r\n            left: [0, 0.5],\r\n            right: [1, 0.5],\r\n            'top-left': [0, 1],\r\n            'top-right': [1, 1],\r\n            'bottom-left': [0, 0],\r\n            'bottom-right': [1, 0],\r\n        };\r\n        var anchorArr = AnchorMap[anchor] || [0.5, 0.5];\r\n        return [\r\n            point[0] - anchorArr[0] * width, point[1] + (1 - anchorArr[1]) * height,\r\n            point[0] - anchorArr[0] * width, point[1] - anchorArr[1] * height,\r\n            point[0] + (1 - anchorArr[0]) * width, point[1] + (1 - anchorArr[1]) * height,\r\n            point[0] + (1 - anchorArr[0]) * width, point[1] - anchorArr[1] * height,\r\n        ];\r\n    }\r\n    function createScreenBounds(point, width, height, anchor) {\r\n        if (anchor === void 0) { anchor = 'center'; }\r\n        var AnchorMap = {\r\n            center: [0.5, 0.5],\r\n            top: [0.5, 0],\r\n            bottom: [0.5, 1],\r\n            left: [0, 0.5],\r\n            right: [1, 0.5],\r\n            'top-left': [0, 0],\r\n            'top-right': [1, 0],\r\n            'bottom-left': [0, 1],\r\n            'bottom-right': [1, 1],\r\n        };\r\n        var anchorArr = AnchorMap[anchor] || [0.5, 0.5];\r\n        return {\r\n            leftBottom: [\r\n                point[0] - anchorArr[0] * width, point[1] - anchorArr[1] * height,\r\n            ],\r\n            rightTop: [\r\n                point[0] + (1 - anchorArr[0]) * width, point[1] + (1 - anchorArr[1]) * height,\r\n            ],\r\n        };\r\n    }\r\n    function createPointGeometry(point, width, height, anchor) {\r\n        var vertices = createRect(point, width, height, anchor);\r\n        var texCoords = [0, 1, 0, 0, 1, 1, 1, 0];\r\n        return { vertices: vertices, texCoords: texCoords };\r\n    }\r\n    function mergeArray(arr, l, m, r, cb) {\r\n        var i = l, j = m + 1;\r\n        var temp = [];\r\n        while (i <= m && j <= r) {\r\n            if (cb(arr[i], arr[j]) > 0) {\r\n                temp.push(arr[j]);\r\n                j += 1;\r\n            }\r\n            else {\r\n                temp.push(arr[i]);\r\n                i += 1;\r\n            }\r\n        }\r\n        while (i <= m) {\r\n            temp.push(arr[i]);\r\n            i += 1;\r\n        }\r\n        while (j <= r) {\r\n            temp.push(arr[j]);\r\n            j += 1;\r\n        }\r\n        for (var i_1 = 0; i_1 < temp.length; i_1 += 1) {\r\n            arr[l + i_1] = temp[i_1];\r\n        }\r\n    }\r\n    function mergeSort(arr, l, r, cb) {\r\n        if (l < r) {\r\n            var m = Math.floor((l + r) / 2);\r\n            mergeSort(arr, l, m, cb);\r\n            mergeSort(arr, m + 1, r, cb);\r\n            mergeArray(arr, l, m, r, cb);\r\n        }\r\n    }\r\n    function sort(arr, callback) {\r\n        mergeSort(arr, 0, arr.length - 1, callback);\r\n    }\r\n    function filter(arr, filterArr) {\r\n        var set = new Set(filterArr);\r\n        var result = [];\r\n        var filterResult = [];\r\n        for (var i = 0; i < arr.length; i += 1) {\r\n            set.has(arr[i]) ? filterResult.push(arr[i]) : result.push(arr[i]);\r\n        }\r\n        return { result: result, filterResult: filterResult };\r\n    }\n\n    function isCollisionRect(exitRects, rects) {\r\n        for (var i = 0; i < exitRects.length; i += 1) {\r\n            for (var j = 0; j < rects.length; j += 1) {\r\n                var _a = exitRects[i].leftBottom, x01 = _a[0], y01 = _a[1];\r\n                var _b = exitRects[i].rightTop, x02 = _b[0], y02 = _b[1];\r\n                var _c = rects[j].leftBottom, x11 = _c[0], y11 = _c[1];\r\n                var _d = rects[j].rightTop, x12 = _d[0], y12 = _d[1];\r\n                var zx = Math.abs(x01 + x02 - x11 - x12);\r\n                var x = Math.abs(x01 - x02) + Math.abs(x11 - x12);\r\n                var zy = Math.abs(y01 + y02 - y11 - y12);\r\n                var y = Math.abs(y01 - y02) + Math.abs(y11 - y12);\r\n                if (zx <= x && zy <= y) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    var CollisionEngine = (function () {\r\n        function CollisionEngine(options) {\r\n            this._lastResult = new Map();\r\n            this._view = options.view;\r\n            this._pixelMatrix = new Matrix4(options.pixelMatrix);\r\n            this._zoom = options.zoom;\r\n            this._z = options.z;\r\n            this._center = options.center;\r\n            this._onePixelToWorld = options.onePixelToWorld;\r\n            var _a = this._view, viewWidth = _a.viewWidth, viewHeight = _a.viewHeight;\r\n            this._max = Math.sqrt(Math.pow(viewWidth, 2) + Math.pow(viewHeight, 2)) / 2 / (Math.pow(options.valueZ, 2));\r\n        }\r\n        CollisionEngine.prototype.updateOptions = function (options) {\r\n            this._view = options.view;\r\n            this._pixelMatrix = new Matrix4(options.pixelMatrix);\r\n            this._zoom = options.zoom;\r\n            this._z = options.z;\r\n            this._center = options.center;\r\n            this._onePixelToWorld = options.onePixelToWorld;\r\n            var _a = this._view, viewWidth = _a.viewWidth, viewHeight = _a.viewHeight;\r\n            this._max = Math.sqrt(Math.pow(viewWidth, 2) + Math.pow(viewHeight, 2)) / 2 / (Math.pow(options.valueZ, 2));\r\n        };\r\n        CollisionEngine.prototype._checkCenter = function (point) {\r\n            var distance = Math.sqrt(Math.pow((point[0] - this._center.x), 2) + Math.pow((point[1] - this._center.y), 2));\r\n            return (distance / this._onePixelToWorld) <= this._max;\r\n        };\r\n        CollisionEngine.prototype.calculate = function (list) {\r\n            var _this = this;\r\n            var map = new Map();\r\n            for (var i = 0; i < list.length; i += 1) {\r\n                for (var j = 0; j < list[i].data.length; j += 1) {\r\n                    var _a = list[i].data[j], zoomRange = _a.zoomRange, point = _a.point;\r\n                    if (this._checkZoomRange(zoomRange) && this._checkCenter(point)) {\r\n                        var item = map.get(list[i].floorId);\r\n                        if (item) {\r\n                            item.unshift(__assign({ id: list[i].id, index: j }, list[i].data[j]));\r\n                        }\r\n                        else {\r\n                            map.set(list[i].floorId, [__assign({ id: list[i].id, index: j }, list[i].data[j])]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            var resultMap = new Map();\r\n            map.forEach(function (item) {\r\n                var result = _this._calculateFloor(item);\r\n                result.forEach(function (value, key) {\r\n                    resultMap.set(key, value);\r\n                });\r\n            });\r\n            return this._generateResult(resultMap);\r\n        };\r\n        CollisionEngine.prototype._generateResult = function (data) {\r\n            var _this = this;\r\n            var showResult = {};\r\n            var hideResult = {};\r\n            var normalResult = {};\r\n            data.forEach(function (value, key) {\r\n                var item = _this._lastResult.get(key);\r\n                if (item) {\r\n                    var _a = filter(value, item), result = _a.result, filterResult = _a.filterResult;\r\n                    showResult[key] = result;\r\n                    normalResult[key] = filterResult;\r\n                }\r\n                else {\r\n                    showResult[key] = value;\r\n                }\r\n            });\r\n            this._lastResult.forEach(function (value, key) {\r\n                var item = data.get(key);\r\n                if (item) {\r\n                    var result = filter(value, item).result;\r\n                    hideResult[key] = result;\r\n                }\r\n                else {\r\n                    hideResult[key] = value;\r\n                }\r\n            });\r\n            this._lastResult = data;\r\n            return { hideResult: hideResult, showResult: showResult, normalResult: normalResult };\r\n        };\r\n        CollisionEngine.prototype._checkZoomRange = function (zoomRange) {\r\n            if (!zoomRange)\r\n                return true;\r\n            return (zoomRange[0] === null || zoomRange[0] <= this._zoom) &&\r\n                (zoomRange[1] === null || this._zoom < zoomRange[1]);\r\n        };\r\n        CollisionEngine.prototype._calculateFloor = function (list) {\r\n            sort(list, function (a, b) { return b.weight - a.weight; });\r\n            var resultMap = new Map();\r\n            var exitRects = [];\r\n            for (var i = 0; i < list.length; i += 1) {\r\n                var _a = list[i], point = _a.point, id = _a.id, data = _a.data, margin = _a.margin, index = _a.index;\r\n                var screenPoint = this._worldToScreenCoordinate(point);\r\n                var rects = [];\r\n                for (var j = 0; j < data.length; j += 1) {\r\n                    var _b = data[j], offset = _b.offset, width = _b.width, height = _b.height, anchor = _b.anchor;\r\n                    var x = screenPoint.x, y = screenPoint.y;\r\n                    var bounds = createScreenBounds([x - offset[0], y - offset[1]], width, height, anchor);\r\n                    var leftBottom = [bounds.leftBottom[0] - margin, bounds.leftBottom[1] - margin];\r\n                    var rightTop = [bounds.rightTop[0] + margin, bounds.rightTop[1] + margin];\r\n                    rects.push({ leftBottom: leftBottom, rightTop: rightTop });\r\n                }\r\n                if (this._isInView(screenPoint) && !isCollisionRect(exitRects, rects)) {\r\n                    exitRects.push.apply(exitRects, rects);\r\n                    var value = resultMap.get(id);\r\n                    if (value) {\r\n                        value.push(index);\r\n                    }\r\n                    else {\r\n                        resultMap.set(id, [index]);\r\n                    }\r\n                }\r\n            }\r\n            return resultMap;\r\n        };\r\n        CollisionEngine.prototype._worldToScreenCoordinate = function (worldPoint) {\r\n            var worldX = worldPoint[0], worldY = worldPoint[1];\r\n            var point = new Vector4([worldX, worldY, this._z, 1]);\r\n            var worldVector = point.multiplyMat4(this._pixelMatrix);\r\n            var x = (worldVector.x + worldVector.w) / (worldVector.w * 2);\r\n            var y = 1 - ((worldVector.y + worldVector.w) / (worldVector.w * 2));\r\n            x = x * this._view.viewWidth;\r\n            y = y * this._view.viewHeight;\r\n            return { x: x, y: y };\r\n        };\r\n        CollisionEngine.prototype._isInView = function (point) {\r\n            return 0 <= point.x && point.x < this._view.viewWidth &&\r\n                0 <= point.y && point.y < this._view.viewHeight;\r\n        };\r\n        return CollisionEngine;\r\n    }());\n\n    var engine;\r\n    function calcCollision(data) {\r\n        if (!engine) {\r\n            engine = new CollisionEngine(data);\r\n        }\r\n        else {\r\n            engine.updateOptions(data);\r\n        }\r\n        var resultMap = engine.calculate(data.list);\r\n        var collisionResult = __assign(__assign({ type: 'collisionResult' }, resultMap), { isForce: data.isForce });\r\n        postMessage(collisionResult);\r\n    }\n\n    var earcut_1 = earcut;\n    var _default = earcut;\n\n    function earcut(data, holeIndices, dim) {\n\n        dim = dim || 2;\n\n        var hasHoles = holeIndices && holeIndices.length,\n            outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n            outerNode = linkedList(data, 0, outerLen, dim, true),\n            triangles = [];\n\n        if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n        var minX, minY, maxX, maxY, x, y, invSize;\n\n        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n        if (data.length > 80 * dim) {\n            minX = maxX = data[0];\n            minY = maxY = data[1];\n\n            for (var i = dim; i < outerLen; i += dim) {\n                x = data[i];\n                y = data[i + 1];\n                if (x < minX) minX = x;\n                if (y < minY) minY = y;\n                if (x > maxX) maxX = x;\n                if (y > maxY) maxY = y;\n            }\n\n            // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n            invSize = Math.max(maxX - minX, maxY - minY);\n            invSize = invSize !== 0 ? 1 / invSize : 0;\n        }\n\n        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n        return triangles;\n    }\n\n    // create a circular doubly linked list from polygon points in the specified winding order\n    function linkedList(data, start, end, dim, clockwise) {\n        var i, last;\n\n        if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n            for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n        } else {\n            for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n        }\n\n        if (last && equals(last, last.next)) {\n            removeNode(last);\n            last = last.next;\n        }\n\n        return last;\n    }\n\n    // eliminate colinear or duplicate points\n    function filterPoints(start, end) {\n        if (!start) return start;\n        if (!end) end = start;\n\n        var p = start,\n            again;\n        do {\n            again = false;\n\n            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n                removeNode(p);\n                p = end = p.prev;\n                if (p === p.next) break;\n                again = true;\n\n            } else {\n                p = p.next;\n            }\n        } while (again || p !== end);\n\n        return end;\n    }\n\n    // main ear slicing loop which triangulates a polygon (given as a linked list)\n    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n        if (!ear) return;\n\n        // interlink polygon nodes in z-order\n        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n        var stop = ear,\n            prev, next;\n\n        // iterate through ears, slicing them one by one\n        while (ear.prev !== ear.next) {\n            prev = ear.prev;\n            next = ear.next;\n\n            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n                // cut off the triangle\n                triangles.push(prev.i / dim);\n                triangles.push(ear.i / dim);\n                triangles.push(next.i / dim);\n\n                removeNode(ear);\n\n                // skipping the next vertex leads to less sliver triangles\n                ear = next.next;\n                stop = next.next;\n\n                continue;\n            }\n\n            ear = next;\n\n            // if we looped through the whole remaining polygon and can't find any more ears\n            if (ear === stop) {\n                // try filtering points and slicing again\n                if (!pass) {\n                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                // if this didn't work, try curing all small self-intersections locally\n                } else if (pass === 1) {\n                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                // as a last resort, try splitting the remaining polygon into two\n                } else if (pass === 2) {\n                    splitEarcut(ear, triangles, dim, minX, minY, invSize);\n                }\n\n                break;\n            }\n        }\n    }\n\n    // check whether a polygon node forms a valid ear with adjacent nodes\n    function isEar(ear) {\n        var a = ear.prev,\n            b = ear,\n            c = ear.next;\n\n        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n        // now make sure we don't have other points inside the potential ear\n        var p = ear.next.next;\n\n        while (p !== ear.prev) {\n            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0) return false;\n            p = p.next;\n        }\n\n        return true;\n    }\n\n    function isEarHashed(ear, minX, minY, invSize) {\n        var a = ear.prev,\n            b = ear,\n            c = ear.next;\n\n        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n        // triangle bbox; min & max are calculated like this for speed\n        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n            minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n            maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n            maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n        // z-order range for the current triangle bbox;\n        var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n            maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n        var p = ear.prevZ,\n            n = ear.nextZ;\n\n        // look for points inside the triangle in both directions\n        while (p && p.z >= minZ && n && n.z <= maxZ) {\n            if (p !== ear.prev && p !== ear.next &&\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0) return false;\n            p = p.prevZ;\n\n            if (n !== ear.prev && n !== ear.next &&\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n                area(n.prev, n, n.next) >= 0) return false;\n            n = n.nextZ;\n        }\n\n        // look for remaining points in decreasing z-order\n        while (p && p.z >= minZ) {\n            if (p !== ear.prev && p !== ear.next &&\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0) return false;\n            p = p.prevZ;\n        }\n\n        // look for remaining points in increasing z-order\n        while (n && n.z <= maxZ) {\n            if (n !== ear.prev && n !== ear.next &&\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n                area(n.prev, n, n.next) >= 0) return false;\n            n = n.nextZ;\n        }\n\n        return true;\n    }\n\n    // go through all polygon nodes and cure small local self-intersections\n    function cureLocalIntersections(start, triangles, dim) {\n        var p = start;\n        do {\n            var a = p.prev,\n                b = p.next.next;\n\n            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n                triangles.push(a.i / dim);\n                triangles.push(p.i / dim);\n                triangles.push(b.i / dim);\n\n                // remove two nodes involved\n                removeNode(p);\n                removeNode(p.next);\n\n                p = start = b;\n            }\n            p = p.next;\n        } while (p !== start);\n\n        return filterPoints(p);\n    }\n\n    // try splitting polygon into two and triangulate them independently\n    function splitEarcut(start, triangles, dim, minX, minY, invSize) {\n        // look for a valid diagonal that divides the polygon into two\n        var a = start;\n        do {\n            var b = a.next.next;\n            while (b !== a.prev) {\n                if (a.i !== b.i && isValidDiagonal(a, b)) {\n                    // split the polygon in two by the diagonal\n                    var c = splitPolygon(a, b);\n\n                    // filter colinear points around the cuts\n                    a = filterPoints(a, a.next);\n                    c = filterPoints(c, c.next);\n\n                    // run earcut on each half\n                    earcutLinked(a, triangles, dim, minX, minY, invSize);\n                    earcutLinked(c, triangles, dim, minX, minY, invSize);\n                    return;\n                }\n                b = b.next;\n            }\n            a = a.next;\n        } while (a !== start);\n    }\n\n    // link every hole into the outer loop, producing a single-ring polygon without holes\n    function eliminateHoles(data, holeIndices, outerNode, dim) {\n        var queue = [],\n            i, len, start, end, list;\n\n        for (i = 0, len = holeIndices.length; i < len; i++) {\n            start = holeIndices[i] * dim;\n            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            list = linkedList(data, start, end, dim, false);\n            if (list === list.next) list.steiner = true;\n            queue.push(getLeftmost(list));\n        }\n\n        queue.sort(compareX);\n\n        // process holes from left to right\n        for (i = 0; i < queue.length; i++) {\n            eliminateHole(queue[i], outerNode);\n            outerNode = filterPoints(outerNode, outerNode.next);\n        }\n\n        return outerNode;\n    }\n\n    function compareX(a, b) {\n        return a.x - b.x;\n    }\n\n    // find a bridge between vertices that connects hole with an outer ring and and link it\n    function eliminateHole(hole, outerNode) {\n        outerNode = findHoleBridge(hole, outerNode);\n        if (outerNode) {\n            var b = splitPolygon(outerNode, hole);\n\n            // filter collinear points around the cuts\n            filterPoints(outerNode, outerNode.next);\n            filterPoints(b, b.next);\n        }\n    }\n\n    // David Eberly's algorithm for finding a bridge between hole and outer polygon\n    function findHoleBridge(hole, outerNode) {\n        var p = outerNode,\n            hx = hole.x,\n            hy = hole.y,\n            qx = -Infinity,\n            m;\n\n        // find a segment intersected by a ray from the hole's leftmost point to the left;\n        // segment's endpoint with lesser x will be potential connection point\n        do {\n            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n                if (x <= hx && x > qx) {\n                    qx = x;\n                    if (x === hx) {\n                        if (hy === p.y) return p;\n                        if (hy === p.next.y) return p.next;\n                    }\n                    m = p.x < p.next.x ? p : p.next;\n                }\n            }\n            p = p.next;\n        } while (p !== outerNode);\n\n        if (!m) return null;\n\n        if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n        // look for points inside the triangle of hole point, segment intersection and endpoint;\n        // if there are no points found, we have a valid connection;\n        // otherwise choose the point of the minimum angle with the ray as connection point\n\n        var stop = m,\n            mx = m.x,\n            my = m.y,\n            tanMin = Infinity,\n            tan;\n\n        p = m;\n\n        do {\n            if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                    pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n                if (locallyInside(p, hole) &&\n                    (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                    m = p;\n                    tanMin = tan;\n                }\n            }\n\n            p = p.next;\n        } while (p !== stop);\n\n        return m;\n    }\n\n    // whether sector in vertex m contains sector in vertex p in the same coordinates\n    function sectorContainsSector(m, p) {\n        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n    }\n\n    // interlink polygon nodes in z-order\n    function indexCurve(start, minX, minY, invSize) {\n        var p = start;\n        do {\n            if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n            p.prevZ = p.prev;\n            p.nextZ = p.next;\n            p = p.next;\n        } while (p !== start);\n\n        p.prevZ.nextZ = null;\n        p.prevZ = null;\n\n        sortLinked(p);\n    }\n\n    // Simon Tatham's linked list merge sort algorithm\n    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n    function sortLinked(list) {\n        var i, p, q, e, tail, numMerges, pSize, qSize,\n            inSize = 1;\n\n        do {\n            p = list;\n            list = null;\n            tail = null;\n            numMerges = 0;\n\n            while (p) {\n                numMerges++;\n                q = p;\n                pSize = 0;\n                for (i = 0; i < inSize; i++) {\n                    pSize++;\n                    q = q.nextZ;\n                    if (!q) break;\n                }\n                qSize = inSize;\n\n                while (pSize > 0 || (qSize > 0 && q)) {\n\n                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                        e = p;\n                        p = p.nextZ;\n                        pSize--;\n                    } else {\n                        e = q;\n                        q = q.nextZ;\n                        qSize--;\n                    }\n\n                    if (tail) tail.nextZ = e;\n                    else list = e;\n\n                    e.prevZ = tail;\n                    tail = e;\n                }\n\n                p = q;\n            }\n\n            tail.nextZ = null;\n            inSize *= 2;\n\n        } while (numMerges > 1);\n\n        return list;\n    }\n\n    // z-order of a point given coords and inverse of the longer side of data bbox\n    function zOrder(x, y, minX, minY, invSize) {\n        // coords are transformed into non-negative 15-bit integer range\n        x = 32767 * (x - minX) * invSize;\n        y = 32767 * (y - minY) * invSize;\n\n        x = (x | (x << 8)) & 0x00FF00FF;\n        x = (x | (x << 4)) & 0x0F0F0F0F;\n        x = (x | (x << 2)) & 0x33333333;\n        x = (x | (x << 1)) & 0x55555555;\n\n        y = (y | (y << 8)) & 0x00FF00FF;\n        y = (y | (y << 4)) & 0x0F0F0F0F;\n        y = (y | (y << 2)) & 0x33333333;\n        y = (y | (y << 1)) & 0x55555555;\n\n        return x | (y << 1);\n    }\n\n    // find the leftmost node of a polygon ring\n    function getLeftmost(start) {\n        var p = start,\n            leftmost = start;\n        do {\n            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n            p = p.next;\n        } while (p !== start);\n\n        return leftmost;\n    }\n\n    // check if a point lies within a convex triangle\n    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n               (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n               (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n    }\n\n    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n    function isValidDiagonal(a, b) {\n        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n               (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n                (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n                equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n    }\n\n    // signed area of a triangle\n    function area(p, q, r) {\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    }\n\n    // check if two points are equal\n    function equals(p1, p2) {\n        return p1.x === p2.x && p1.y === p2.y;\n    }\n\n    // check if two segments intersect\n    function intersects(p1, q1, p2, q2) {\n        var o1 = sign(area(p1, q1, p2));\n        var o2 = sign(area(p1, q1, q2));\n        var o3 = sign(area(p2, q2, p1));\n        var o4 = sign(area(p2, q2, q1));\n\n        if (o1 !== o2 && o3 !== o4) return true; // general case\n\n        if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n        if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n        if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n        if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n        return false;\n    }\n\n    // for collinear points p, q, r, check if point q lies on segment pr\n    function onSegment(p, q, r) {\n        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n    }\n\n    function sign(num) {\n        return num > 0 ? 1 : num < 0 ? -1 : 0;\n    }\n\n    // check if a polygon diagonal intersects any polygon segments\n    function intersectsPolygon(a, b) {\n        var p = a;\n        do {\n            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                    intersects(p, p.next, a, b)) return true;\n            p = p.next;\n        } while (p !== a);\n\n        return false;\n    }\n\n    // check if a polygon diagonal is locally inside the polygon\n    function locallyInside(a, b) {\n        return area(a.prev, a, a.next) < 0 ?\n            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n    }\n\n    // check if the middle point of a polygon diagonal is inside the polygon\n    function middleInside(a, b) {\n        var p = a,\n            inside = false,\n            px = (a.x + b.x) / 2,\n            py = (a.y + b.y) / 2;\n        do {\n            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n                inside = !inside;\n            p = p.next;\n        } while (p !== a);\n\n        return inside;\n    }\n\n    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n    // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n    function splitPolygon(a, b) {\n        var a2 = new Node(a.i, a.x, a.y),\n            b2 = new Node(b.i, b.x, b.y),\n            an = a.next,\n            bp = b.prev;\n\n        a.next = b;\n        b.prev = a;\n\n        a2.next = an;\n        an.prev = a2;\n\n        b2.next = a2;\n        a2.prev = b2;\n\n        bp.next = b2;\n        b2.prev = bp;\n\n        return b2;\n    }\n\n    // create a node and optionally link it with previous one (in a circular doubly linked list)\n    function insertNode(i, x, y, last) {\n        var p = new Node(i, x, y);\n\n        if (!last) {\n            p.prev = p;\n            p.next = p;\n\n        } else {\n            p.next = last.next;\n            p.prev = last;\n            last.next.prev = p;\n            last.next = p;\n        }\n        return p;\n    }\n\n    function removeNode(p) {\n        p.next.prev = p.prev;\n        p.prev.next = p.next;\n\n        if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n        if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n    }\n\n    function Node(i, x, y) {\n        // vertex index in coordinates array\n        this.i = i;\n\n        // vertex coordinates\n        this.x = x;\n        this.y = y;\n\n        // previous and next vertex nodes in a polygon ring\n        this.prev = null;\n        this.next = null;\n\n        // z-order curve value\n        this.z = null;\n\n        // previous and next nodes in z-order\n        this.prevZ = null;\n        this.nextZ = null;\n\n        // indicates whether this is a steiner point\n        this.steiner = false;\n    }\n\n    // return a percentage difference between the polygon area and its triangulation area;\n    // used to verify correctness of triangulation\n    earcut.deviation = function (data, holeIndices, dim, triangles) {\n        var hasHoles = holeIndices && holeIndices.length;\n        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n        if (hasHoles) {\n            for (var i = 0, len = holeIndices.length; i < len; i++) {\n                var start = holeIndices[i] * dim;\n                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n                polygonArea -= Math.abs(signedArea(data, start, end, dim));\n            }\n        }\n\n        var trianglesArea = 0;\n        for (i = 0; i < triangles.length; i += 3) {\n            var a = triangles[i] * dim;\n            var b = triangles[i + 1] * dim;\n            var c = triangles[i + 2] * dim;\n            trianglesArea += Math.abs(\n                (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n                (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n        }\n\n        return polygonArea === 0 && trianglesArea === 0 ? 0 :\n            Math.abs((trianglesArea - polygonArea) / polygonArea);\n    };\n\n    function signedArea(data, start, end, dim) {\n        var sum = 0;\n        for (var i = start, j = end - dim; i < end; i += dim) {\n            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n            j = i;\n        }\n        return sum;\n    }\n\n    // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\n    earcut.flatten = function (data) {\n        var dim = data[0][0].length,\n            result = {vertices: [], holes: [], dimensions: dim},\n            holeIndex = 0;\n\n        for (var i = 0; i < data.length; i++) {\n            for (var j = 0; j < data[i].length; j++) {\n                for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n            }\n            if (i > 0) {\n                holeIndex += data[i - 1].length;\n                result.holes.push(holeIndex);\n            }\n        }\n        return result;\n    };\n    earcut_1.default = _default;\n\n    var AbstractBucket = (function () {\r\n        function AbstractBucket(data) {\r\n            this._geometryInfo = [];\r\n            this._features = data.features;\r\n            this._id = data.id;\r\n            this._offset = data.offset;\r\n            this._layout = data.layout;\r\n            this._type = data.type;\r\n            this._taskId = data.taskId;\r\n            this._hideCategoryId = data.hideCategoryIdArray;\r\n            this._hideColorId = data.hideColorIdArray;\r\n            this._chartletTable = data.chartletTable;\r\n            this._bTextureEnable = data.bTextureEnable;\r\n        }\r\n        AbstractBucket.prototype.init = function () {\r\n        };\r\n        AbstractBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n            this._hideCategoryId.length = 0;\r\n            this._hideColorId.length = 0;\r\n        };\r\n        AbstractBucket.prototype.deepClear = function () {\r\n            this._geometryInfo.length = 0;\r\n            this._id = '';\r\n            this._layout = null;\r\n            this._type = null;\r\n            this._taskId = '';\r\n        };\r\n        AbstractBucket.prototype.GetSideTextureByFeatureId = function (featureId) {\r\n            if (this._chartletTable == null || this._chartletTable == undefined) {\r\n                return '';\r\n            }\r\n            for (var i = 0; i < this._chartletTable.length; i++) {\r\n                if (this._chartletTable[i].featureId === featureId) {\r\n                    var result = this._chartletTable[i].sideTextureUrl;\r\n                    if (result == null || result == undefined) {\r\n                        result = '';\r\n                    }\r\n                    return result;\r\n                }\r\n            }\r\n            return '';\r\n        };\r\n        AbstractBucket.prototype.GetFeatureTextureCoordFactor = function (featureId) {\r\n            var defaultTextureCoordFactor = 0.5;\r\n            if (this._chartletTable == null\r\n                || this._chartletTable == undefined) {\r\n                return defaultTextureCoordFactor;\r\n            }\r\n            for (var i = 0; i < this._chartletTable.length; i++) {\r\n                if (this._chartletTable[i].featureId === featureId) {\r\n                    if (this._chartletTable[i].textureCoordFactor != null\r\n                        && this._chartletTable[i].textureCoordFactor != undefined) {\r\n                        return this._chartletTable[i].textureCoordFactor;\r\n                    }\r\n                    else {\r\n                        return defaultTextureCoordFactor;\r\n                    }\r\n                }\r\n            }\r\n            return defaultTextureCoordFactor;\r\n        };\r\n        AbstractBucket.prototype.GetTextureByFeatureId = function (featureId) {\r\n            if (this._chartletTable == null || this._chartletTable == undefined) {\r\n                return '';\r\n            }\r\n            for (var i = 0; i < this._chartletTable.length; i++) {\r\n                if (this._chartletTable[i].featureId === featureId) {\r\n                    var result = this._chartletTable[i].url;\r\n                    if (result == null || result == undefined) {\r\n                        result = '';\r\n                    }\r\n                    return result;\r\n                }\r\n            }\r\n            return '';\r\n        };\r\n        AbstractBucket.prototype.getDrawInfo = function () {\r\n            return {\r\n                id: this._id,\r\n                info: this._geometryInfo,\r\n                type: this._type,\r\n                taskId: this._taskId,\r\n            };\r\n        };\r\n        AbstractBucket.prototype.GetFloor = function (featureId) {\r\n            if (featureId == null || featureId == undefined || featureId == '' || typeof featureId != 'string') {\r\n                return '';\r\n            }\r\n            var floorStr = featureId.substr(0, 9);\r\n            return floorStr;\r\n        };\r\n        AbstractBucket.prototype.IsF0 = function (featureId) {\r\n            if (featureId == undefined\r\n                || featureId == null\r\n                || typeof featureId != 'string') {\r\n                return false;\r\n            }\r\n            var floorType = featureId.charAt(6);\r\n            var floorLevel = featureId.charAt(8);\r\n            if (floorType == 'F' && floorLevel == '0') {\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        return AbstractBucket;\r\n    }());\n\n    var IdGenerator = (function () {\r\n        function IdGenerator() {\r\n        }\r\n        IdGenerator.getId = function (prefix) {\r\n            if (prefix === void 0) { prefix = 'nag'; }\r\n            IdGenerator.id += 1;\r\n            return prefix + \"-\" + IdGenerator.id;\r\n        };\r\n        IdGenerator.id = 0;\r\n        return IdGenerator;\r\n    }());\n\n    function parseColor(color) {\r\n        if (!color)\r\n            return [0, 0, 0, 1];\r\n        var arr = [];\r\n        if (color.substr(0, 1) === '#') {\r\n            var str = color.slice(1);\r\n            for (var i = 0; i < 5; i += 2) {\r\n                var num = parseInt(str.substr(i, 2), 16) / 255;\r\n                arr.push(num || 0);\r\n            }\r\n            arr.push(1);\r\n        }\r\n        else if (color.substr(0, 4) === 'rgba') {\r\n            var str = color.slice(5, -1);\r\n            var splitArr = str.split(',');\r\n            for (var i = 0; i < 3; i += 1) {\r\n                var num = Number(splitArr[i]) / 255;\r\n                arr.push(num || 0);\r\n            }\r\n            arr.push(Number(splitArr[3]) || 1);\r\n        }\r\n        else if (color.substr(0, 3) === 'rgb') {\r\n            var str = color.slice(4, -1);\r\n            var splitArr = str.split(',');\r\n            for (var i = 0; i < 3; i += 1) {\r\n                var num = Number(splitArr[i]) / 255;\r\n                arr.push(num || 0);\r\n            }\r\n            arr.push(1);\r\n        }\r\n        if (arr.length !== 4) {\r\n            return [0, 0, 0, 1];\r\n        }\r\n        else {\r\n            return arr;\r\n        }\r\n    }\r\n    function getStyle(layout, name, properties) {\r\n        var keys = layout.keys, values = layout.values;\r\n        var style = layout[name];\r\n        if (keys && values && properties) {\r\n            for (var i = 0; i < keys.length; i += 1) {\r\n                var otherLayout = values[properties[keys[i]]];\r\n                if (otherLayout && otherLayout[name] !== undefined) {\r\n                    style = otherLayout[name];\r\n                    return style;\r\n                }\r\n            }\r\n        }\r\n        return style;\r\n    }\r\n    function getStopsOpacity(zoom, stops) {\r\n        var zoomOpacity = 1;\r\n        if (stops) {\r\n            var num = 1 - (zoom - stops[0]) / (stops[1] - stops[0]);\r\n            zoomOpacity = num > 1 ? 1 : (num > 0 ? num : 0);\r\n        }\r\n        return zoomOpacity;\r\n    }\r\n    var StyleUtils = {\r\n        parseColor: parseColor,\r\n        getStyle: getStyle,\r\n        getStopsOpacity: getStopsOpacity,\r\n    };\n\n    var Indices = (function () {\r\n        function Indices(indices) {\r\n            if (indices === void 0) { indices = []; }\r\n            this._value = indices;\r\n        }\r\n        Indices.prototype.add = function (indices, offset) {\r\n            if (offset === 0) {\r\n                this._value = this._value.concat(indices);\r\n            }\r\n            else {\r\n                for (var i = 0; i < indices.length; i += 1) {\r\n                    this._value.push(offset + indices[i]);\r\n                }\r\n            }\r\n        };\r\n        Indices.prototype.clear = function () {\r\n            this._value = [];\r\n        };\r\n        Indices.prototype.getValue = function () {\r\n            return this._value;\r\n        };\r\n        return Indices;\r\n    }());\n\n    var ZoomRangeConfig = (function () {\r\n        function ZoomRangeConfig() {\r\n        }\r\n        ZoomRangeConfig.zoomRangeTable = [\r\n            [0, 23],\r\n            [0, 23],\r\n            [0, 23],\r\n            [0, 23],\r\n            [0, 23],\r\n            [0, 23],\r\n            [0, 23],\r\n            [0, 23],\r\n            [0, 23],\r\n            [0, 23],\r\n            [0, 23],\r\n        ];\r\n        return ZoomRangeConfig;\r\n    }());\n\n    var LogMgr = (function () {\r\n        function LogMgr() {\r\n        }\r\n        LogMgr.log = function (strLog) {\r\n        };\r\n        return LogMgr;\r\n    }());\n\n    var FillBucket = (function (_super) {\r\n        __extends(FillBucket, _super);\r\n        function FillBucket() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this._geometryMap = {};\r\n            return _this;\r\n        }\r\n        FillBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n            this._geometryMap = {};\r\n        };\r\n        FillBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties, featureid = _a.featureid;\r\n                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n                if (featureid === undefined) {\r\n                    featureid = properties === null || properties === void 0 ? void 0 : properties.id;\r\n                }\r\n                if (visible) {\r\n                    if (geometry.type === 'Polygon') {\r\n                        this._calcPolygon(geometry.coordinates, properties, featureid);\r\n                    }\r\n                    else if (geometry.type === 'MultiPolygon') {\r\n                        for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                            this._calcPolygon(geometry.coordinates[j], properties, featureid);\r\n                        }\r\n                    }\r\n                    else ;\r\n                }\r\n            }\r\n            for (var key in this._geometryMap) {\r\n                var item = this._geometryMap[key];\r\n                this._geometryInfo.push({\r\n                    vertices: item.vertices,\r\n                    fillIndices: item.fillIndices.getValue(),\r\n                    outlineIndices: item.outlineIndices.getValue(),\r\n                    fillColor: item.fillColor,\r\n                    outlineColor: item.outlineColor,\r\n                    base: item.base,\r\n                    opacity: item.opacity,\r\n                    zoomRange: item.zoomRange,\r\n                    floorString: item.floorString,\r\n                    sideVertices: [],\r\n                    sideIndices: [],\r\n                    featureId: item.featureId,\r\n                    texCoord: item.texCoord,\r\n                    texture: null,\r\n                    sideTexture: null,\r\n                    isF0: item.isF0,\r\n                    textureUrl: item.textureUrl,\r\n                    sideTextureUrl: item.sideTextureUrl,\r\n                });\r\n            }\r\n        };\r\n        FillBucket.prototype._calcPolygon = function (polygon, properties, featureid) {\r\n            if (polygon.length === 0)\r\n                return;\r\n            var offset = this._offset;\r\n            var vertices = [];\r\n            var texCoord = [];\r\n            var holes = [];\r\n            var outlineIndices = [];\r\n            var enableOutline = StyleUtils.getStyle(this._layout, 'enableOutline', properties);\r\n            if (featureid == null || featureid == undefined || typeof featureid != 'string') {\r\n                featureid = '';\r\n            }\r\n            var floorStr = this.GetFloor(featureid);\r\n            var bF0 = this.IsF0(floorStr);\r\n            var zoomRange = [0, 24];\r\n            if (bF0 == false && featureid) {\r\n                var featureType = featureid.charAt(9);\r\n                zoomRange = ZoomRangeConfig.zoomRangeTable[parseInt(featureType)];\r\n            }\r\n            for (var i = 0; i < polygon.length; i += 1) {\r\n                var face = polygon[i];\r\n                for (var j = 0; j < face.length; j += 1) {\r\n                    if (enableOutline) {\r\n                        var verticesCount = vertices.length / 2;\r\n                        if (j < face.length - 1) {\r\n                            outlineIndices.push(verticesCount, verticesCount + 1);\r\n                        }\r\n                    }\r\n                    vertices.push(face[j][0] + offset[0], face[j][1] + offset[1]);\r\n                    if (this._bTextureEnable) {\r\n                        texCoord.push(face[j][0] + offset[0], face[j][1] + offset[1]);\r\n                    }\r\n                }\r\n                if (i < polygon.length - 1) {\r\n                    holes.push(vertices.length / 2);\r\n                }\r\n            }\r\n            var fillIndices = earcut_1(vertices, holes.length === 0 ? undefined : holes, 2);\r\n            var fillColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'fillColor', properties));\r\n            var outlineColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'outlineColor', properties));\r\n            var base = StyleUtils.getStyle(this._layout, 'base', properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);\r\n            if (bF0) {\r\n                base = 0.0;\r\n            }\r\n            var textureUrl = this.GetTextureByFeatureId(featureid);\r\n            var sideTextureUrl = this.GetSideTextureByFeatureId(featureid);\r\n            if (textureUrl == '' && sideTextureUrl == '') {\r\n                featureid = '';\r\n            }\r\n            else {\r\n                LogMgr.log('isExtra featureId: ' + featureid);\r\n            }\r\n            var key = this._getGeometryKey2(properties, featureid + textureUrl + sideTextureUrl + '-' + base);\r\n            if (this._geometryMap[key]\r\n                && this._geometryMap[key].vertices.length / 2 + vertices.length / 2 < 65536\r\n                && this._geometryMap[key].zoomRange === zoomRange) {\r\n                var geometry = this._geometryMap[key];\r\n                var oldVerticesCount = geometry.vertices.length / 2;\r\n                geometry.fillIndices.add(fillIndices, oldVerticesCount);\r\n                geometry.outlineIndices.add(outlineIndices, oldVerticesCount);\r\n                geometry.vertices = geometry.vertices.concat(vertices);\r\n                geometry.texCoord = geometry.texCoord.concat(texCoord);\r\n                geometry.floorString = floorStr;\r\n                geometry.featureId = featureid;\r\n                geometry.isF0 = bF0;\r\n                geometry.textureUrl = textureUrl;\r\n                geometry.sideTextureUrl = sideTextureUrl;\r\n            }\r\n            else {\r\n                if (this._geometryMap[key]) {\r\n                    var newId = IdGenerator.getId();\r\n                    this._geometryMap[newId] = this._geometryMap[key];\r\n                }\r\n                this._geometryMap[key] = {\r\n                    vertices: vertices,\r\n                    texCoord: texCoord,\r\n                    outlineColor: outlineColor,\r\n                    fillColor: fillColor,\r\n                    fillIndices: new Indices(fillIndices),\r\n                    outlineIndices: new Indices(outlineIndices),\r\n                    base: base,\r\n                    opacity: opacity,\r\n                    zoomRange: zoomRange,\r\n                    floorString: floorStr,\r\n                    featureId: featureid,\r\n                    isF0: bF0,\r\n                    textureUrl: textureUrl,\r\n                    sideTextureUrl: sideTextureUrl,\r\n                };\r\n            }\r\n        };\r\n        FillBucket.prototype._getGeometryKey = function (properties) {\r\n            var arr = [];\r\n            for (var i = 0; i < FillBucket.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, FillBucket.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            return arr.join('-');\r\n        };\r\n        FillBucket.prototype._getGeometryKey2 = function (properties, textureUrl) {\r\n            var arr = [];\r\n            for (var i = 0; i < FillBucket.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, FillBucket.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            arr.push(textureUrl);\r\n            return arr.join('-');\r\n        };\r\n        FillBucket.GEOMETRY_KEYS = ['fillColor', 'outlineColor', 'base', 'opacity'];\r\n        return FillBucket;\r\n    }(AbstractBucket));\n\n    var Vector2 = (function () {\r\n        function Vector2(start, end) {\r\n            if (end) {\r\n                this.x = end[0] - start[0];\r\n                this.y = end[1] - start[1];\r\n            }\r\n            else {\r\n                this.x = start[0];\r\n                this.y = start[1];\r\n            }\r\n        }\r\n        Vector2.prototype.unit = function () {\r\n            var length = this.getLength();\r\n            if (length === 0) {\r\n                return new Vector2([0, 0]);\r\n            }\r\n            var x = this.x / length;\r\n            var y = this.y / length;\r\n            return new Vector2([0, 0], [x, y]);\r\n        };\r\n        Vector2.prototype.normal = function () {\r\n            return new Vector2([0, 0], [-this.y, this.x]);\r\n        };\r\n        Vector2.prototype.add = function (other) {\r\n            this.x += other.x;\r\n            this.y += other.y;\r\n            return this;\r\n        };\r\n        Vector2.prototype.subtract = function (other) {\r\n            this.x -= other.x;\r\n            this.y -= other.y;\r\n            return this;\r\n        };\r\n        Vector2.prototype.rotate = function (angle) {\r\n            var cos = Math.cos(angle);\r\n            var sin = Math.sin(angle);\r\n            var x = cos * this.x - sin * this.y;\r\n            var y = sin * this.x + cos * this.y;\r\n            this.x = x;\r\n            this.y = y;\r\n            return this;\r\n        };\r\n        Vector2.prototype.multiply = function (num) {\r\n            this.x *= num;\r\n            this.y *= num;\r\n            return this;\r\n        };\r\n        Vector2.prototype.dot = function (other) {\r\n            return this.x * other.x + this.y * other.y;\r\n        };\r\n        Vector2.prototype.angleTo = function (other) {\r\n            var m1 = this.getLength();\r\n            var m2 = other.getLength();\r\n            var m = m1 * m2;\r\n            if (m === 0)\r\n                return 0;\r\n            var num = (this.x * other.x + this.y * other.y) / m;\r\n            if (num > 1) {\r\n                num = 1;\r\n            }\r\n            else if (num < -1) {\r\n                num = -1;\r\n            }\r\n            var angle = Math.acos(num) / Math.PI * 180;\r\n            var cross = this.cross(other) < 0 ? 1 : -1;\r\n            return cross * angle;\r\n        };\r\n        Vector2.prototype.cross = function (other) {\r\n            return this.x * other.y - other.x * this.y;\r\n        };\r\n        Vector2.prototype.clone = function () {\r\n            return new Vector2([0, 0], [this.x, this.y]);\r\n        };\r\n        Vector2.prototype.multiplyMat4 = function (matrix) {\r\n            var m = matrix.getValue();\r\n            var x = m[0] * this.x + m[4] * this.y + m[12];\r\n            var y = m[1] * this.x + m[5] * this.y + m[13];\r\n            return new Vector2([x, y]);\r\n        };\r\n        Vector2.prototype.getLength = function () {\r\n            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\r\n        };\r\n        return Vector2;\r\n    }());\n\n    var Global = (function () {\r\n        function Global() {\r\n            this.m_hiddenFeatureCategoryIdArray = new Array();\r\n            this.m_hiddenFeatureColorIdArray = new Array();\r\n            this.m_isOutDoor = false;\r\n        }\r\n        Global.getInstance = function () {\r\n            if (Global.m_instance == null) {\r\n                Global.m_instance = new Global();\r\n            }\r\n            return Global.m_instance;\r\n        };\r\n        Global.prototype.AddHideFeatureByCategoryId = function (categoryId) {\r\n            this.m_hiddenFeatureCategoryIdArray.push(categoryId);\r\n        };\r\n        Global.prototype.AddHideFeatureByColorId = function (colorId) {\r\n            this.m_hiddenFeatureColorIdArray.push(colorId);\r\n        };\r\n        Global.prototype.RemoveHideFeatureByColorId = function (colorId) {\r\n            for (var i = 0; i < this.m_hiddenFeatureColorIdArray.length; i++) {\r\n                if (this.m_hiddenFeatureColorIdArray[i] == colorId) {\r\n                    this.m_hiddenFeatureColorIdArray.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n        };\r\n        Global.prototype.RemoveHideFeatureByCategoryId = function (categoryId) {\r\n            for (var i = 0; i < this.m_hiddenFeatureCategoryIdArray.length; i++) {\r\n                if (this.m_hiddenFeatureCategoryIdArray[i] == categoryId) {\r\n                    this.m_hiddenFeatureCategoryIdArray.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n        };\r\n        Global.prototype.IsHideFeature = function (categoryId) {\r\n            for (var i = 0; i < this.m_hiddenFeatureCategoryIdArray.length; i++) {\r\n                if (this.m_hiddenFeatureCategoryIdArray[i] == categoryId) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        Global.prototype.GetHideCategoryIdArray = function () {\r\n            return this.m_hiddenFeatureCategoryIdArray;\r\n        };\r\n        Global.prototype.GetHideColorIdArray = function () {\r\n            return this.m_hiddenFeatureColorIdArray;\r\n        };\r\n        Global.prototype.IsOutDoor = function () {\r\n            return this.m_isOutDoor;\r\n        };\r\n        Global.prototype.SetOutDoor = function (bOutDoor) {\r\n            this.m_isOutDoor = bOutDoor;\r\n        };\r\n        Global.m_instance = null;\r\n        Global.m_curFillExtrusionDataCount = 0;\r\n        Global.m_maxFillExtrusionAllowed = 20000;\r\n        Global.m_maxFloorCachedAllowed = 1;\r\n        Global.m_bTextureEnable = false;\r\n        Global.m_bLowDisplay = true;\r\n        return Global;\r\n    }());\n\n    var FillExtrusionBucket = (function (_super) {\r\n        __extends(FillExtrusionBucket, _super);\r\n        function FillExtrusionBucket() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this._geometryMap = {};\r\n            return _this;\r\n        }\r\n        FillExtrusionBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                this._update(this._features[i]);\r\n            }\r\n            this._fireMessage();\r\n        };\r\n        FillExtrusionBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n            this._geometryMap = {};\r\n        };\r\n        FillExtrusionBucket.prototype._fireMessage = function () {\r\n            this._geometryInfo.length = 0;\r\n            for (var key in this._geometryMap) {\r\n                var item = this._geometryMap[key];\r\n                this._geometryInfo.push({\r\n                    vertices: item.vertices,\r\n                    sideVertices: item.sideVertices,\r\n                    fillIndices: item.fillIndices.getValue(),\r\n                    sideIndices: item.sideIndices.getValue(),\r\n                    outlineIndices: item.outlineIndices.getValue(),\r\n                    fillColor: item.fillColor,\r\n                    outlineColor: item.outlineColor,\r\n                    base: item.base,\r\n                    opacity: item.opacity,\r\n                    normals: item.normals,\r\n                    sideNormals: item.sideNormals,\r\n                    height: item.height,\r\n                    stops: item.stops,\r\n                    zoomRange: item.zoomRange,\r\n                    floorString: item.floorString,\r\n                    featureId: item.featureId,\r\n                    colorId: item.colorId,\r\n                    texCoordArray: item.texCoordArray,\r\n                    sideTexCoordArray: item.sideTexCoordArray,\r\n                    texCoord: [],\r\n                    texture: null,\r\n                    sideTexture: null,\r\n                    textureUrl: item.textureUrl,\r\n                    sideTextureUrl: item.sideTextureUrl,\r\n                    isF0: item.isF0,\r\n                });\r\n            }\r\n        };\r\n        FillExtrusionBucket.prototype.IsHideFeatureByCategoryId = function (categoryid) {\r\n            for (var i = 0; i < this._hideCategoryId.length; i++) {\r\n                if (categoryid == this._hideCategoryId[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        FillExtrusionBucket.prototype.IsHideFeatureByColorId = function (colorId) {\r\n            for (var i = 0; i < this._hideColorId.length; i++) {\r\n                if (colorId == this._hideColorId[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        FillExtrusionBucket.prototype._update = function (feature) {\r\n            var geometry = feature.geometry, properties = feature.properties, featureid = feature.featureid;\r\n            if (featureid == undefined || featureid == null) {\r\n                featureid = properties === null || properties === void 0 ? void 0 : properties.id;\r\n            }\r\n            if (properties\r\n                && (this.IsHideFeatureByCategoryId(properties.categoryid) || this.IsHideFeatureByColorId(properties.colorid))) {\r\n                LogMgr.log('鏈哄満蹇界暐鏌卞瓙');\r\n                return;\r\n            }\r\n            var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n            if (visible) {\r\n                if (geometry.type === 'Polygon') {\r\n                    this._calcPolygon(geometry.coordinates, properties, featureid);\r\n                }\r\n                else if (geometry.type === 'MultiPolygon') {\r\n                    for (var i = 0; i < geometry.coordinates.length; i += 1) {\r\n                        this._calcPolygon(geometry.coordinates[i], properties, featureid);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        FillExtrusionBucket.prototype.isExtra = function (properties) {\r\n            if (properties == null || properties == undefined) {\r\n                return false;\r\n            }\r\n            if (properties.isExtra != null && properties.isExtra != undefined) {\r\n                return properties.isExtra;\r\n            }\r\n            var colorid = properties === null || properties === void 0 ? void 0 : properties.colorid;\r\n            if (colorid == null || colorid == undefined) {\r\n                return false;\r\n            }\r\n            if (colorid == 7 || colorid == 8) {\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        FillExtrusionBucket.prototype._calcPolygon = function (polygon, properties, featureid) {\r\n            var offset = this._offset;\r\n            var vertices = [];\r\n            var sideVertices = [];\r\n            var sideIndices = [];\r\n            var outSideIndices = [];\r\n            var holes = [];\r\n            var outlineIndices = [];\r\n            var sideNormals = [];\r\n            var topNormals = [];\r\n            var enableOutline = StyleUtils.getStyle(this._layout, 'enableOutline', properties);\r\n            var height = StyleUtils.getStyle(this._layout, 'height', properties);\r\n            var sideTexCoordArray = [];\r\n            var texCoordArray = [];\r\n            var isF0 = this.IsF0(featureid);\r\n            var factor = 1.0;\r\n            var zoomRange = [0, 24];\r\n            properties === null || properties === void 0 ? void 0 : properties.id;\r\n            if (isF0 == false && featureid) {\r\n                var featureType = featureid.charAt(9);\r\n                zoomRange = ZoomRangeConfig.zoomRangeTable[parseInt(featureType)];\r\n            }\r\n            var floorStr = this.GetFloor(featureid);\r\n            for (var i = 0; i < polygon.length; i += 1) {\r\n                var face = polygon[i];\r\n                for (var j = 0; j < face.length; j += 1) {\r\n                    var curX = face[j][0] + offset[0];\r\n                    var curY = face[j][1] + offset[1];\r\n                    var sideCount = sideVertices.length / 3;\r\n                    if (j < face.length - 1) {\r\n                        if (enableOutline) {\r\n                            var verticesCount = vertices.length / 3;\r\n                            outlineIndices.push(verticesCount, verticesCount + 1);\r\n                        }\r\n                        new Vector2(face[j], face[j + 1]).normal();\r\n                        sideIndices.push(sideCount + 0, sideCount + 1, sideCount + 2);\r\n                        sideIndices.push(sideCount + 1, sideCount + 2, sideCount + 3);\r\n                        var nextX = face[j + 1][0] + offset[0];\r\n                        var nextY = face[j + 1][1] + offset[1];\r\n                        sideVertices.push(curX, curY, 0);\r\n                        sideVertices.push(curX, curY, 1);\r\n                        sideVertices.push(nextX, nextY, 0);\r\n                        sideVertices.push(nextX, nextY, 1);\r\n                        if (this._bTextureEnable) {\r\n                            sideTexCoordArray.push(curX, curY);\r\n                            sideTexCoordArray.push(curX + 1, curY);\r\n                            sideTexCoordArray.push(curX + 1, curY + 1);\r\n                            sideTexCoordArray.push(curX, curY + 1);\r\n                        }\r\n                    }\r\n                    vertices.push(curX, curY, FillExtrusionBucket.FACTOR + 1);\r\n                    if (this._bTextureEnable) {\r\n                        texCoordArray.push(curX * factor, curY * factor);\r\n                    }\r\n                }\r\n                if (i < polygon.length - 1) {\r\n                    holes.push(vertices.length / 3);\r\n                }\r\n            }\r\n            var indices = earcut_1(vertices, holes.length === 0 ? undefined : holes, 3);\r\n            var topFaceCount = vertices.length / 3;\r\n            for (var i = 0; i < sideIndices.length; i += 1) {\r\n                outSideIndices.push(sideIndices[i]);\r\n            }\r\n            var totalCount = topFaceCount + sideVertices.length / 3;\r\n            var fillColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'fillColor', properties));\r\n            var outlineColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'outlineColor', properties));\r\n            var base = StyleUtils.getStyle(this._layout, 'base', properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);\r\n            var stops = StyleUtils.getStyle(this._layout, 'stops', properties);\r\n            var textureUrl = this.GetTextureByFeatureId(featureid);\r\n            var sideTextureUrl = this.GetSideTextureByFeatureId(featureid);\r\n            if (this.isExtra(properties) == false && textureUrl == '' && sideTextureUrl == '') {\r\n                featureid = '';\r\n            }\r\n            else {\r\n                LogMgr.log('isExtra featureId: ' + featureid);\r\n            }\r\n            var key = this._getGeometryKey2(properties, textureUrl + '-' + sideTextureUrl + '-' + featureid + '-' + height);\r\n            if (this._geometryMap[key] &&\r\n                this._geometryMap[key].vertices.length / 3 + totalCount < 65536) {\r\n                var geometry = this._geometryMap[key];\r\n                var oldVerticesCount = geometry.vertices.length / 3;\r\n                var oldSideVerticesCount = geometry.sideVertices.length / 3;\r\n                geometry.fillIndices.add(indices, oldVerticesCount);\r\n                geometry.sideIndices.add(outSideIndices, oldSideVerticesCount);\r\n                geometry.outlineIndices.add(outlineIndices, oldVerticesCount);\r\n                geometry.vertices = geometry.vertices.concat(vertices);\r\n                geometry.sideVertices = geometry.sideVertices.concat(sideVertices);\r\n                geometry.normals = geometry.normals.concat(topNormals);\r\n                geometry.sideNormals = geometry.sideNormals.concat(sideNormals);\r\n                geometry.floorString = floorStr;\r\n                geometry.featureId = featureid;\r\n                geometry.colorId = properties === null || properties === void 0 ? void 0 : properties.colorid;\r\n                geometry.texCoordArray = geometry.texCoordArray.concat(texCoordArray);\r\n                geometry.sideTexCoordArray = geometry.sideTexCoordArray.concat(sideTexCoordArray);\r\n                geometry.isF0 = isF0;\r\n                geometry.textureUrl = textureUrl;\r\n                geometry.sideTextureUrl = sideTextureUrl;\r\n            }\r\n            else {\r\n                if (this._geometryMap[key]) {\r\n                    this._geometryMap[IdGenerator.getId()] = this._geometryMap[key];\r\n                }\r\n                this._geometryMap[key] = {\r\n                    fillIndices: new Indices(indices),\r\n                    vertices: vertices,\r\n                    sideVertices: sideVertices,\r\n                    normals: topNormals,\r\n                    sideNormals: sideNormals,\r\n                    sideIndices: new Indices(outSideIndices),\r\n                    outlineIndices: new Indices(outlineIndices),\r\n                    zoomRange: zoomRange,\r\n                    floorString: floorStr,\r\n                    featureId: featureid,\r\n                    colorId: properties === null || properties === void 0 ? void 0 : properties.colorid,\r\n                    texCoordArray: texCoordArray,\r\n                    sideTexCoordArray: sideTexCoordArray,\r\n                    fillColor: fillColor,\r\n                    outlineColor: outlineColor,\r\n                    height: height,\r\n                    base: base,\r\n                    opacity: opacity,\r\n                    stops: stops,\r\n                    isF0: isF0,\r\n                    textureUrl: textureUrl,\r\n                    sideTextureUrl: sideTextureUrl,\r\n                };\r\n            }\r\n        };\r\n        FillExtrusionBucket.prototype._getGeometryKey = function (properties) {\r\n            var arr = [];\r\n            for (var i = 0; i < FillExtrusionBucket.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucket.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            return arr.join('-');\r\n        };\r\n        FillExtrusionBucket.prototype._getGeometryKey2 = function (properties, textureUrl) {\r\n            var arr = [];\r\n            for (var i = 0; i < FillExtrusionBucket.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucket.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            arr.push(textureUrl);\r\n            return arr.join('-');\r\n        };\r\n        FillExtrusionBucket.GEOMETRY_KEYS = [\r\n            'fillColor', 'outlineColor', 'height', 'base', 'opacity', 'stops',\r\n        ];\r\n        FillExtrusionBucket.FACTOR = Math.pow(2, 13);\r\n        return FillExtrusionBucket;\r\n    }(AbstractBucket));\n\n    var FillExtrusionBucket2d = (function (_super) {\r\n        __extends(FillExtrusionBucket2d, _super);\r\n        function FillExtrusionBucket2d() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        FillExtrusionBucket2d.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                this._update(this._features[i]);\r\n            }\r\n            this._fireMessage();\r\n        };\r\n        FillExtrusionBucket2d.prototype.clear = function () {\r\n            this._features.length = 0;\r\n            this._geometryMap = {};\r\n        };\r\n        FillExtrusionBucket2d.prototype._fireMessage = function () {\r\n            this._geometryInfo.length = 0;\r\n            for (var key in this._geometryMap) {\r\n                var item = this._geometryMap[key];\r\n                this._geometryInfo.push({\r\n                    vertices: item.vertices,\r\n                    sideVertices: [],\r\n                    fillIndices: item.fillIndices.getValue(),\r\n                    sideIndices: [],\r\n                    outlineIndices: item.outlineIndices.getValue(),\r\n                    fillColor: item.fillColor,\r\n                    outlineColor: item.outlineColor,\r\n                    base: item.base,\r\n                    opacity: item.opacity,\r\n                    normals: item.normals,\r\n                    sideNormals: [],\r\n                    height: 0,\r\n                    stops: item.stops,\r\n                    zoomRange: item.zoomRange,\r\n                    floorString: item.floorString,\r\n                    featureId: item.featureId,\r\n                    colorId: item.colorId,\r\n                    texCoordArray: item.texCoordArray,\r\n                    sideTexCoordArray: [],\r\n                    texCoord: [],\r\n                    texture: null,\r\n                    sideTexture: null,\r\n                    isF0: item.isF0,\r\n                    textureUrl: item.textureUrl,\r\n                    sideTextureUrl: item.sideTextureUrl,\r\n                });\r\n            }\r\n        };\r\n        FillExtrusionBucket2d.prototype.IsHideFeatureByCategoryId = function (categoryid) {\r\n            for (var i = 0; i < this._hideCategoryId.length; i++) {\r\n                if (categoryid == this._hideCategoryId[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        FillExtrusionBucket2d.prototype.IsHideFeatureByColorId = function (colorId) {\r\n            for (var i = 0; i < this._hideColorId.length; i++) {\r\n                if (colorId == this._hideColorId[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        FillExtrusionBucket2d.prototype._update = function (feature) {\r\n            var geometry = feature.geometry, properties = feature.properties, featureid = feature.featureid;\r\n            if (featureid == undefined || featureid == null) {\r\n                featureid = properties === null || properties === void 0 ? void 0 : properties.id;\r\n            }\r\n            if (properties\r\n                && (this.IsHideFeatureByCategoryId(properties.categoryid) || this.IsHideFeatureByColorId(properties.colorid))) {\r\n                LogMgr.log('鏈哄満蹇界暐鏌卞瓙');\r\n                return;\r\n            }\r\n            var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n            if (visible) {\r\n                if (geometry.type === 'Polygon') {\r\n                    this._calcPolygon(geometry.coordinates, properties, featureid);\r\n                }\r\n                else if (geometry.type === 'MultiPolygon') {\r\n                    for (var i = 0; i < geometry.coordinates.length; i += 1) {\r\n                        this._calcPolygon(geometry.coordinates[i], properties, featureid);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        FillExtrusionBucket2d.prototype.isExtra = function (properties) {\r\n            if (properties == null || properties == undefined) {\r\n                return false;\r\n            }\r\n            if (properties.isExtra != null && properties.isExtra != undefined) {\r\n                return properties.isExtra;\r\n            }\r\n            var colorid = properties === null || properties === void 0 ? void 0 : properties.colorid;\r\n            if (colorid == null || colorid == undefined) {\r\n                return false;\r\n            }\r\n            if (colorid == 7 || colorid == 8) {\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        FillExtrusionBucket2d.prototype._calcPolygon = function (polygon, properties, featureid) {\r\n            var offset = this._offset;\r\n            var vertices = [];\r\n            var holes = [];\r\n            var outlineIndices = [];\r\n            var topNormals = [];\r\n            var enableOutline = StyleUtils.getStyle(this._layout, 'enableOutline', properties);\r\n            var height = StyleUtils.getStyle(this._layout, 'height', properties);\r\n            var sideTexCoordArray = [];\r\n            var texCoordArray = [];\r\n            var isF0 = this.IsF0(featureid);\r\n            var factor = 1.0;\r\n            var zoomRange = [0, 24];\r\n            properties === null || properties === void 0 ? void 0 : properties.id;\r\n            if (isF0 == false && featureid) {\r\n                var featureType = featureid.charAt(9);\r\n                zoomRange = ZoomRangeConfig.zoomRangeTable[parseInt(featureType)];\r\n            }\r\n            var floorStr = this.GetFloor(featureid);\r\n            for (var i = 0; i < polygon.length; i += 1) {\r\n                var face = polygon[i];\r\n                for (var j = 0; j < face.length; j += 1) {\r\n                    var curX = face[j][0] + offset[0];\r\n                    var curY = face[j][1] + offset[1];\r\n                    if (j < face.length - 1) {\r\n                        if (enableOutline) {\r\n                            var verticesCount = vertices.length / 3;\r\n                            outlineIndices.push(verticesCount, verticesCount + 1);\r\n                        }\r\n                        new Vector2(face[j], face[j + 1]).normal();\r\n                        face[j + 1][0] + offset[0];\r\n                        face[j + 1][1] + offset[1];\r\n                        if (Global.m_bTextureEnable) {\r\n                            sideTexCoordArray.push(curX, curY);\r\n                            sideTexCoordArray.push(curX + 1, curY);\r\n                            sideTexCoordArray.push(curX + 1, curY + 1);\r\n                            sideTexCoordArray.push(curX, curY + 1);\r\n                        }\r\n                    }\r\n                    vertices.push(curX, curY, FillExtrusionBucket.FACTOR + 1);\r\n                    if (Global.m_bTextureEnable) {\r\n                        texCoordArray.push(curX * factor, curY * factor);\r\n                    }\r\n                }\r\n                if (i < polygon.length - 1) {\r\n                    holes.push(vertices.length / 3);\r\n                }\r\n            }\r\n            var indices = earcut_1(vertices, holes.length === 0 ? undefined : holes, 3);\r\n            var topFaceCount = vertices.length / 3;\r\n            var totalCount = topFaceCount;\r\n            var fillColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'fillColor', properties));\r\n            var outlineColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'outlineColor', properties));\r\n            var base = StyleUtils.getStyle(this._layout, 'base', properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);\r\n            var stops = StyleUtils.getStyle(this._layout, 'stops', properties);\r\n            var featureTextureUrl = this.GetTextureByFeatureId(featureid);\r\n            if (this.isExtra(properties) == false && featureTextureUrl == '') {\r\n                featureid = '';\r\n            }\r\n            else {\r\n                LogMgr.log('isExtra featureId: ' + featureid);\r\n            }\r\n            var key = this._getGeometryKey2(properties, featureTextureUrl + featureid + '-' + height);\r\n            if (this._geometryMap[key] &&\r\n                this._geometryMap[key].vertices.length / 3 + totalCount < 65536) {\r\n                var geometry = this._geometryMap[key];\r\n                var oldVerticesCount = geometry.vertices.length / 3;\r\n                geometry.sideVertices.length / 3;\r\n                geometry.fillIndices.add(indices, oldVerticesCount);\r\n                geometry.outlineIndices.add(outlineIndices, oldVerticesCount);\r\n                geometry.vertices = geometry.vertices.concat(vertices);\r\n                geometry.normals = geometry.normals.concat(topNormals);\r\n                geometry.floorString = floorStr;\r\n                geometry.featureId = featureid;\r\n                geometry.colorId = properties === null || properties === void 0 ? void 0 : properties.colorid;\r\n                geometry.texCoordArray = geometry.texCoordArray.concat(texCoordArray);\r\n                geometry.sideTexCoordArray = geometry.sideTexCoordArray.concat(sideTexCoordArray);\r\n                geometry.isF0 = isF0;\r\n                geometry.textureUrl = featureTextureUrl;\r\n            }\r\n            else {\r\n                if (this._geometryMap[key]) {\r\n                    this._geometryMap[IdGenerator.getId()] = this._geometryMap[key];\r\n                }\r\n                this._geometryMap[key] = {\r\n                    fillIndices: new Indices(indices),\r\n                    vertices: vertices,\r\n                    sideVertices: [],\r\n                    normals: topNormals,\r\n                    sideNormals: [],\r\n                    sideIndices: new Indices([]),\r\n                    outlineIndices: new Indices(outlineIndices),\r\n                    zoomRange: zoomRange,\r\n                    floorString: floorStr,\r\n                    featureId: featureid,\r\n                    colorId: properties === null || properties === void 0 ? void 0 : properties.colorid,\r\n                    texCoordArray: texCoordArray,\r\n                    sideTexCoordArray: [],\r\n                    fillColor: fillColor,\r\n                    outlineColor: outlineColor,\r\n                    height: 0,\r\n                    base: base,\r\n                    opacity: opacity,\r\n                    stops: stops,\r\n                    isF0: isF0,\r\n                    textureUrl: featureTextureUrl,\r\n                    sideTextureUrl: '',\r\n                };\r\n            }\r\n        };\r\n        FillExtrusionBucket2d.prototype._getGeometryKey = function (properties) {\r\n            var arr = [];\r\n            for (var i = 0; i < FillExtrusionBucket.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucket.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            return arr.join('-');\r\n        };\r\n        FillExtrusionBucket2d.prototype._getGeometryKey2 = function (properties, textureUrl) {\r\n            var arr = [];\r\n            for (var i = 0; i < FillExtrusionBucket.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucket.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            arr.push(textureUrl);\r\n            return arr.join('-');\r\n        };\r\n        FillExtrusionBucket2d.GEOMETRY_KEYS = [\r\n            'fillColor', 'outlineColor', 'height', 'base', 'opacity', 'stops',\r\n        ];\r\n        FillExtrusionBucket2d.FACTOR = Math.pow(2, 13);\r\n        return FillExtrusionBucket2d;\r\n    }(FillExtrusionBucket));\n\n    var CircleBucket = (function (_super) {\r\n        __extends(CircleBucket, _super);\r\n        function CircleBucket() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        CircleBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;\r\n                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n                if (visible) {\r\n                    if (geometry.type === 'Point') {\r\n                        this._calcPoint(geometry.coordinates, properties);\r\n                    }\r\n                    else if (geometry.type === 'MultiPoint') {\r\n                        for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                            this._calcPoint(geometry.coordinates[j], properties);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        CircleBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n        };\r\n        CircleBucket.prototype._calcPoint = function (point, properties) {\r\n            var offset = this._offset;\r\n            var p = [point[0] + offset[0], point[1] + offset[1]];\r\n            var color = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'color', properties));\r\n            var base = StyleUtils.getStyle(this._layout, 'base', properties);\r\n            var radius = StyleUtils.getStyle(this._layout, 'radius', properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);\r\n            this._geometryInfo.push({\r\n                color: color,\r\n                base: base,\r\n                point: p,\r\n                radius: radius,\r\n                opacity: opacity,\r\n            });\r\n        };\r\n        return CircleBucket;\r\n    }(AbstractBucket));\n\n    var SymbolBucket = (function (_super) {\r\n        __extends(SymbolBucket, _super);\r\n        function SymbolBucket(data) {\r\n            var _this = _super.call(this, data) || this;\r\n            _this._baseTextSize = data.baseTextSize;\r\n            return _this;\r\n        }\r\n        SymbolBucket.prototype.IsHideFeatureByCategoryId = function (categoryid) {\r\n            for (var i = 0; i < this._hideCategoryId.length; i++) {\r\n                if (categoryid == this._hideCategoryId[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        SymbolBucket.prototype.IsHideFeatureByColorId = function (colorId) {\r\n            for (var i = 0; i < this._hideColorId.length; i++) {\r\n                if (colorId == this._hideColorId[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        SymbolBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties, featureid = _a.featureid;\r\n                if (featureid == undefined || featureid == null || featureid == '') {\r\n                    featureid = properties === null || properties === void 0 ? void 0 : properties.id;\r\n                }\r\n                if (properties\r\n                    && (this.IsHideFeatureByCategoryId(properties.categoryid) || this.IsHideFeatureByColorId(properties.colorid))) {\r\n                    LogMgr.log('鏈哄満蹇界暐鏌卞瓙锛宻ymbol 灞�');\r\n                    return;\r\n                }\r\n                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n                if (visible) {\r\n                    if (geometry.type === 'Point') {\r\n                        this._calcPoint(geometry.coordinates, this._features[i], featureid);\r\n                    }\r\n                    else if (geometry.type === 'MultiPoint') {\r\n                        for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                            this._calcPoint(geometry.coordinates[j], this._features[i], featureid);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        SymbolBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n        };\r\n        SymbolBucket.prototype._calcPoint = function (point, item, featureId) {\r\n            var offset = this._offset;\r\n            var resultPoint = [point[0] + offset[0], point[1] + offset[1]];\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', item.properties);\r\n            var base = StyleUtils.getStyle(this._layout, 'base', item.properties);\r\n            var iconZHeight = StyleUtils.getStyle(this._layout, 'iconZHeight', item.properties);\r\n            var textZHeight = StyleUtils.getStyle(this._layout, 'textZHeight', item.properties);\r\n            if (iconZHeight && textZHeight) {\r\n                base += (iconZHeight + textZHeight) / 2;\r\n            }\r\n            else if (iconZHeight) {\r\n                base += iconZHeight;\r\n            }\r\n            else if (textZHeight) {\r\n                base += textZHeight;\r\n            }\r\n            var imgSymbol = this._calcImage(resultPoint, item, base, opacity);\r\n            var textSymbol = this._calcText(resultPoint, item, base, opacity);\r\n            var isCollision = StyleUtils.getStyle(this._layout, 'collision', item.properties);\r\n            var weight = StyleUtils.getStyle(this._layout, 'weight', item.properties);\r\n            var margin = StyleUtils.getStyle(this._layout, 'margin', item.properties);\r\n            var floorString = this.GetFloor(featureId);\r\n            var zoomRange = StyleUtils.getStyle(this._layout, 'zoomRange', item.properties);\r\n            var collision = {\r\n                point: resultPoint,\r\n                data: [],\r\n                weight: weight,\r\n                margin: margin,\r\n                zoomRange: zoomRange,\r\n                floorString: floorString,\r\n            };\r\n            var arr = [];\r\n            if (imgSymbol && textSymbol) {\r\n                collision.data.push(imgSymbol.collision, textSymbol.collision);\r\n                arr.push(imgSymbol.geometry, textSymbol.geometry);\r\n            }\r\n            else if (imgSymbol) {\r\n                collision.data.push(imgSymbol.collision);\r\n                arr.push(imgSymbol.geometry);\r\n            }\r\n            else if (textSymbol) {\r\n                collision.data.push(textSymbol.collision);\r\n                arr.push(textSymbol.geometry);\r\n            }\r\n            this._geometryInfo.push({\r\n                data: arr,\r\n                floorString: floorString,\r\n                isCollision: isCollision,\r\n                featureId: featureId,\r\n                height: item.properties.height,\r\n                collision: collision\r\n            });\r\n        };\r\n        SymbolBucket.prototype._calcImage = function (point, item, base, opacity) {\r\n            if (!item.iconSize)\r\n                return;\r\n            var iconUrl = StyleUtils.getStyle(this._layout, 'iconImage', item.properties);\r\n            var anchor = StyleUtils.getStyle(this._layout, 'iconAnchor', item.properties);\r\n            var offset = StyleUtils.getStyle(this._layout, 'iconOffset', item.properties);\r\n            var iconSize = StyleUtils.getStyle(this._layout, 'iconSize', item.properties);\r\n            var width = item.iconSize[0] * iconSize;\r\n            var height = item.iconSize[1] * iconSize;\r\n            var _a = createPointGeometry(point, width, height, anchor), vertices = _a.vertices, texCoords = _a.texCoords;\r\n            var geometry = { point: point, vertices: vertices, texCoords: texCoords, offset: offset, base: base, opacity: opacity, iconUrl: iconUrl };\r\n            var collision = { width: width, height: height, anchor: anchor, offset: offset };\r\n            return { geometry: geometry, collision: collision };\r\n        };\r\n        SymbolBucket.prototype._calcText = function (point, item, base, opacity) {\r\n            if (!item.textSize || !item.textArr)\r\n                return;\r\n            var textSize = StyleUtils.getStyle(this._layout, 'textSize', item.properties);\r\n            var anchor = StyleUtils.getStyle(this._layout, 'textAnchor', item.properties);\r\n            var offset = StyleUtils.getStyle(this._layout, 'textOffset', item.properties);\r\n            var width = item.textSize[0] * textSize / this._baseTextSize;\r\n            var height = item.textSize[1] * textSize / this._baseTextSize;\r\n            var textColor = StyleUtils.getStyle(this._layout, 'textColor', item.properties);\r\n            var strokeColor = StyleUtils.getStyle(this._layout, 'textStrokeColor', item.properties);\r\n            var _a = createPointGeometry(point, width, height, anchor), vertices = _a.vertices, texCoords = _a.texCoords;\r\n            var textOptions = {\r\n                textArr: item.textArr,\r\n                width: item.textSize[0],\r\n                height: item.textSize[1],\r\n                fillColor: textColor,\r\n                strokeColor: strokeColor,\r\n            };\r\n            var geometry = {\r\n                point: point,\r\n                vertices: vertices,\r\n                texCoords: texCoords,\r\n                offset: offset,\r\n                base: base,\r\n                opacity: opacity,\r\n                textOptions: textOptions,\r\n            };\r\n            var collision = { width: width, height: height, anchor: anchor, offset: offset };\r\n            return { geometry: geometry, collision: collision };\r\n        };\r\n        return SymbolBucket;\r\n    }(AbstractBucket));\n\n    var ConnectionBucket = (function (_super) {\r\n        __extends(ConnectionBucket, _super);\r\n        function ConnectionBucket() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        ConnectionBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;\r\n                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n                if (visible) {\r\n                    if (geometry.type === 'LineString') {\r\n                        this._calcPolyline(geometry.coordinates, properties);\r\n                    }\r\n                    else if (geometry.type === 'MultiLineString') {\r\n                        for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                            this._calcPolyline(geometry.coordinates[j], properties);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ConnectionBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n        };\r\n        ConnectionBucket.prototype._calcPolyline = function (line, properties) {\r\n            var offset = this._offset;\r\n            var base = StyleUtils.getStyle(this._layout, 'base', properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);\r\n            var color = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'color', properties));\r\n            var width = StyleUtils.getStyle(this._layout, 'width', properties);\r\n            var iconUrl = StyleUtils.getStyle(this._layout, 'icon', properties);\r\n            var tubeUrl = './assets/tube1.png';\r\n            var vertices = [];\r\n            var normals = [];\r\n            var texCoords = [];\r\n            for (var i = 0; i < line.length; i += 1) {\r\n                var point = [line[i][0] + offset[0], line[i][1] + offset[1], line[i][2]];\r\n                if (i === 0) {\r\n                    var start = [line[i][0] + offset[0], line[i][2]];\r\n                    var end = [line[i + 1][0] + offset[0], line[i + 1][2]];\r\n                    var normal = new Vector2(start, end).normal().unit();\r\n                    normals.push(normal.x, normal.y, -normal.x, -normal.y);\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    texCoords.push(0, 1, 0, 0);\r\n                }\r\n                else if (i < line.length - 1) {\r\n                    var last = [line[i - 1][0] + offset[0], line[i - 1][2]];\r\n                    var cur = [line[i][0] + offset[0], line[i][2]];\r\n                    var next = [line[i + 1][0] + offset[0], line[i + 1][2]];\r\n                    var dir1 = new Vector2(last, cur);\r\n                    var normal1 = dir1.normal().unit();\r\n                    normals.push(normal1.x, normal1.y, -normal1.x, -normal1.y);\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    texCoords.push(1 * dir1.getLength(), 1, 1 * dir1.getLength(), 0);\r\n                    var normal2 = new Vector2(cur, next).normal().unit();\r\n                    normals.push(normal2.x, normal2.y, -normal2.x, -normal2.y);\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    texCoords.push(0, 1, 0, 0);\r\n                }\r\n                else {\r\n                    var start = [line[i - 1][0] + offset[0], line[i - 1][2]];\r\n                    var end = [line[i][0] + offset[0], line[i][2]];\r\n                    var dir = new Vector2(start, end);\r\n                    var normal = dir.normal().unit();\r\n                    normals.push(normal.x, normal.y, -normal.x, -normal.y);\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    texCoords.push(1 * dir.getLength(), 1, 1 * dir.getLength(), 0);\r\n                }\r\n            }\r\n            this._geometryInfo.push({\r\n                vertices: vertices,\r\n                normals: normals,\r\n                base: base,\r\n                opacity: opacity,\r\n                width: width,\r\n                color: color,\r\n                iconUrl: iconUrl,\r\n                tubeUrl: tubeUrl,\r\n                texCoords: texCoords,\r\n            });\r\n        };\r\n        return ConnectionBucket;\r\n    }(AbstractBucket));\n\n    var HeatmapBucket = (function (_super) {\r\n        __extends(HeatmapBucket, _super);\r\n        function HeatmapBucket() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        HeatmapBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;\r\n                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n                if (visible) {\r\n                    if (geometry.type === 'Point') {\r\n                        this._calcPoint(geometry.coordinates, properties);\r\n                    }\r\n                    else if (geometry.type === 'MultiPoint') {\r\n                        for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                            this._calcPoint(geometry.coordinates[j], properties);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        HeatmapBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n        };\r\n        HeatmapBucket.prototype._calcPoint = function (point, properties) {\r\n            var offset = this._offset;\r\n            var p = [point[0] + offset[0], point[1] + offset[1]];\r\n            var radius = StyleUtils.getStyle(this._layout, 'radius', properties);\r\n            this._geometryInfo.push({\r\n                point: p,\r\n                radius: radius,\r\n            });\r\n        };\r\n        return HeatmapBucket;\r\n    }(AbstractBucket));\n\n    var LineBucket = (function (_super) {\r\n        __extends(LineBucket, _super);\r\n        function LineBucket() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this._geometryMap = {};\r\n            return _this;\r\n        }\r\n        LineBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                var _a = this._features[i], properties = _a.properties, geometry = _a.geometry;\r\n                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n                if (visible) {\r\n                    if (geometry.type === 'LineString') {\r\n                        this._calcPolyline(geometry.coordinates, properties);\r\n                    }\r\n                    else if (geometry.type === 'MultiLineString') {\r\n                        for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                            this._calcPolyline(geometry.coordinates[j], properties);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (var key in this._geometryMap) {\r\n                this._geometryInfo.push(__assign(__assign({}, this._geometryMap[key]), { indices: this._geometryMap[key].indices.getValue() }));\r\n            }\r\n        };\r\n        LineBucket.prototype.clear = function () {\r\n            this._geometryMap = {};\r\n        };\r\n        LineBucket.prototype._calcPolyline = function (polyline, properties) {\r\n            var offset = this._offset;\r\n            var base = StyleUtils.getStyle(this._layout, 'base', properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);\r\n            var width = StyleUtils.getStyle(this._layout, 'lineWidth', properties);\r\n            var color = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'lineColor', properties));\r\n            var iconUrl = StyleUtils.getStyle(this._layout, 'lineImage', properties);\r\n            var vertices = [];\r\n            var normals = [];\r\n            var deviation = [];\r\n            var texCoords = [];\r\n            var indices = [];\r\n            for (var i = 0; i < polyline.length; i += 1) {\r\n                var point = [polyline[i][0] + offset[0], polyline[i][1] + offset[1]];\r\n                var startNum = vertices.length / 2;\r\n                if (i === 0) {\r\n                    var dir = new Vector2(polyline[i], polyline[i + 1]);\r\n                    var normal = dir.normal().unit();\r\n                    var length1 = dir.getLength();\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    texCoords.push(-1 * length1 * 0.14, 1, -1 * length1 * 0.14, 0);\r\n                    deviation.push(0, 0, 0, 0, 0, 0);\r\n                    normals.push(normal.x, normal.y, -normal.x, -normal.y);\r\n                    indices.push(startNum + 0, startNum + 1);\r\n                }\r\n                else if (i < polyline.length - 1) {\r\n                    var lastPoint = [polyline[i - 1][0] + offset[0], polyline[i - 1][1] + offset[1]];\r\n                    var nextPoint = [polyline[i + 1][0] + offset[0], polyline[i + 1][1] + offset[1]];\r\n                    var dir1 = new Vector2(lastPoint, point);\r\n                    var length1 = dir1.getLength();\r\n                    var unitDir1 = dir1.unit();\r\n                    var normal1 = unitDir1.normal();\r\n                    var dir2 = new Vector2(point, nextPoint);\r\n                    var length2 = dir2.getLength();\r\n                    var unitDir2 = dir2.unit();\r\n                    var normal2 = unitDir2.normal();\r\n                    var angle = Math.abs(normal1.angleTo(normal2));\r\n                    angle = angle === 180 ? 0 : angle;\r\n                    angle = angle / 180 * Math.PI;\r\n                    var offsetNum = Math.tan(angle / 2);\r\n                    unitDir1.multiply(-offsetNum);\r\n                    unitDir2.multiply(offsetNum);\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    texCoords.push(1 * length1, 1, 1 * length1, 0);\r\n                    deviation.push(unitDir1.x, unitDir1.y, length1, unitDir1.x, unitDir1.y, length1);\r\n                    indices.push(startNum, startNum - 1, startNum, startNum + 1);\r\n                    normals.push(normal1.x, normal1.y, -normal1.x, -normal1.y);\r\n                    var flat = normal1.cross(normal2) <= 0 ? -1 : 1;\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    texCoords.push(0, flat === -1 ? 1 : 0, 0, flat === -1 ? 0 : 0.93);\r\n                    deviation.push(unitDir1.x, unitDir1.y, length1, unitDir1.x, unitDir1.y, length1);\r\n                    normals.push(normal1.x, normal1.y, -normal1.x, -normal1.y);\r\n                    startNum += 2;\r\n                    var _a = LineBucket.getLineJoin(point, normal1, normal2, vertices.length / 2), subIndices = _a.indices, subVertices = _a.vertices, subNormals = _a.normals, subTexCoords = _a.texCoords, subDeviation = _a.deviation;\r\n                    vertices.push.apply(vertices, subVertices);\r\n                    indices.push.apply(indices, subIndices);\r\n                    normals.push.apply(normals, subNormals);\r\n                    deviation.push.apply(deviation, subDeviation);\r\n                    texCoords.push.apply(texCoords, subTexCoords);\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    texCoords.push(0, flat === -1 ? 1 : 0, 0, flat === -1 ? 0 : 0.93);\r\n                    deviation.push(unitDir2.x, unitDir2.y, length2, unitDir2.x, unitDir2.y, length2);\r\n                    normals.push(normal2.x, normal2.y, -normal2.x, -normal2.y);\r\n                    startNum += 2;\r\n                    var subNum = subVertices.length / 2;\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    texCoords.push(0, 1, 0, 0);\r\n                    deviation.push(unitDir2.x, unitDir2.y, length2, unitDir2.x, unitDir2.y, length2);\r\n                    indices.push(startNum + 2 + subNum, startNum + 3 + subNum);\r\n                    normals.push(normal2.x, normal2.y, -normal2.x, -normal2.y);\r\n                }\r\n                else {\r\n                    var lastPoint = [polyline[i - 1][0] + offset[0], polyline[i - 1][1] + offset[1]];\r\n                    var dir = new Vector2(lastPoint, point);\r\n                    var length = dir.getLength();\r\n                    var normal = dir.normal().unit();\r\n                    vertices.push.apply(vertices, __spreadArrays(point, point));\r\n                    deviation.push(0, 0, 0, 0, 0, 0);\r\n                    texCoords.push(1 * length, 1, 1 * length, 0);\r\n                    indices.push(startNum, startNum - 1, startNum, startNum + 1);\r\n                    normals.push(normal.x, normal.y, -normal.x, -normal.y);\r\n                }\r\n            }\r\n            var key = this._getGeometryKey(properties);\r\n            if (this._geometryMap[key] &&\r\n                this._geometryMap[key].vertices.length / 2 + vertices.length / 2 < 65536) {\r\n                var geometry = this._geometryMap[key];\r\n                var oldVerticesCount = geometry.vertices.length / 2;\r\n                geometry.indices.add(indices, oldVerticesCount);\r\n                geometry.vertices = geometry.vertices.concat(vertices);\r\n                geometry.texCoords = geometry.texCoords.concat(texCoords);\r\n                geometry.normals = geometry.normals.concat(normals);\r\n                geometry.deviation = geometry.deviation.concat(deviation);\r\n            }\r\n            else {\r\n                this._geometryMap[key] = {\r\n                    vertices: vertices,\r\n                    normals: normals,\r\n                    base: base,\r\n                    opacity: opacity,\r\n                    width: width,\r\n                    color: color,\r\n                    deviation: deviation,\r\n                    iconUrl: iconUrl,\r\n                    texCoords: texCoords,\r\n                    indices: new Indices(indices),\r\n                };\r\n            }\r\n        };\r\n        LineBucket.prototype._getGeometryKey = function (properties) {\r\n            var arr = [];\r\n            for (var i = 0; i < LineBucket.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, LineBucket.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            return arr.join('-');\r\n        };\r\n        LineBucket.getLineJoin = function (point, v0, v1, indexOffset) {\r\n            var vertices = [];\r\n            var texCoords = [];\r\n            var deviation = [];\r\n            var normals = [];\r\n            var indices = [];\r\n            var step = Math.PI / 16;\r\n            var maxAngle = Math.abs(v0.angleTo(v1)) / 180 * Math.PI + step;\r\n            var dir = v0.clone().add(v1).unit();\r\n            var normal = dir.normal();\r\n            var dir1Normal = v0.unit().normal();\r\n            var num = 1 / normal.dot(dir1Normal);\r\n            var flat = v0.cross(v1) <= 0 ? -1 : 1;\r\n            dir.multiply(num * flat);\r\n            vertices.push.apply(vertices, point);\r\n            texCoords.push(0, 0.7);\r\n            deviation.push(0, 0, 0);\r\n            normals.push(0, 0);\r\n            if (maxAngle > step) {\r\n                indices.push(indexOffset - 1, indexOffset, indexOffset + 1, indexOffset - 2, indexOffset - 1, flat === -1 ? indexOffset + 1 : indexOffset);\r\n            }\r\n            var v0_scale = v0.clone().multiply(-1 * flat);\r\n            var index = indexOffset;\r\n            for (var angle = 0; angle < maxAngle; angle += step) {\r\n                var rotateVector = v0_scale.clone().rotate(angle * flat);\r\n                vertices.push.apply(vertices, point);\r\n                texCoords.push(0, 0.93);\r\n                deviation.push(0, 0, 0);\r\n                normals.push(rotateVector.x, rotateVector.y);\r\n                if (angle + step < maxAngle) {\r\n                    indices.push(indexOffset + 0);\r\n                    indices.push(index + 1);\r\n                    indices.push(index + 2);\r\n                }\r\n                else {\r\n                    indices.push(indexOffset, index + 1, index + 3, flat === -1 ? index + 1 : indexOffset, index + 2, index + 3);\r\n                }\r\n                index += 1;\r\n            }\r\n            return { vertices: vertices, indices: indices, normals: normals, texCoords: texCoords, deviation: deviation };\r\n        };\r\n        LineBucket.GEOMETRY_KEYS = [\r\n            'lineColor', 'lineWidth', 'base', 'opacity', 'lineImage',\r\n        ];\r\n        return LineBucket;\r\n    }(AbstractBucket));\n\n    var ModelBucket = (function (_super) {\r\n        __extends(ModelBucket, _super);\r\n        function ModelBucket() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        ModelBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties, featureid = _a.featureid;\r\n                if (featureid == undefined) {\r\n                    if ((properties === null || properties === void 0 ? void 0 : properties.featureid) != null && (properties === null || properties === void 0 ? void 0 : properties.featureid) != undefined) {\r\n                        featureid = properties === null || properties === void 0 ? void 0 : properties.featureid;\r\n                    }\r\n                    else if ((properties === null || properties === void 0 ? void 0 : properties.id) != null && (properties === null || properties === void 0 ? void 0 : properties.id) != undefined) {\r\n                        featureid = properties === null || properties === void 0 ? void 0 : properties.id;\r\n                    }\r\n                }\r\n                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n                if (visible) {\r\n                    if (geometry.type === 'Point') {\r\n                        this._calcPoint(geometry.coordinates, properties, featureid);\r\n                    }\r\n                    else if (geometry.type === 'MultiPoint') {\r\n                        for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                            this._calcPoint(geometry.coordinates[j], properties, featureid);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        ModelBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n        };\r\n        ModelBucket.prototype._calcPoint = function (point, properties, featureId) {\r\n            var url = StyleUtils.getStyle(this._layout, 'url', properties);\r\n            if (!url)\r\n                return;\r\n            var offset = this._offset;\r\n            var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n            if (!visible)\r\n                return;\r\n            var matrix = new Matrix4();\r\n            var p = [point[0] + offset[0], point[1] + offset[1]];\r\n            var offsetArr = StyleUtils.getStyle(this._layout, 'offset', properties);\r\n            if (offsetArr) {\r\n                p[0] += offsetArr[0];\r\n                p[1] += offsetArr[1];\r\n            }\r\n            var base = StyleUtils.getStyle(this._layout, 'base', properties);\r\n            var size = StyleUtils.getStyle(this._layout, 'size', properties);\r\n            var rotateX = StyleUtils.getStyle(this._layout, 'rotateX', properties);\r\n            var rotateY = StyleUtils.getStyle(this._layout, 'rotateY', properties);\r\n            var rotateZ = StyleUtils.getStyle(this._layout, 'rotateZ', properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);\r\n            var stops = StyleUtils.getStyle(this._layout, 'stops', properties);\r\n            var brightness = StyleUtils.getStyle(this._layout, 'brightness', properties);\r\n            var isExtra = false;\r\n            if (properties == null || properties == undefined) {\r\n                isExtra = false;\r\n            }\r\n            else {\r\n                if (properties.isExtra == null || properties.isExtra == undefined) {\r\n                    isExtra = false;\r\n                }\r\n                else {\r\n                    isExtra = properties.isExtra;\r\n                }\r\n            }\r\n            if (brightness === null || brightness === undefined) {\r\n                brightness = 1.0;\r\n            }\r\n            matrix.scale(size, size, size);\r\n            matrix.rotate(rotateX, 1, 0, 0);\r\n            matrix.rotate(rotateY, 0, 1, 0);\r\n            matrix.rotate(rotateZ, 0, 0, 1);\r\n            this._geometryInfo.push({\r\n                matrix: matrix.getValue(),\r\n                opacity: opacity,\r\n                point: p,\r\n                base: base,\r\n                url: url,\r\n                stops: stops,\r\n                brightness: brightness,\r\n                featureId: featureId,\r\n                isExtra: isExtra,\r\n            });\r\n        };\r\n        return ModelBucket;\r\n    }(AbstractBucket));\n\n    var TrackBucket = (function (_super) {\r\n        __extends(TrackBucket, _super);\r\n        function TrackBucket() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this._geometryMap = {};\r\n            return _this;\r\n        }\r\n        TrackBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;\r\n                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n                if (visible) {\r\n                    if (geometry.type === 'LineString') {\r\n                        this._calcPolyline(geometry.coordinates, properties);\r\n                    }\r\n                    else if (geometry.type === 'MultiLineString') {\r\n                        for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                            this._calcPolyline(geometry.coordinates[j], properties);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            for (var key in this._geometryMap) {\r\n                this._geometryInfo.push(__assign(__assign({}, this._geometryMap[key]), { indices: this._geometryMap[key].indices.getValue() }));\r\n            }\r\n        };\r\n        TrackBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n            this._geometryMap = {};\r\n        };\r\n        TrackBucket.prototype._calcPolyline = function (polyline, properties) {\r\n            if (polyline.length < 2)\r\n                return;\r\n            var vertices = [];\r\n            var offset = this._offset;\r\n            var indices = [];\r\n            for (var i = 0; i < polyline.length; i += 1) {\r\n                var _a = polyline[i], x = _a[0], y = _a[1];\r\n                vertices.push(x + offset[0], y + offset[1]);\r\n                if (i + 1 < polyline.length) {\r\n                    indices.push(i, i + 1);\r\n                }\r\n            }\r\n            var color = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'color', properties));\r\n            var base = StyleUtils.getStyle(this._layout, 'base', properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);\r\n            var key = this._getGeometryKey(properties);\r\n            if (this._geometryMap[key] &&\r\n                this._geometryMap[key].vertices.length / 2 + vertices.length / 2 < 65536) {\r\n                var geometry = this._geometryMap[key];\r\n                var oldVerticesCount = geometry.vertices.length / 2;\r\n                geometry.indices.add(indices, oldVerticesCount);\r\n                geometry.vertices = geometry.vertices.concat(vertices);\r\n            }\r\n            else {\r\n                if (this._geometryMap[key]) {\r\n                    this._geometryMap[IdGenerator.getId()] = this._geometryMap[key];\r\n                }\r\n                this._geometryMap[key] = {\r\n                    vertices: vertices,\r\n                    color: color,\r\n                    base: base,\r\n                    indices: new Indices(indices),\r\n                    opacity: opacity,\r\n                };\r\n            }\r\n        };\r\n        TrackBucket.prototype._getGeometryKey = function (properties) {\r\n            var arr = [];\r\n            for (var i = 0; i < TrackBucket.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, TrackBucket.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            return arr.join('-');\r\n        };\r\n        TrackBucket.GEOMETRY_KEYS = ['color', 'base', 'opacity'];\r\n        return TrackBucket;\r\n    }(AbstractBucket));\n\n    var PictureBucket = (function (_super) {\r\n        __extends(PictureBucket, _super);\r\n        function PictureBucket() {\r\n            return _super !== null && _super.apply(this, arguments) || this;\r\n        }\r\n        PictureBucket.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;\r\n                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n                if (visible) {\r\n                    if (geometry.type === 'Point') {\r\n                        this._calcPoint(geometry.coordinates, this._features[i]);\r\n                    }\r\n                    else if (geometry.type === 'MultiPoint') {\r\n                        for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                            this._calcPoint(geometry.coordinates[j], this._features[i]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        PictureBucket.prototype.clear = function () {\r\n            this._features.length = 0;\r\n        };\r\n        PictureBucket.prototype._calcPoint = function (point, item) {\r\n            var offset = this._offset;\r\n            var iconUrl = StyleUtils.getStyle(this._layout, 'iconImage', item.properties);\r\n            if (!iconUrl)\r\n                return;\r\n            var p = [point[0] + offset[0], point[1] + offset[1]];\r\n            var offsetArr = StyleUtils.getStyle(this._layout, 'offset', item.properties);\r\n            if (offsetArr) {\r\n                p[0] += offsetArr[0];\r\n                p[1] += offsetArr[1];\r\n            }\r\n            var base = StyleUtils.getStyle(this._layout, 'base', item.properties);\r\n            var size = StyleUtils.getStyle(this._layout, 'size', item.properties);\r\n            var rotate = StyleUtils.getStyle(this._layout, 'rotate', item.properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', item.properties);\r\n            var anchor = StyleUtils.getStyle(this._layout, 'anchor', item.properties);\r\n            var width = item.imgSize[0] * size;\r\n            var height = item.imgSize[1] * size;\r\n            var geometry = createPointGeometry(p, width, height, anchor);\r\n            this._geometryInfo.push({\r\n                opacity: opacity,\r\n                base: base,\r\n                rotate: rotate,\r\n                point: p,\r\n                vertices: geometry.vertices,\r\n                iconUrl: iconUrl,\r\n                texCoords: geometry.texCoords,\r\n                index: item.index,\r\n            });\r\n        };\r\n        return PictureBucket;\r\n    }(AbstractBucket));\n\n    var FillExtrusionBucketNoCut = (function (_super) {\r\n        __extends(FillExtrusionBucketNoCut, _super);\r\n        function FillExtrusionBucketNoCut() {\r\n            var _this = _super !== null && _super.apply(this, arguments) || this;\r\n            _this._geometryMap = {};\r\n            return _this;\r\n        }\r\n        FillExtrusionBucketNoCut.prototype.init = function () {\r\n            for (var i = 0; i < this._features.length; i += 1) {\r\n                this._update(this._features[i]);\r\n            }\r\n            this._fireMessage();\r\n        };\r\n        FillExtrusionBucketNoCut.prototype.clear = function () {\r\n            this._features.length = 0;\r\n            this._geometryMap = {};\r\n        };\r\n        FillExtrusionBucketNoCut.prototype._fireMessage = function () {\r\n            this._geometryInfo.length = 0;\r\n            for (var key in this._geometryMap) {\r\n                var item = this._geometryMap[key];\r\n                this._geometryInfo.push({\r\n                    vertices: item.vertices,\r\n                    sideVertices: [],\r\n                    fillIndices: item.fillIndices.getValue(),\r\n                    sideIndices: [],\r\n                    outlineIndices: item.outlineIndices.getValue(),\r\n                    fillColor: item.fillColor,\r\n                    outlineColor: item.outlineColor,\r\n                    base: item.base,\r\n                    opacity: item.opacity,\r\n                    normals: item.normals,\r\n                    sideNormals: [],\r\n                    height: item.height,\r\n                    stops: item.stops,\r\n                    zoomRange: item.zoomRange,\r\n                    floorString: item.floorString,\r\n                    featureId: item.featureId,\r\n                    colorId: item.colorId,\r\n                    texCoordArray: item.texCoordArray,\r\n                    sideTexCoordArray: [],\r\n                    texCoord: [],\r\n                    texture: null,\r\n                    sideTexture: null,\r\n                    isF0: item.isF0,\r\n                    textureUrl: item.textureUrl,\r\n                    sideTextureUrl: item.sideTextureUrl\r\n                });\r\n            }\r\n        };\r\n        FillExtrusionBucketNoCut.prototype.IsHideFeatureByCategoryId = function (categoryid) {\r\n            for (var i = 0; i < this._hideCategoryId.length; i++) {\r\n                if (categoryid == this._hideCategoryId[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        FillExtrusionBucketNoCut.prototype.isExtra = function (properties) {\r\n            if (properties == null || properties == undefined) {\r\n                return false;\r\n            }\r\n            if (properties.isExtra != null && properties.isExtra != undefined) {\r\n                return properties.isExtra;\r\n            }\r\n            var colorid = properties === null || properties === void 0 ? void 0 : properties.colorid;\r\n            if (colorid == null || colorid == undefined) {\r\n                return false;\r\n            }\r\n            if (colorid == 7 || colorid == 8) {\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n        FillExtrusionBucketNoCut.prototype.IsHideFeatureByColorId = function (colorId) {\r\n            for (var i = 0; i < this._hideColorId.length; i++) {\r\n                if (colorId == this._hideColorId[i]) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        FillExtrusionBucketNoCut.prototype._update = function (feature) {\r\n            var geometry = feature.geometry, properties = feature.properties, featureid = feature.featureid;\r\n            if (featureid == undefined || featureid == null) {\r\n                featureid = properties === null || properties === void 0 ? void 0 : properties.id;\r\n            }\r\n            if (properties\r\n                && (this.IsHideFeatureByCategoryId(properties.categoryid) || this.IsHideFeatureByColorId(properties.colorid))) {\r\n                LogMgr.log('鏈哄満蹇界暐鏌卞瓙');\r\n                return;\r\n            }\r\n            var visible = StyleUtils.getStyle(this._layout, 'visible', properties);\r\n            if (visible) {\r\n                if (geometry.type === 'Polygon') {\r\n                    this._calcPolygon(geometry.coordinates, properties, featureid);\r\n                }\r\n                else if (geometry.type === 'MultiPolygon') {\r\n                    for (var i = 0; i < geometry.coordinates.length; i += 1) {\r\n                        this._calcPolygon(geometry.coordinates[i], properties, featureid);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        FillExtrusionBucketNoCut.prototype._calcPolygon = function (polygon, properties, featureid) {\r\n            var offset = this._offset;\r\n            var vertices = [];\r\n            var sideVertices = [];\r\n            var sideIndices = [];\r\n            var holes = [];\r\n            var outlineIndices = [];\r\n            var normals = [];\r\n            var topNormals = [];\r\n            var enableOutline = StyleUtils.getStyle(this._layout, 'enableOutline', properties);\r\n            var height = StyleUtils.getStyle(this._layout, 'height', properties);\r\n            var texCoordArray = [];\r\n            var isF0 = this.IsF0(featureid);\r\n            var factor = 1.0;\r\n            var zoomRange = [0, 24];\r\n            properties === null || properties === void 0 ? void 0 : properties.id;\r\n            if (isF0 == false && featureid) {\r\n                var featureType = featureid.charAt(9);\r\n                zoomRange = ZoomRangeConfig.zoomRangeTable[parseInt(featureType)];\r\n            }\r\n            var floorStr = this.GetFloor(featureid);\r\n            for (var i = 0; i < polygon.length; i += 1) {\r\n                var face = polygon[i];\r\n                for (var j = 0; j < face.length; j += 1) {\r\n                    var curX = face[j][0] + offset[0];\r\n                    var curY = face[j][1] + offset[1];\r\n                    var sideCount = sideVertices.length / 3;\r\n                    if (j < face.length - 1) {\r\n                        if (enableOutline) {\r\n                            var verticesCount = vertices.length / 3;\r\n                            outlineIndices.push(verticesCount, verticesCount + 1);\r\n                        }\r\n                        var normalVector = new Vector2(face[j], face[j + 1]).normal();\r\n                        normals.push(normalVector.x, normalVector.y, 0);\r\n                        normals.push(normalVector.x, normalVector.y, 1);\r\n                        normals.push(normalVector.x, normalVector.y, 0);\r\n                        normals.push(normalVector.x, normalVector.y, 1);\r\n                        var nextX = face[j + 1][0] + offset[0];\r\n                        var nextY = face[j + 1][1] + offset[1];\r\n                        sideVertices.push(curX, curY, 0);\r\n                        sideVertices.push(curX, curY, 1);\r\n                        sideVertices.push(nextX, nextY, 0);\r\n                        sideVertices.push(nextX, nextY, 1);\r\n                        sideIndices.push(sideCount + 0, sideCount + 1, sideCount + 2);\r\n                        sideIndices.push(sideCount + 1, sideCount + 2, sideCount + 3);\r\n                    }\r\n                    topNormals.push(0, 0, FillExtrusionBucketNoCut.FACTOR + 1);\r\n                    vertices.push(curX, curY, FillExtrusionBucketNoCut.FACTOR + 1);\r\n                    if (Global.m_bTextureEnable) {\r\n                        texCoordArray.push(curX * factor, curY * factor);\r\n                    }\r\n                }\r\n                if (i < polygon.length - 1) {\r\n                    holes.push(vertices.length / 3);\r\n                }\r\n            }\r\n            var indices = earcut_1(vertices, holes.length === 0 ? undefined : holes, 3);\r\n            var topFaceCount = vertices.length / 3;\r\n            for (var i = 0; i < sideIndices.length; i += 1) {\r\n                indices.push(sideIndices[i] + topFaceCount);\r\n            }\r\n            var totalCount = topFaceCount + sideVertices.length / 3;\r\n            var fillColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'fillColor', properties));\r\n            var outlineColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'outlineColor', properties));\r\n            var base = StyleUtils.getStyle(this._layout, 'base', properties);\r\n            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);\r\n            var stops = StyleUtils.getStyle(this._layout, 'stops', properties);\r\n            var featureTextureUrl = this.GetTextureByFeatureId(featureid);\r\n            if (this.isExtra(properties) == false && featureTextureUrl == '') {\r\n                featureid = '';\r\n            }\r\n            else {\r\n                LogMgr.log('isExtra featureId: ' + featureid);\r\n            }\r\n            var key = this._getGeometryKey2(properties, featureTextureUrl + featureid + '-' + height);\r\n            if (this._geometryMap[key] &&\r\n                this._geometryMap[key].vertices.length / 3 + totalCount < 65536) {\r\n                var geometry = this._geometryMap[key];\r\n                var oldVerticesCount = geometry.vertices.length / 3;\r\n                geometry.fillIndices.add(indices, oldVerticesCount);\r\n                geometry.outlineIndices.add(outlineIndices, oldVerticesCount);\r\n                geometry.vertices = geometry.vertices.concat(vertices).concat(sideVertices);\r\n                geometry.normals = geometry.normals.concat(topNormals).concat(normals);\r\n                geometry.floorString = floorStr;\r\n                geometry.featureId = featureid;\r\n                geometry.colorId = properties === null || properties === void 0 ? void 0 : properties.colorid;\r\n                geometry.texCoordArray = geometry.texCoordArray.concat(texCoordArray);\r\n                geometry.isF0 = isF0;\r\n                geometry.textureUrl = featureTextureUrl;\r\n                geometry.sideTextureUrl = '';\r\n            }\r\n            else {\r\n                if (this._geometryMap[key]) {\r\n                    this._geometryMap[IdGenerator.getId()] = this._geometryMap[key];\r\n                }\r\n                this._geometryMap[key] = {\r\n                    fillIndices: new Indices(indices),\r\n                    vertices: vertices.concat(sideVertices),\r\n                    normals: topNormals.concat(normals),\r\n                    outlineIndices: new Indices(outlineIndices),\r\n                    zoomRange: zoomRange,\r\n                    floorString: floorStr,\r\n                    featureId: featureid,\r\n                    colorId: properties === null || properties === void 0 ? void 0 : properties.colorid,\r\n                    texCoordArray: texCoordArray,\r\n                    fillColor: fillColor,\r\n                    outlineColor: outlineColor,\r\n                    height: height,\r\n                    base: base,\r\n                    opacity: opacity,\r\n                    stops: stops,\r\n                    isF0: isF0,\r\n                    textureUrl: featureTextureUrl,\r\n                    sideTextureUrl: '',\r\n                };\r\n            }\r\n        };\r\n        FillExtrusionBucketNoCut.prototype._getGeometryKey = function (properties) {\r\n            var arr = [];\r\n            for (var i = 0; i < FillExtrusionBucketNoCut.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucketNoCut.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            return arr.join('-');\r\n        };\r\n        FillExtrusionBucketNoCut.prototype._getGeometryKey2 = function (properties, textureUrl) {\r\n            var arr = [];\r\n            for (var i = 0; i < FillExtrusionBucketNoCut.GEOMETRY_KEYS.length; i += 1) {\r\n                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucketNoCut.GEOMETRY_KEYS[i], properties);\r\n                style !== undefined && arr.push(style);\r\n            }\r\n            arr.push(textureUrl);\r\n            return arr.join('-');\r\n        };\r\n        FillExtrusionBucketNoCut.GEOMETRY_KEYS = [\r\n            'fillColor', 'outlineColor', 'height', 'base', 'opacity', 'stops',\r\n        ];\r\n        FillExtrusionBucketNoCut.FACTOR = Math.pow(2, 13);\r\n        return FillExtrusionBucketNoCut;\r\n    }(AbstractBucket));\n\n    var BucketFactor = (function () {\r\n        function BucketFactor() {\r\n        }\r\n        BucketFactor.prototype.calculate = function (data) {\r\n            var bucket;\r\n            var result = null;\r\n            if (data.type === 'fill') {\r\n                bucket = new FillBucket(data);\r\n            }\r\n            else if (data.type === 'fillExtrusion') {\r\n                var bOnly2d = data.bOnly2d;\r\n                var bCutFeature = data.bCutFeature;\r\n                if (bOnly2d) {\r\n                    bucket = new FillExtrusionBucket2d(data);\r\n                }\r\n                else if (bCutFeature) {\r\n                    bucket = new FillExtrusionBucket(data);\r\n                }\r\n                else {\r\n                    bucket = new FillExtrusionBucketNoCut(data);\r\n                    LogMgr.log('use no cut fillExtrusion.');\r\n                }\r\n            }\r\n            else if (data.type === 'circle') {\r\n                bucket = new CircleBucket(data);\r\n            }\r\n            else if (data.type === 'symbol') {\r\n                bucket = new SymbolBucket(data);\r\n            }\r\n            else if (data.type === 'connection') {\r\n                bucket = new ConnectionBucket(data);\r\n            }\r\n            else if (data.type === 'heatmap') {\r\n                bucket = new HeatmapBucket(data);\r\n            }\r\n            else if (data.type === 'line') {\r\n                bucket = new LineBucket(data);\r\n            }\r\n            else if (data.type === 'model') {\r\n                bucket = new ModelBucket(data);\r\n            }\r\n            else if (data.type === 'track') {\r\n                bucket = new TrackBucket(data);\r\n            }\r\n            else if (data.type === 'picture') {\r\n                bucket = new PictureBucket(data);\r\n            }\r\n            if (bucket) {\r\n                bucket.init();\r\n                result = bucket.getDrawInfo();\r\n                bucket.clear();\r\n            }\r\n            return result;\r\n        };\r\n        return BucketFactor;\r\n    }());\n\n    var factor = new BucketFactor();\r\n    function calcBucket(data) {\r\n        var result = factor.calculate(data);\r\n        result && postMessage(result);\r\n    }\n\n    onmessage = function (_a) {\r\n        var data = _a.data;\r\n        if (data.type === 'collision') {\r\n            calcCollision(data);\r\n        }\r\n        else {\r\n            calcBucket(data);\r\n        }\r\n    };\n\n})();\n");

    var CollisionManager = (function (_super) {
        __extends$1(CollisionManager, _super);
        function CollisionManager(camera, options) {
            var _this = _super.call(this) || this;
            _this._collisionList = new ArraySet();
            _this._worker = new Worker$2();
            _this._updateQueue = [];
            _this._normalResult = { data: {}, opacity: 1 };
            _this._camera = camera;
            bindAll([
                '_onMessage',
                '_frameUpdate',
            ], _this);
            _this._options = options;
            _this._step = 1 / Math.floor(options.animateDuration / 16);
            _this._worker.addEventListener('message', _this._onMessage);
            return _this;
        }
        CollisionManager.prototype.getStep = function () {
            return this._step;
        };
        CollisionManager.prototype._frameUpdate = function () {
            if (this._updateQueue.length !== 0) {
                var params = this._updateQueue.shift();
                this._update(params);
            }
            else {
                this._stopFrameUpdate();
            }
        };
        CollisionManager.prototype._startFrameUpdate = function () {
            if (!this._updateTimer) {
                this._frameUpdate();
                var interval = Math.max(this._options.collisionDuration, this._options.animateDuration);
                this._updateTimer = window.setInterval(this._frameUpdate, interval);
            }
        };
        CollisionManager.prototype._stopFrameUpdate = function () {
            if (this._updateTimer) {
                clearInterval(this._updateTimer);
                delete this._updateTimer;
            }
        };
        CollisionManager.prototype._onMessage = function (e) {
            var result = e.data;
            if (result.type === 'collisionResult') {
                var hideResult = result.hideResult, showResult = result.showResult, normalResult = result.normalResult;
                this._hideResult = { data: hideResult, opacity: 1 };
                this._showResult = { data: showResult, opacity: 0 };
                this._normalResult = { data: normalResult, opacity: 1 };
                this.fire('change', result);
            }
        };
        CollisionManager.prototype.getHideResult = function () {
            return this._hideResult;
        };
        CollisionManager.prototype.getShowResult = function () {
            return this._showResult;
        };
        CollisionManager.prototype.getNormalResult = function () {
            return this._normalResult;
        };
        CollisionManager.prototype.isNeedCollisionRender = function () {
            return Boolean(this._hideResult || this._showResult);
        };
        CollisionManager.prototype.updateFadeResult = function () {
            if (this._showResult) {
                this._showResult.opacity += this._step;
                if (this._showResult.opacity >= 1) {
                    for (var key in this._showResult.data) {
                        var value = this._showResult.data[key];
                        var item = this._normalResult.data[key];
                        if (item) {
                            item.push.apply(item, value);
                        }
                        else {
                            this._normalResult.data[key] = value;
                        }
                    }
                    delete this._showResult;
                }
            }
            if (this._hideResult) {
                this._hideResult.opacity -= this._step;
                if (this._hideResult.opacity <= 0) {
                    delete this._hideResult;
                }
            }
        };
        CollisionManager.prototype.add = function (item) {
            this._collisionList.set(item);
        };
        CollisionManager.prototype.remove = function (item) {
            this._collisionList.delete(item);
        };
        CollisionManager.prototype.clear = function () {
            this._collisionList.clear();
        };
        CollisionManager.prototype.update = function (isForce) {
            if (isForce) {
                this._updateQueue.length = 0;
                this._update(true);
                return;
            }
            if (this._updateQueue.length === 0) {
                this._updateQueue.push(false);
            }
            this._startFrameUpdate();
        };
        CollisionManager.prototype._update = function (isForce) {
            var _a = this._options, viewHeight = _a.viewHeight, viewWidth = _a.viewWidth;
            var center = this._camera.getCenter();
            var offset = this._camera.getOffset();
            var collisionData = {
                type: 'collision',
                isForce: isForce,
                zoom: this._camera.getZoom(),
                z: this._camera.getZ(),
                center: { x: center.x + offset[0], y: center.y + offset[1] },
                valueZ: this._camera.viewMatrix[10],
                pixelMatrix: this._camera.pixelMatrix,
                onePixelToWorld: this._camera.getOnePixelToWorld(),
                view: { viewWidth: viewWidth, viewHeight: viewHeight },
                list: this._collisionList.getValues(),
            };
            this._worker.postMessage(collisionData);
        };
        CollisionManager.prototype.destroy = function () {
            this._worker.terminate();
            this.clear();
            this.clearRegister();
        };
        CollisionManager.prototype.resize = function (width, height) {
            this._options.viewWidth = width;
            this._options.viewHeight = height;
        };
        return CollisionManager;
    }(NCore$1));

    var Canvas2d = (function () {
        function Canvas2d() {
            this._width = 1080;
            this._height = 960;
            this._pixelRatio = devicePixelRatio;
            this._canvas = document.createElement('canvas');
            this._setupCanvasWidth(this._width);
            this._setupCanvasHeight(this._height);
            this._ctx = this._canvas.getContext('2d');
        }
        Canvas2d.prototype._setupCanvasWidth = function (width) {
            this._canvas.width = width * this._pixelRatio;
            this._canvas.style.width = width + "px";
        };
        Canvas2d.prototype._setupCanvasHeight = function (height) {
            this._canvas.height = height * this._pixelRatio;
            this._canvas.style.height = height + "px";
        };
        Canvas2d.prototype.getWidth = function () {
            return this._width;
        };
        Canvas2d.prototype.getHeight = function () {
            return this._height;
        };
        return Canvas2d;
    }());

    var TextureManager = (function (_super) {
        __extends$1(TextureManager, _super);
        function TextureManager(gl) {
            var _this = _super.call(this) || this;
            _this._textureMap = new Map();
            _this._hasRequestTextureMap = new Map();
            _this._gl = gl;
            _this._emptyTexture = _this._gl.createTexture();
            _this._gl.bindTexture(_this._gl.TEXTURE_2D, _this._emptyTexture);
            _this._gl.texParameteri(_this._gl.TEXTURE_2D, _this._gl.TEXTURE_MAG_FILTER, _this._gl.LINEAR);
            _this._gl.texParameteri(_this._gl.TEXTURE_2D, _this._gl.TEXTURE_MIN_FILTER, _this._gl.LINEAR);
            _this._gl.texParameteri(_this._gl.TEXTURE_2D, _this._gl.TEXTURE_WRAP_S, _this._gl.CLAMP_TO_EDGE);
            _this._gl.texParameteri(_this._gl.TEXTURE_2D, _this._gl.TEXTURE_WRAP_T, _this._gl.CLAMP_TO_EDGE);
            var pixels = document.createElement('canvas');
            _this._gl.texImage2D(_this._gl.TEXTURE_2D, 0, _this._gl.RGBA, _this._gl.RGBA, _this._gl.UNSIGNED_BYTE, pixels);
            return _this;
        }
        TextureManager.prototype.getTexture = function (url, options) {
            var key = url + "-" + options.xRepeat + "-" + options.yRepeat;
            return this._textureMap.get(key);
        };
        TextureManager.prototype.getEmptyTexture = function () {
            return this._emptyTexture;
        };
        TextureManager.prototype.loadTexture = function (url, options) {
            var _this = this;
            var key = url + "-" + options.xRepeat + "-" + options.yRepeat;
            var loadPromise = this._hasRequestTextureMap.get(key);
            if (!loadPromise) {
                loadPromise = this._loadTexture(url, options);
                this._hasRequestTextureMap.set(key, loadPromise);
                loadPromise.then(function () {
                    _this._hasRequestTextureMap.delete(key);
                });
            }
            return loadPromise;
        };
        TextureManager.prototype._loadTexture = function (url, options) {
            return __awaiter(this, void 0, void 0, function () {
                var key, imgData, texture, width, height, tempTexture;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            key = url + "-" + options.xRepeat + "-" + options.yRepeat;
                            return [4, this._loadImage(url, options)];
                        case 1:
                            imgData = _a.sent();
                            texture = this._initTexture(imgData, options);
                            width = imgData.width, height = imgData.height;
                            tempTexture = { texture: texture, width: width, height: height };
                            this._textureMap.set(key, tempTexture);
                            return [2, tempTexture];
                    }
                });
            });
        };
        TextureManager.prototype._initTexture = function (pixels, options) {
            var texture = this._gl.createTexture();
            this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
            var xParam = options.xRepeat ? this._gl.REPEAT : this._gl.CLAMP_TO_EDGE;
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, xParam);
            var yParam = options.yRepeat ? this._gl.REPEAT : this._gl.CLAMP_TO_EDGE;
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, yParam);
            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixels);
            return texture;
        };
        TextureManager.prototype._loadImage = function (url, options) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var img = new Image();
                img.crossOrigin = 'anonymous';
                img.src = url;
                img.onload = function () {
                    var width = img.width, height = img.height;
                    if (options.xRepeat || options.yRepeat) {
                        width = Math.pow(2, Math.ceil(Math.log2(img.width)));
                        height = Math.pow(2, Math.ceil(Math.log2(img.height)));
                        _this._ctx.clearRect(0, 0, width, height);
                        _this._ctx.drawImage(img, 0, 0, width, height);
                        var pixels = _this._ctx.getImageData(0, 0, width, height);
                        resolve(pixels);
                    }
                    else {
                        resolve(img);
                    }
                };
                img.onerror = function (err) {
                    reject(err);
                };
            });
        };
        TextureManager.prototype.destroy = function () {
            this._textureMap.clear();
        };
        return TextureManager;
    }(Canvas2d));

    var GlyphManager = (function (_super) {
        __extends$1(GlyphManager, _super);
        function GlyphManager(gl, options) {
            var _this = _super.call(this) || this;
            _this._baseSize = 14;
            _this._gl = gl;
            _this._options = options;
            _this._ctx.textAlign = 'left';
            _this._ctx.textBaseline = 'middle';
            _this._ctx.lineWidth = 4 * _this._pixelRatio;
            var size = _this._baseSize * _this._pixelRatio;
            _this._ctx.font = _this._options.fontWeight + " " + size + "px " + _this._options.fontFamily;
            return _this;
        }
        GlyphManager.prototype.getBaseSize = function () {
            return this._baseSize;
        };
        GlyphManager.prototype.getPixels = function (options) {
            var buffer = this._options.buffer;
            var fillColor = options.fillColor, strokeColor = options.strokeColor, textArr = options.textArr, w = options.width, h = options.height;
            var width = w * this._pixelRatio;
            var height = h * this._pixelRatio;
            this._ctx.clearRect(0, 0, width, height);
            for (var i = 0; i < textArr.length; i += 1) {
                var y = (this._baseSize / 2 + i * this._baseSize + (i + 1) * buffer) * this._pixelRatio;
                if (strokeColor) {
                    this._ctx.strokeStyle = strokeColor;
                    this._ctx.strokeText(textArr[i], buffer, y);
                }
                if (fillColor) {
                    this._ctx.fillStyle = fillColor;
                    this._ctx.fillText(textArr[i], buffer, y);
                }
            }
            return this._ctx.getImageData(0, 0, width, height);
        };
        GlyphManager.prototype.getTexture = function (textOptions) {
            var pixels = this.getPixels(textOptions);
            var texture = this._gl.createTexture();
            this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixels);
            this._gl.bindTexture(this._gl.TEXTURE_2D, null);
            return texture;
        };
        GlyphManager.prototype.getTextBound = function (text) {
            var _a = this._options, buffer = _a.buffer, textMaxWidth = _a.textMaxWidth, textSplit = _a.textSplit;
            textSplit = "|";
            var textArr = [];
            if (textSplit && new RegExp(textSplit).test(text)) {
                textArr = text.split(textSplit);
            }
            else {
                var num = Math.ceil(text.length / textMaxWidth);
                var step = Math.ceil(text.length / num);
                for (var i = 0; i < num; i += 1) {
                    textArr.push(text.slice(i * step, (i + 1) * step));
                }
            }
            var width = this._ctx.measureText(textArr[0]).width;
            for (var i = 1; i < textArr.length; i += 1) {
                var itemWidth = this._ctx.measureText(textArr[i]).width;
                if (itemWidth > width) {
                    width = itemWidth;
                }
            }
            return {
                width: Math.round(width + buffer * 2) / this._pixelRatio,
                height: Math.round(this._baseSize * textArr.length + buffer * (textArr.length + 1)),
                textArr: textArr,
            };
        };
        return GlyphManager;
    }(Canvas2d));

    var earcut_1 = earcut;
    var _default = earcut;

    function earcut(data, holeIndices, dim) {

        dim = dim || 2;

        var hasHoles = holeIndices && holeIndices.length,
            outerLen = hasHoles ? holeIndices[0] * dim : data.length,
            outerNode = linkedList(data, 0, outerLen, dim, true),
            triangles = [];

        if (!outerNode || outerNode.next === outerNode.prev) return triangles;

        var minX, minY, maxX, maxY, x, y, invSize;

        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];

            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
            }

            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }

        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

        return triangles;
    }

    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;

        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
        } else {
            for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
        }

        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }

        return last;
    }

    // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;

        var p = start,
            again;
        do {
            again = false;

            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) break;
                again = true;

            } else {
                p = p.next;
            }
        } while (again || p !== end);

        return end;
    }

    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) return;

        // interlink polygon nodes in z-order
        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

        var stop = ear,
            prev, next;

        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;

            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);

                removeNode(ear);

                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;

                continue;
            }

            ear = next;

            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

                // if this didn't work, try curing all small self-intersections locally
                } else if (pass === 1) {
                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

                // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }

                break;
            }
        }
    }

    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev,
            b = ear,
            c = ear.next;

        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;

        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.next;
        }

        return true;
    }

    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev,
            b = ear,
            c = ear.next;

        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
            minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
            maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
            maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

        // z-order range for the current triangle bbox;
        var minZ = zOrder(minTX, minTY, minX, minY, invSize),
            maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

        var p = ear.prevZ,
            n = ear.nextZ;

        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;

            if (n !== ear.prev && n !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }

        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        }

        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n !== ear.prev && n !== ear.next &&
                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }

        return true;
    }

    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev,
                b = p.next.next;

            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);

                // remove two nodes involved
                removeNode(p);
                removeNode(p.next);

                p = start = b;
            }
            p = p.next;
        } while (p !== start);

        return filterPoints(p);
    }

    // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b);

                    // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);

                    // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, invSize);
                    earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }

    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [],
            i, len, start, end, list;

        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }

        queue.sort(compareX);

        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }

        return outerNode;
    }

    function compareX(a, b) {
        return a.x - b.x;
    }

    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);

            // filter collinear points around the cuts
            filterPoints(outerNode, outerNode.next);
            filterPoints(b, b.next);
        }
    }

    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = -Infinity,
            m;

        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) return p;
                        if (hy === p.next.y) return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);

        if (!m) return null;

        if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point

        var stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;

        p = m;

        do {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                    pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

                if (locallyInside(p, hole) &&
                    (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                    m = p;
                    tanMin = tan;
                }
            }

            p = p.next;
        } while (p !== stop);

        return m;
    }

    // whether sector in vertex m contains sector in vertex p in the same coordinates
    function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }

    // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);

        p.prevZ.nextZ = null;
        p.prevZ = null;

        sortLinked(p);
    }

    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;

        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;

            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
                qSize = inSize;

                while (pSize > 0 || (qSize > 0 && q)) {

                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }

                    if (tail) tail.nextZ = e;
                    else list = e;

                    e.prevZ = tail;
                    tail = e;
                }

                p = q;
            }

            tail.nextZ = null;
            inSize *= 2;

        } while (numMerges > 1);

        return list;
    }

    // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;

        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;

        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;

        return x | (y << 1);
    }

    // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
            p = p.next;
        } while (p !== start);

        return leftmost;
    }

    // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
               (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
               (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }

    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
               (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
                (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
                equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
    }

    // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }

    // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }

    // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        var o1 = sign(area(p1, q1, p2));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p2, q2, p1));
        var o4 = sign(area(p2, q2, q1));

        if (o1 !== o2 && o3 !== o4) return true; // general case

        if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
        if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
        if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
        if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

        return false;
    }

    // for collinear points p, q, r, check if point q lies on segment pr
    function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }

    function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
    }

    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    intersects(p, p.next, a, b)) return true;
            p = p.next;
        } while (p !== a);

        return false;
    }

    // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ?
            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }

    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a,
            inside = false,
            px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                inside = !inside;
            p = p.next;
        } while (p !== a);

        return inside;
    }

    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y),
            b2 = new Node(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;

        a.next = b;
        b.prev = a;

        a2.next = an;
        an.prev = a2;

        b2.next = a2;
        a2.prev = b2;

        bp.next = b2;
        b2.prev = bp;

        return b2;
    }

    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);

        if (!last) {
            p.prev = p;
            p.next = p;

        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }

    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;

        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }

    function Node(i, x, y) {
        // vertex index in coordinates array
        this.i = i;

        // vertex coordinates
        this.x = x;
        this.y = y;

        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;

        // z-order curve value
        this.z = null;

        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;

        // indicates whether this is a steiner point
        this.steiner = false;
    }

    // return a percentage difference between the polygon area and its triangulation area;
    // used to verify correctness of triangulation
    earcut.deviation = function (data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
            for (var i = 0, len = holeIndices.length; i < len; i++) {
                var start = holeIndices[i] * dim;
                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                polygonArea -= Math.abs(signedArea(data, start, end, dim));
            }
        }

        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
            var a = triangles[i] * dim;
            var b = triangles[i + 1] * dim;
            var c = triangles[i + 2] * dim;
            trianglesArea += Math.abs(
                (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
        }

        return polygonArea === 0 && trianglesArea === 0 ? 0 :
            Math.abs((trianglesArea - polygonArea) / polygonArea);
    };

    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }

    // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
    earcut.flatten = function (data) {
        var dim = data[0][0].length,
            result = {vertices: [], holes: [], dimensions: dim},
            holeIndex = 0;

        for (var i = 0; i < data.length; i++) {
            for (var j = 0; j < data[i].length; j++) {
                for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
            }
            if (i > 0) {
                holeIndex += data[i - 1].length;
                result.holes.push(holeIndex);
            }
        }
        return result;
    };
    earcut_1.default = _default;

    var AbstractBucket = (function () {
        function AbstractBucket(data) {
            this._geometryInfo = [];
            this._features = data.features;
            this._id = data.id;
            this._offset = data.offset;
            this._layout = data.layout;
            this._type = data.type;
            this._taskId = data.taskId;
            this._hideCategoryId = data.hideCategoryIdArray;
            this._hideColorId = data.hideColorIdArray;
            this._chartletTable = data.chartletTable;
            this._bTextureEnable = data.bTextureEnable;
        }
        AbstractBucket.prototype.init = function () {
        };
        AbstractBucket.prototype.clear = function () {
            this._features.length = 0;
            this._hideCategoryId.length = 0;
            this._hideColorId.length = 0;
        };
        AbstractBucket.prototype.deepClear = function () {
            this._geometryInfo.length = 0;
            this._id = '';
            this._layout = null;
            this._type = null;
            this._taskId = '';
        };
        AbstractBucket.prototype.GetSideTextureByFeatureId = function (featureId) {
            if (this._chartletTable == null || this._chartletTable == undefined) {
                return '';
            }
            for (var i = 0; i < this._chartletTable.length; i++) {
                if (this._chartletTable[i].featureId === featureId) {
                    var result = this._chartletTable[i].sideTextureUrl;
                    if (result == null || result == undefined) {
                        result = '';
                    }
                    return result;
                }
            }
            return '';
        };
        AbstractBucket.prototype.GetFeatureTextureCoordFactor = function (featureId) {
            var defaultTextureCoordFactor = 0.5;
            if (this._chartletTable == null
                || this._chartletTable == undefined) {
                return defaultTextureCoordFactor;
            }
            for (var i = 0; i < this._chartletTable.length; i++) {
                if (this._chartletTable[i].featureId === featureId) {
                    if (this._chartletTable[i].textureCoordFactor != null
                        && this._chartletTable[i].textureCoordFactor != undefined) {
                        return this._chartletTable[i].textureCoordFactor;
                    }
                    else {
                        return defaultTextureCoordFactor;
                    }
                }
            }
            return defaultTextureCoordFactor;
        };
        AbstractBucket.prototype.GetTextureByFeatureId = function (featureId) {
            if (this._chartletTable == null || this._chartletTable == undefined) {
                return '';
            }
            for (var i = 0; i < this._chartletTable.length; i++) {
                if (this._chartletTable[i].featureId === featureId) {
                    var result = this._chartletTable[i].url;
                    if (result == null || result == undefined) {
                        result = '';
                    }
                    return result;
                }
            }
            return '';
        };
        AbstractBucket.prototype.getDrawInfo = function () {
            return {
                id: this._id,
                info: this._geometryInfo,
                type: this._type,
                taskId: this._taskId,
            };
        };
        AbstractBucket.prototype.GetFloor = function (featureId) {
            if (featureId == null || featureId == undefined || featureId == '' || typeof featureId != 'string') {
                return '';
            }
            var floorStr = featureId.substr(0, 9);
            return floorStr;
        };
        AbstractBucket.prototype.IsF0 = function (featureId) {
            if (featureId == undefined
                || featureId == null
                || typeof featureId != 'string') {
                return false;
            }
            var floorType = featureId.charAt(6);
            var floorLevel = featureId.charAt(8);
            if (floorType == 'F' && floorLevel == '0') {
                return true;
            }
            else {
                return false;
            }
        };
        return AbstractBucket;
    }());

    var IdGenerator = (function () {
        function IdGenerator() {
        }
        IdGenerator.getId = function (prefix) {
            if (prefix === void 0) { prefix = 'nag'; }
            IdGenerator.id += 1;
            return prefix + "-" + IdGenerator.id;
        };
        IdGenerator.id = 0;
        return IdGenerator;
    }());

    function parseColor(color) {
        if (!color)
            return [0, 0, 0, 1];
        var arr = [];
        if (color.substr(0, 1) === '#') {
            var str = color.slice(1);
            for (var i = 0; i < 5; i += 2) {
                var num = parseInt(str.substr(i, 2), 16) / 255;
                arr.push(num || 0);
            }
            arr.push(1);
        }
        else if (color.substr(0, 4) === 'rgba') {
            var str = color.slice(5, -1);
            var splitArr = str.split(',');
            for (var i = 0; i < 3; i += 1) {
                var num = Number(splitArr[i]) / 255;
                arr.push(num || 0);
            }
            arr.push(Number(splitArr[3]) || 1);
        }
        else if (color.substr(0, 3) === 'rgb') {
            var str = color.slice(4, -1);
            var splitArr = str.split(',');
            for (var i = 0; i < 3; i += 1) {
                var num = Number(splitArr[i]) / 255;
                arr.push(num || 0);
            }
            arr.push(1);
        }
        if (arr.length !== 4) {
            return [0, 0, 0, 1];
        }
        else {
            return arr;
        }
    }
    function getStyle(layout, name, properties) {
        var keys = layout.keys, values = layout.values;
        var style = layout[name];
        if (keys && values && properties) {
            for (var i = 0; i < keys.length; i += 1) {
                var otherLayout = values[properties[keys[i]]];
                if (otherLayout && otherLayout[name] !== undefined) {
                    style = otherLayout[name];
                    return style;
                }
            }
        }
        return style;
    }
    function getStopsOpacity(zoom, stops) {
        var zoomOpacity = 1;
        if (stops) {
            var num = 1 - (zoom - stops[0]) / (stops[1] - stops[0]);
            zoomOpacity = num > 1 ? 1 : (num > 0 ? num : 0);
        }
        return zoomOpacity;
    }
    var StyleUtils = {
        parseColor: parseColor,
        getStyle: getStyle,
        getStopsOpacity: getStopsOpacity,
    };

    var Indices = (function () {
        function Indices(indices) {
            if (indices === void 0) { indices = []; }
            this._value = indices;
        }
        Indices.prototype.add = function (indices, offset) {
            if (offset === 0) {
                this._value = this._value.concat(indices);
            }
            else {
                for (var i = 0; i < indices.length; i += 1) {
                    this._value.push(offset + indices[i]);
                }
            }
        };
        Indices.prototype.clear = function () {
            this._value = [];
        };
        Indices.prototype.getValue = function () {
            return this._value;
        };
        return Indices;
    }());

    var ZoomRangeConfig = (function () {
        function ZoomRangeConfig() {
        }
        ZoomRangeConfig.zoomRangeTable = [
            [0, 23],
            [0, 23],
            [0, 23],
            [0, 23],
            [0, 23],
            [0, 23],
            [0, 23],
            [0, 23],
            [0, 23],
            [0, 23],
            [0, 23],
        ];
        return ZoomRangeConfig;
    }());

    var LogMgr$1 = (function () {
        function LogMgr() {
        }
        LogMgr.log = function (strLog) {
        };
        return LogMgr;
    }());

    var FillBucket = (function (_super) {
        __extends$1(FillBucket, _super);
        function FillBucket() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._geometryMap = {};
            return _this;
        }
        FillBucket.prototype.clear = function () {
            this._features.length = 0;
            this._geometryMap = {};
        };
        FillBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties, featureid = _a.featureid;
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                if (featureid === undefined) {
                    featureid = properties === null || properties === void 0 ? void 0 : properties.id;
                }
                if (visible) {
                    if (geometry.type === 'Polygon') {
                        this._calcPolygon(geometry.coordinates, properties, featureid);
                    }
                    else if (geometry.type === 'MultiPolygon') {
                        for (var j = 0; j < geometry.coordinates.length; j += 1) {
                            this._calcPolygon(geometry.coordinates[j], properties, featureid);
                        }
                    }
                    else ;
                }
            }
            for (var key in this._geometryMap) {
                var item = this._geometryMap[key];
                this._geometryInfo.push({
                    vertices: item.vertices,
                    fillIndices: item.fillIndices.getValue(),
                    outlineIndices: item.outlineIndices.getValue(),
                    fillColor: item.fillColor,
                    outlineColor: item.outlineColor,
                    base: item.base,
                    opacity: item.opacity,
                    zoomRange: item.zoomRange,
                    floorString: item.floorString,
                    sideVertices: [],
                    sideIndices: [],
                    featureId: item.featureId,
                    texCoord: item.texCoord,
                    texture: null,
                    sideTexture: null,
                    isF0: item.isF0,
                    textureUrl: item.textureUrl,
                    sideTextureUrl: item.sideTextureUrl,
                });
            }
        };
        FillBucket.prototype._calcPolygon = function (polygon, properties, featureid) {
            if (polygon.length === 0)
                return;
            var offset = this._offset;
            var vertices = [];
            var texCoord = [];
            var holes = [];
            var outlineIndices = [];
            var enableOutline = StyleUtils.getStyle(this._layout, 'enableOutline', properties);
            if (featureid == null || featureid == undefined || typeof featureid != 'string') {
                featureid = '';
            }
            var floorStr = this.GetFloor(featureid);
            var bF0 = this.IsF0(floorStr);
            var zoomRange = [0, 24];
            if (bF0 == false && featureid) {
                var featureType = featureid.charAt(9);
                zoomRange = ZoomRangeConfig.zoomRangeTable[parseInt(featureType)];
            }
            for (var i = 0; i < polygon.length; i += 1) {
                var face = polygon[i];
                for (var j = 0; j < face.length; j += 1) {
                    if (enableOutline) {
                        var verticesCount = vertices.length / 2;
                        if (j < face.length - 1) {
                            outlineIndices.push(verticesCount, verticesCount + 1);
                        }
                    }
                    vertices.push(face[j][0] + offset[0], face[j][1] + offset[1]);
                    if (this._bTextureEnable) {
                        texCoord.push(face[j][0] + offset[0], face[j][1] + offset[1]);
                    }
                }
                if (i < polygon.length - 1) {
                    holes.push(vertices.length / 2);
                }
            }
            var fillIndices = earcut_1(vertices, holes.length === 0 ? undefined : holes, 2);
            var fillColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'fillColor', properties));
            var outlineColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'outlineColor', properties));
            var base = StyleUtils.getStyle(this._layout, 'base', properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);
            if (bF0) {
                base = 0.0;
            }
            var textureUrl = this.GetTextureByFeatureId(featureid);
            var sideTextureUrl = this.GetSideTextureByFeatureId(featureid);
            if (textureUrl == '' && sideTextureUrl == '') {
                featureid = '';
            }
            else {
                LogMgr$1.log('isExtra featureId: ' + featureid);
            }
            var key = this._getGeometryKey2(properties, featureid + textureUrl + sideTextureUrl + '-' + base);
            if (this._geometryMap[key]
                && this._geometryMap[key].vertices.length / 2 + vertices.length / 2 < 65536
                && this._geometryMap[key].zoomRange === zoomRange) {
                var geometry = this._geometryMap[key];
                var oldVerticesCount = geometry.vertices.length / 2;
                geometry.fillIndices.add(fillIndices, oldVerticesCount);
                geometry.outlineIndices.add(outlineIndices, oldVerticesCount);
                geometry.vertices = geometry.vertices.concat(vertices);
                geometry.texCoord = geometry.texCoord.concat(texCoord);
                geometry.floorString = floorStr;
                geometry.featureId = featureid;
                geometry.isF0 = bF0;
                geometry.textureUrl = textureUrl;
                geometry.sideTextureUrl = sideTextureUrl;
            }
            else {
                if (this._geometryMap[key]) {
                    var newId = IdGenerator.getId();
                    this._geometryMap[newId] = this._geometryMap[key];
                }
                this._geometryMap[key] = {
                    vertices: vertices,
                    texCoord: texCoord,
                    outlineColor: outlineColor,
                    fillColor: fillColor,
                    fillIndices: new Indices(fillIndices),
                    outlineIndices: new Indices(outlineIndices),
                    base: base,
                    opacity: opacity,
                    zoomRange: zoomRange,
                    floorString: floorStr,
                    featureId: featureid,
                    isF0: bF0,
                    textureUrl: textureUrl,
                    sideTextureUrl: sideTextureUrl,
                };
            }
        };
        FillBucket.prototype._getGeometryKey = function (properties) {
            var arr = [];
            for (var i = 0; i < FillBucket.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, FillBucket.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            return arr.join('-');
        };
        FillBucket.prototype._getGeometryKey2 = function (properties, textureUrl) {
            var arr = [];
            for (var i = 0; i < FillBucket.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, FillBucket.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            arr.push(textureUrl);
            return arr.join('-');
        };
        FillBucket.GEOMETRY_KEYS = ['fillColor', 'outlineColor', 'base', 'opacity'];
        return FillBucket;
    }(AbstractBucket));

    var Vector2 = (function () {
        function Vector2(start, end) {
            if (end) {
                this.x = end[0] - start[0];
                this.y = end[1] - start[1];
            }
            else {
                this.x = start[0];
                this.y = start[1];
            }
        }
        Vector2.prototype.unit = function () {
            var length = this.getLength();
            if (length === 0) {
                return new Vector2([0, 0]);
            }
            var x = this.x / length;
            var y = this.y / length;
            return new Vector2([0, 0], [x, y]);
        };
        Vector2.prototype.normal = function () {
            return new Vector2([0, 0], [-this.y, this.x]);
        };
        Vector2.prototype.add = function (other) {
            this.x += other.x;
            this.y += other.y;
            return this;
        };
        Vector2.prototype.subtract = function (other) {
            this.x -= other.x;
            this.y -= other.y;
            return this;
        };
        Vector2.prototype.rotate = function (angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var x = cos * this.x - sin * this.y;
            var y = sin * this.x + cos * this.y;
            this.x = x;
            this.y = y;
            return this;
        };
        Vector2.prototype.multiply = function (num) {
            this.x *= num;
            this.y *= num;
            return this;
        };
        Vector2.prototype.dot = function (other) {
            return this.x * other.x + this.y * other.y;
        };
        Vector2.prototype.angleTo = function (other) {
            var m1 = this.getLength();
            var m2 = other.getLength();
            var m = m1 * m2;
            if (m === 0)
                return 0;
            var num = (this.x * other.x + this.y * other.y) / m;
            if (num > 1) {
                num = 1;
            }
            else if (num < -1) {
                num = -1;
            }
            var angle = Math.acos(num) / Math.PI * 180;
            var cross = this.cross(other) < 0 ? 1 : -1;
            return cross * angle;
        };
        Vector2.prototype.cross = function (other) {
            return this.x * other.y - other.x * this.y;
        };
        Vector2.prototype.clone = function () {
            return new Vector2([0, 0], [this.x, this.y]);
        };
        Vector2.prototype.multiplyMat4 = function (matrix) {
            var m = matrix.getValue();
            var x = m[0] * this.x + m[4] * this.y + m[12];
            var y = m[1] * this.x + m[5] * this.y + m[13];
            return new Vector2([x, y]);
        };
        Vector2.prototype.getLength = function () {
            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
        };
        return Vector2;
    }());

    var Global = (function () {
        function Global() {
            this.m_hiddenFeatureCategoryIdArray = new Array();
            this.m_hiddenFeatureColorIdArray = new Array();
            this.m_isOutDoor = false;
        }
        Global.getInstance = function () {
            if (Global.m_instance == null) {
                Global.m_instance = new Global();
            }
            return Global.m_instance;
        };
        Global.prototype.AddHideFeatureByCategoryId = function (categoryId) {
            this.m_hiddenFeatureCategoryIdArray.push(categoryId);
        };
        Global.prototype.AddHideFeatureByColorId = function (colorId) {
            this.m_hiddenFeatureColorIdArray.push(colorId);
        };
        Global.prototype.RemoveHideFeatureByColorId = function (colorId) {
            for (var i = 0; i < this.m_hiddenFeatureColorIdArray.length; i++) {
                if (this.m_hiddenFeatureColorIdArray[i] == colorId) {
                    this.m_hiddenFeatureColorIdArray.splice(i, 1);
                    i--;
                }
            }
        };
        Global.prototype.RemoveHideFeatureByCategoryId = function (categoryId) {
            for (var i = 0; i < this.m_hiddenFeatureCategoryIdArray.length; i++) {
                if (this.m_hiddenFeatureCategoryIdArray[i] == categoryId) {
                    this.m_hiddenFeatureCategoryIdArray.splice(i, 1);
                    i--;
                }
            }
        };
        Global.prototype.IsHideFeature = function (categoryId) {
            for (var i = 0; i < this.m_hiddenFeatureCategoryIdArray.length; i++) {
                if (this.m_hiddenFeatureCategoryIdArray[i] == categoryId) {
                    return true;
                }
            }
            return false;
        };
        Global.prototype.GetHideCategoryIdArray = function () {
            return this.m_hiddenFeatureCategoryIdArray;
        };
        Global.prototype.GetHideColorIdArray = function () {
            return this.m_hiddenFeatureColorIdArray;
        };
        Global.prototype.IsOutDoor = function () {
            return this.m_isOutDoor;
        };
        Global.prototype.SetOutDoor = function (bOutDoor) {
            this.m_isOutDoor = bOutDoor;
        };
        Global.m_instance = null;
        Global.m_curFillExtrusionDataCount = 0;
        Global.m_maxFillExtrusionAllowed = 20000;
        Global.m_maxFloorCachedAllowed = 1;
        Global.m_bTextureEnable = false;
        Global.m_bLowDisplay = true;
        return Global;
    }());

    var FillExtrusionBucket = (function (_super) {
        __extends$1(FillExtrusionBucket, _super);
        function FillExtrusionBucket() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._geometryMap = {};
            return _this;
        }
        FillExtrusionBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                this._update(this._features[i]);
            }
            this._fireMessage();
        };
        FillExtrusionBucket.prototype.clear = function () {
            this._features.length = 0;
            this._geometryMap = {};
        };
        FillExtrusionBucket.prototype._fireMessage = function () {
            this._geometryInfo.length = 0;
            for (var key in this._geometryMap) {
                var item = this._geometryMap[key];
                this._geometryInfo.push({
                    vertices: item.vertices,
                    sideVertices: item.sideVertices,
                    fillIndices: item.fillIndices.getValue(),
                    sideIndices: item.sideIndices.getValue(),
                    outlineIndices: item.outlineIndices.getValue(),
                    fillColor: item.fillColor,
                    outlineColor: item.outlineColor,
                    base: item.base,
                    opacity: item.opacity,
                    normals: item.normals,
                    sideNormals: item.sideNormals,
                    height: item.height,
                    stops: item.stops,
                    zoomRange: item.zoomRange,
                    floorString: item.floorString,
                    featureId: item.featureId,
                    colorId: item.colorId,
                    texCoordArray: item.texCoordArray,
                    sideTexCoordArray: item.sideTexCoordArray,
                    texCoord: [],
                    texture: null,
                    sideTexture: null,
                    textureUrl: item.textureUrl,
                    sideTextureUrl: item.sideTextureUrl,
                    isF0: item.isF0,
                });
            }
        };
        FillExtrusionBucket.prototype.IsHideFeatureByCategoryId = function (categoryid) {
            for (var i = 0; i < this._hideCategoryId.length; i++) {
                if (categoryid == this._hideCategoryId[i]) {
                    return true;
                }
            }
            return false;
        };
        FillExtrusionBucket.prototype.IsHideFeatureByColorId = function (colorId) {
            for (var i = 0; i < this._hideColorId.length; i++) {
                if (colorId == this._hideColorId[i]) {
                    return true;
                }
            }
            return false;
        };
        FillExtrusionBucket.prototype._update = function (feature) {
            var geometry = feature.geometry, properties = feature.properties, featureid = feature.featureid;
            if (featureid == undefined || featureid == null) {
                featureid = properties === null || properties === void 0 ? void 0 : properties.id;
            }
            if (properties
                && (this.IsHideFeatureByCategoryId(properties.categoryid) || this.IsHideFeatureByColorId(properties.colorid))) {
                LogMgr$1.log('鏈哄満蹇界暐鏌卞瓙');
                return;
            }
            var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
            if (visible) {
                if (geometry.type === 'Polygon') {
                    this._calcPolygon(geometry.coordinates, properties, featureid);
                }
                else if (geometry.type === 'MultiPolygon') {
                    for (var i = 0; i < geometry.coordinates.length; i += 1) {
                        this._calcPolygon(geometry.coordinates[i], properties, featureid);
                    }
                }
            }
        };
        FillExtrusionBucket.prototype.isExtra = function (properties) {
            if (properties == null || properties == undefined) {
                return false;
            }
            if (properties.isExtra != null && properties.isExtra != undefined) {
                return properties.isExtra;
            }
            var colorid = properties === null || properties === void 0 ? void 0 : properties.colorid;
            if (colorid == null || colorid == undefined) {
                return false;
            }
            if (colorid == 7 || colorid == 8) {
                return true;
            }
            else {
                return false;
            }
        };
        FillExtrusionBucket.prototype._calcPolygon = function (polygon, properties, featureid) {
            var offset = this._offset;
            var vertices = [];
            var sideVertices = [];
            var sideIndices = [];
            var outSideIndices = [];
            var holes = [];
            var outlineIndices = [];
            var sideNormals = [];
            var topNormals = [];
            var enableOutline = StyleUtils.getStyle(this._layout, 'enableOutline', properties);
            var height = StyleUtils.getStyle(this._layout, 'height', properties);
            var sideTexCoordArray = [];
            var texCoordArray = [];
            var isF0 = this.IsF0(featureid);
            var factor = 1.0;
            var zoomRange = [0, 24];
            properties === null || properties === void 0 ? void 0 : properties.id;
            if (isF0 == false && featureid) {
                var featureType = featureid.charAt(9);
                zoomRange = ZoomRangeConfig.zoomRangeTable[parseInt(featureType)];
            }
            var floorStr = this.GetFloor(featureid);
            for (var i = 0; i < polygon.length; i += 1) {
                var face = polygon[i];
                for (var j = 0; j < face.length; j += 1) {
                    var curX = face[j][0] + offset[0];
                    var curY = face[j][1] + offset[1];
                    var sideCount = sideVertices.length / 3;
                    if (j < face.length - 1) {
                        if (enableOutline) {
                            var verticesCount = vertices.length / 3;
                            outlineIndices.push(verticesCount, verticesCount + 1);
                        }
                        new Vector2(face[j], face[j + 1]).normal();
                        sideIndices.push(sideCount + 0, sideCount + 1, sideCount + 2);
                        sideIndices.push(sideCount + 1, sideCount + 2, sideCount + 3);
                        var nextX = face[j + 1][0] + offset[0];
                        var nextY = face[j + 1][1] + offset[1];
                        sideVertices.push(curX, curY, 0);
                        sideVertices.push(curX, curY, 1);
                        sideVertices.push(nextX, nextY, 0);
                        sideVertices.push(nextX, nextY, 1);
                        if (this._bTextureEnable) {
                            sideTexCoordArray.push(curX, curY);
                            sideTexCoordArray.push(curX + 1, curY);
                            sideTexCoordArray.push(curX + 1, curY + 1);
                            sideTexCoordArray.push(curX, curY + 1);
                        }
                    }
                    vertices.push(curX, curY, FillExtrusionBucket.FACTOR + 1);
                    if (this._bTextureEnable) {
                        texCoordArray.push(curX * factor, curY * factor);
                    }
                }
                if (i < polygon.length - 1) {
                    holes.push(vertices.length / 3);
                }
            }
            var indices = earcut_1(vertices, holes.length === 0 ? undefined : holes, 3);
            var topFaceCount = vertices.length / 3;
            for (var i = 0; i < sideIndices.length; i += 1) {
                outSideIndices.push(sideIndices[i]);
            }
            var totalCount = topFaceCount + sideVertices.length / 3;
            var fillColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'fillColor', properties));
            var outlineColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'outlineColor', properties));
            var base = StyleUtils.getStyle(this._layout, 'base', properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);
            var stops = StyleUtils.getStyle(this._layout, 'stops', properties);
            var textureUrl = this.GetTextureByFeatureId(featureid);
            var sideTextureUrl = this.GetSideTextureByFeatureId(featureid);
            if (this.isExtra(properties) == false && textureUrl == '' && sideTextureUrl == '') {
                featureid = '';
            }
            else {
                LogMgr$1.log('isExtra featureId: ' + featureid);
            }
            var key = this._getGeometryKey2(properties, textureUrl + '-' + sideTextureUrl + '-' + featureid + '-' + height);
            if (this._geometryMap[key] &&
                this._geometryMap[key].vertices.length / 3 + totalCount < 65536) {
                var geometry = this._geometryMap[key];
                var oldVerticesCount = geometry.vertices.length / 3;
                var oldSideVerticesCount = geometry.sideVertices.length / 3;
                geometry.fillIndices.add(indices, oldVerticesCount);
                geometry.sideIndices.add(outSideIndices, oldSideVerticesCount);
                geometry.outlineIndices.add(outlineIndices, oldVerticesCount);
                geometry.vertices = geometry.vertices.concat(vertices);
                geometry.sideVertices = geometry.sideVertices.concat(sideVertices);
                geometry.normals = geometry.normals.concat(topNormals);
                geometry.sideNormals = geometry.sideNormals.concat(sideNormals);
                geometry.floorString = floorStr;
                geometry.featureId = featureid;
                geometry.colorId = properties === null || properties === void 0 ? void 0 : properties.colorid;
                geometry.texCoordArray = geometry.texCoordArray.concat(texCoordArray);
                geometry.sideTexCoordArray = geometry.sideTexCoordArray.concat(sideTexCoordArray);
                geometry.isF0 = isF0;
                geometry.textureUrl = textureUrl;
                geometry.sideTextureUrl = sideTextureUrl;
            }
            else {
                if (this._geometryMap[key]) {
                    this._geometryMap[IdGenerator.getId()] = this._geometryMap[key];
                }
                this._geometryMap[key] = {
                    fillIndices: new Indices(indices),
                    vertices: vertices,
                    sideVertices: sideVertices,
                    normals: topNormals,
                    sideNormals: sideNormals,
                    sideIndices: new Indices(outSideIndices),
                    outlineIndices: new Indices(outlineIndices),
                    zoomRange: zoomRange,
                    floorString: floorStr,
                    featureId: featureid,
                    colorId: properties === null || properties === void 0 ? void 0 : properties.colorid,
                    texCoordArray: texCoordArray,
                    sideTexCoordArray: sideTexCoordArray,
                    fillColor: fillColor,
                    outlineColor: outlineColor,
                    height: height,
                    base: base,
                    opacity: opacity,
                    stops: stops,
                    isF0: isF0,
                    textureUrl: textureUrl,
                    sideTextureUrl: sideTextureUrl,
                };
            }
        };
        FillExtrusionBucket.prototype._getGeometryKey = function (properties) {
            var arr = [];
            for (var i = 0; i < FillExtrusionBucket.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucket.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            return arr.join('-');
        };
        FillExtrusionBucket.prototype._getGeometryKey2 = function (properties, textureUrl) {
            var arr = [];
            for (var i = 0; i < FillExtrusionBucket.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucket.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            arr.push(textureUrl);
            return arr.join('-');
        };
        FillExtrusionBucket.GEOMETRY_KEYS = [
            'fillColor', 'outlineColor', 'height', 'base', 'opacity', 'stops',
        ];
        FillExtrusionBucket.FACTOR = Math.pow(2, 13);
        return FillExtrusionBucket;
    }(AbstractBucket));

    var FillExtrusionBucket2d = (function (_super) {
        __extends$1(FillExtrusionBucket2d, _super);
        function FillExtrusionBucket2d() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FillExtrusionBucket2d.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                this._update(this._features[i]);
            }
            this._fireMessage();
        };
        FillExtrusionBucket2d.prototype.clear = function () {
            this._features.length = 0;
            this._geometryMap = {};
        };
        FillExtrusionBucket2d.prototype._fireMessage = function () {
            this._geometryInfo.length = 0;
            for (var key in this._geometryMap) {
                var item = this._geometryMap[key];
                this._geometryInfo.push({
                    vertices: item.vertices,
                    sideVertices: [],
                    fillIndices: item.fillIndices.getValue(),
                    sideIndices: [],
                    outlineIndices: item.outlineIndices.getValue(),
                    fillColor: item.fillColor,
                    outlineColor: item.outlineColor,
                    base: item.base,
                    opacity: item.opacity,
                    normals: item.normals,
                    sideNormals: [],
                    height: 0,
                    stops: item.stops,
                    zoomRange: item.zoomRange,
                    floorString: item.floorString,
                    featureId: item.featureId,
                    colorId: item.colorId,
                    texCoordArray: item.texCoordArray,
                    sideTexCoordArray: [],
                    texCoord: [],
                    texture: null,
                    sideTexture: null,
                    isF0: item.isF0,
                    textureUrl: item.textureUrl,
                    sideTextureUrl: item.sideTextureUrl,
                });
            }
        };
        FillExtrusionBucket2d.prototype.IsHideFeatureByCategoryId = function (categoryid) {
            for (var i = 0; i < this._hideCategoryId.length; i++) {
                if (categoryid == this._hideCategoryId[i]) {
                    return true;
                }
            }
            return false;
        };
        FillExtrusionBucket2d.prototype.IsHideFeatureByColorId = function (colorId) {
            for (var i = 0; i < this._hideColorId.length; i++) {
                if (colorId == this._hideColorId[i]) {
                    return true;
                }
            }
            return false;
        };
        FillExtrusionBucket2d.prototype._update = function (feature) {
            var geometry = feature.geometry, properties = feature.properties, featureid = feature.featureid;
            if (featureid == undefined || featureid == null) {
                featureid = properties === null || properties === void 0 ? void 0 : properties.id;
            }
            if (properties
                && (this.IsHideFeatureByCategoryId(properties.categoryid) || this.IsHideFeatureByColorId(properties.colorid))) {
                LogMgr$1.log('鏈哄満蹇界暐鏌卞瓙');
                return;
            }
            var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
            if (visible) {
                if (geometry.type === 'Polygon') {
                    this._calcPolygon(geometry.coordinates, properties, featureid);
                }
                else if (geometry.type === 'MultiPolygon') {
                    for (var i = 0; i < geometry.coordinates.length; i += 1) {
                        this._calcPolygon(geometry.coordinates[i], properties, featureid);
                    }
                }
            }
        };
        FillExtrusionBucket2d.prototype.isExtra = function (properties) {
            if (properties == null || properties == undefined) {
                return false;
            }
            if (properties.isExtra != null && properties.isExtra != undefined) {
                return properties.isExtra;
            }
            var colorid = properties === null || properties === void 0 ? void 0 : properties.colorid;
            if (colorid == null || colorid == undefined) {
                return false;
            }
            if (colorid == 7 || colorid == 8) {
                return true;
            }
            else {
                return false;
            }
        };
        FillExtrusionBucket2d.prototype._calcPolygon = function (polygon, properties, featureid) {
            var offset = this._offset;
            var vertices = [];
            var holes = [];
            var outlineIndices = [];
            var topNormals = [];
            var enableOutline = StyleUtils.getStyle(this._layout, 'enableOutline', properties);
            var height = StyleUtils.getStyle(this._layout, 'height', properties);
            var sideTexCoordArray = [];
            var texCoordArray = [];
            var isF0 = this.IsF0(featureid);
            var factor = 1.0;
            var zoomRange = [0, 24];
            properties === null || properties === void 0 ? void 0 : properties.id;
            if (isF0 == false && featureid) {
                var featureType = featureid.charAt(9);
                zoomRange = ZoomRangeConfig.zoomRangeTable[parseInt(featureType)];
            }
            var floorStr = this.GetFloor(featureid);
            for (var i = 0; i < polygon.length; i += 1) {
                var face = polygon[i];
                for (var j = 0; j < face.length; j += 1) {
                    var curX = face[j][0] + offset[0];
                    var curY = face[j][1] + offset[1];
                    if (j < face.length - 1) {
                        if (enableOutline) {
                            var verticesCount = vertices.length / 3;
                            outlineIndices.push(verticesCount, verticesCount + 1);
                        }
                        new Vector2(face[j], face[j + 1]).normal();
                        face[j + 1][0] + offset[0];
                        face[j + 1][1] + offset[1];
                        if (Global.m_bTextureEnable) {
                            sideTexCoordArray.push(curX, curY);
                            sideTexCoordArray.push(curX + 1, curY);
                            sideTexCoordArray.push(curX + 1, curY + 1);
                            sideTexCoordArray.push(curX, curY + 1);
                        }
                    }
                    vertices.push(curX, curY, FillExtrusionBucket.FACTOR + 1);
                    if (Global.m_bTextureEnable) {
                        texCoordArray.push(curX * factor, curY * factor);
                    }
                }
                if (i < polygon.length - 1) {
                    holes.push(vertices.length / 3);
                }
            }
            var indices = earcut_1(vertices, holes.length === 0 ? undefined : holes, 3);
            var topFaceCount = vertices.length / 3;
            var totalCount = topFaceCount;
            var fillColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'fillColor', properties));
            var outlineColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'outlineColor', properties));
            var base = StyleUtils.getStyle(this._layout, 'base', properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);
            var stops = StyleUtils.getStyle(this._layout, 'stops', properties);
            var featureTextureUrl = this.GetTextureByFeatureId(featureid);
            if (this.isExtra(properties) == false && featureTextureUrl == '') {
                featureid = '';
            }
            else {
                LogMgr$1.log('isExtra featureId: ' + featureid);
            }
            var key = this._getGeometryKey2(properties, featureTextureUrl + featureid + '-' + height);
            if (this._geometryMap[key] &&
                this._geometryMap[key].vertices.length / 3 + totalCount < 65536) {
                var geometry = this._geometryMap[key];
                var oldVerticesCount = geometry.vertices.length / 3;
                geometry.sideVertices.length / 3;
                geometry.fillIndices.add(indices, oldVerticesCount);
                geometry.outlineIndices.add(outlineIndices, oldVerticesCount);
                geometry.vertices = geometry.vertices.concat(vertices);
                geometry.normals = geometry.normals.concat(topNormals);
                geometry.floorString = floorStr;
                geometry.featureId = featureid;
                geometry.colorId = properties === null || properties === void 0 ? void 0 : properties.colorid;
                geometry.texCoordArray = geometry.texCoordArray.concat(texCoordArray);
                geometry.sideTexCoordArray = geometry.sideTexCoordArray.concat(sideTexCoordArray);
                geometry.isF0 = isF0;
                geometry.textureUrl = featureTextureUrl;
            }
            else {
                if (this._geometryMap[key]) {
                    this._geometryMap[IdGenerator.getId()] = this._geometryMap[key];
                }
                this._geometryMap[key] = {
                    fillIndices: new Indices(indices),
                    vertices: vertices,
                    sideVertices: [],
                    normals: topNormals,
                    sideNormals: [],
                    sideIndices: new Indices([]),
                    outlineIndices: new Indices(outlineIndices),
                    zoomRange: zoomRange,
                    floorString: floorStr,
                    featureId: featureid,
                    colorId: properties === null || properties === void 0 ? void 0 : properties.colorid,
                    texCoordArray: texCoordArray,
                    sideTexCoordArray: [],
                    fillColor: fillColor,
                    outlineColor: outlineColor,
                    height: 0,
                    base: base,
                    opacity: opacity,
                    stops: stops,
                    isF0: isF0,
                    textureUrl: featureTextureUrl,
                    sideTextureUrl: '',
                };
            }
        };
        FillExtrusionBucket2d.prototype._getGeometryKey = function (properties) {
            var arr = [];
            for (var i = 0; i < FillExtrusionBucket.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucket.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            return arr.join('-');
        };
        FillExtrusionBucket2d.prototype._getGeometryKey2 = function (properties, textureUrl) {
            var arr = [];
            for (var i = 0; i < FillExtrusionBucket.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucket.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            arr.push(textureUrl);
            return arr.join('-');
        };
        FillExtrusionBucket2d.GEOMETRY_KEYS = [
            'fillColor', 'outlineColor', 'height', 'base', 'opacity', 'stops',
        ];
        FillExtrusionBucket2d.FACTOR = Math.pow(2, 13);
        return FillExtrusionBucket2d;
    }(FillExtrusionBucket));

    var CircleBucket = (function (_super) {
        __extends$1(CircleBucket, _super);
        function CircleBucket() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CircleBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                if (visible) {
                    if (geometry.type === 'Point') {
                        this._calcPoint(geometry.coordinates, properties);
                    }
                    else if (geometry.type === 'MultiPoint') {
                        for (var j = 0; j < geometry.coordinates.length; j += 1) {
                            this._calcPoint(geometry.coordinates[j], properties);
                        }
                    }
                }
            }
        };
        CircleBucket.prototype.clear = function () {
            this._features.length = 0;
        };
        CircleBucket.prototype._calcPoint = function (point, properties) {
            var offset = this._offset;
            var p = [point[0] + offset[0], point[1] + offset[1]];
            var color = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'color', properties));
            var base = StyleUtils.getStyle(this._layout, 'base', properties);
            var radius = StyleUtils.getStyle(this._layout, 'radius', properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);
            this._geometryInfo.push({
                color: color,
                base: base,
                point: p,
                radius: radius,
                opacity: opacity,
            });
        };
        return CircleBucket;
    }(AbstractBucket));

    var SymbolBucket = (function (_super) {
        __extends$1(SymbolBucket, _super);
        function SymbolBucket(data) {
            var _this = _super.call(this, data) || this;
            _this._baseTextSize = data.baseTextSize;
            return _this;
        }
        SymbolBucket.prototype.IsHideFeatureByCategoryId = function (categoryid) {
            for (var i = 0; i < this._hideCategoryId.length; i++) {
                if (categoryid == this._hideCategoryId[i]) {
                    return true;
                }
            }
            return false;
        };
        SymbolBucket.prototype.IsHideFeatureByColorId = function (colorId) {
            for (var i = 0; i < this._hideColorId.length; i++) {
                if (colorId == this._hideColorId[i]) {
                    return true;
                }
            }
            return false;
        };
        SymbolBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties, featureid = _a.featureid;
                if (featureid == undefined || featureid == null || featureid == '') {
                    featureid = properties === null || properties === void 0 ? void 0 : properties.id;
                }
                if (properties
                    && (this.IsHideFeatureByCategoryId(properties.categoryid) || this.IsHideFeatureByColorId(properties.colorid))) {
                    LogMgr$1.log('鏈哄満蹇界暐鏌卞瓙锛宻ymbol 灞�');
                    return;
                }
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                if (visible) {
                    if (geometry.type === 'Point') {
                        this._calcPoint(geometry.coordinates, this._features[i], featureid);
                    }
                    else if (geometry.type === 'MultiPoint') {
                        for (var j = 0; j < geometry.coordinates.length; j += 1) {
                            this._calcPoint(geometry.coordinates[j], this._features[i], featureid);
                        }
                    }
                }
            }
        };
        SymbolBucket.prototype.clear = function () {
            this._features.length = 0;
        };
        SymbolBucket.prototype._calcPoint = function (point, item, featureId) {
            var offset = this._offset;
            var resultPoint = [point[0] + offset[0], point[1] + offset[1]];
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', item.properties);
            var base = StyleUtils.getStyle(this._layout, 'base', item.properties);
            var iconZHeight = StyleUtils.getStyle(this._layout, 'iconZHeight', item.properties);
            var textZHeight = StyleUtils.getStyle(this._layout, 'textZHeight', item.properties);
            if (iconZHeight && textZHeight) {
                base += (iconZHeight + textZHeight) / 2;
            }
            else if (iconZHeight) {
                base += iconZHeight;
            }
            else if (textZHeight) {
                base += textZHeight;
            }
            var imgSymbol = this._calcImage(resultPoint, item, base, opacity);
            var textSymbol = this._calcText(resultPoint, item, base, opacity);
            var isCollision = StyleUtils.getStyle(this._layout, 'collision', item.properties);
            var weight = StyleUtils.getStyle(this._layout, 'weight', item.properties);
            var margin = StyleUtils.getStyle(this._layout, 'margin', item.properties);
            var floorString = this.GetFloor(featureId);
            var zoomRange = StyleUtils.getStyle(this._layout, 'zoomRange', item.properties);
            var collision = {
                point: resultPoint,
                data: [],
                weight: weight,
                margin: margin,
                zoomRange: zoomRange,
                floorString: floorString,
            };
            var arr = [];
            if (imgSymbol && textSymbol) {
                collision.data.push(imgSymbol.collision, textSymbol.collision);
                arr.push(imgSymbol.geometry, textSymbol.geometry);
            }
            else if (imgSymbol) {
                collision.data.push(imgSymbol.collision);
                arr.push(imgSymbol.geometry);
            }
            else if (textSymbol) {
                collision.data.push(textSymbol.collision);
                arr.push(textSymbol.geometry);
            }
            this._geometryInfo.push({
                data: arr,
                floorString: floorString,
                isCollision: isCollision,
                featureId: featureId,
                height: item.properties.height,
                collision: collision
            });
        };
        SymbolBucket.prototype._calcImage = function (point, item, base, opacity) {
            if (!item.iconSize)
                return;
            var iconUrl = StyleUtils.getStyle(this._layout, 'iconImage', item.properties);
            var anchor = StyleUtils.getStyle(this._layout, 'iconAnchor', item.properties);
            var offset = StyleUtils.getStyle(this._layout, 'iconOffset', item.properties);
            var iconSize = StyleUtils.getStyle(this._layout, 'iconSize', item.properties);
            var width = item.iconSize[0] * iconSize;
            var height = item.iconSize[1] * iconSize;
            var _a = createPointGeometry(point, width, height, anchor), vertices = _a.vertices, texCoords = _a.texCoords;
            var geometry = { point: point, vertices: vertices, texCoords: texCoords, offset: offset, base: base, opacity: opacity, iconUrl: iconUrl };
            var collision = { width: width, height: height, anchor: anchor, offset: offset };
            return { geometry: geometry, collision: collision };
        };
        SymbolBucket.prototype._calcText = function (point, item, base, opacity) {
            if (!item.textSize || !item.textArr)
                return;
            var textSize = StyleUtils.getStyle(this._layout, 'textSize', item.properties);
            var anchor = StyleUtils.getStyle(this._layout, 'textAnchor', item.properties);
            var offset = StyleUtils.getStyle(this._layout, 'textOffset', item.properties);
            var width = item.textSize[0] * textSize / this._baseTextSize;
            var height = item.textSize[1] * textSize / this._baseTextSize;
            var textColor = StyleUtils.getStyle(this._layout, 'textColor', item.properties);
            var strokeColor = StyleUtils.getStyle(this._layout, 'textStrokeColor', item.properties);
            var _a = createPointGeometry(point, width, height, anchor), vertices = _a.vertices, texCoords = _a.texCoords;
            var textOptions = {
                textArr: item.textArr,
                width: item.textSize[0],
                height: item.textSize[1],
                fillColor: textColor,
                strokeColor: strokeColor,
            };
            var geometry = {
                point: point,
                vertices: vertices,
                texCoords: texCoords,
                offset: offset,
                base: base,
                opacity: opacity,
                textOptions: textOptions,
            };
            var collision = { width: width, height: height, anchor: anchor, offset: offset };
            return { geometry: geometry, collision: collision };
        };
        return SymbolBucket;
    }(AbstractBucket));

    var ConnectionBucket = (function (_super) {
        __extends$1(ConnectionBucket, _super);
        function ConnectionBucket() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ConnectionBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                if (visible) {
                    if (geometry.type === 'LineString') {
                        this._calcPolyline(geometry.coordinates, properties);
                    }
                    else if (geometry.type === 'MultiLineString') {
                        for (var j = 0; j < geometry.coordinates.length; j += 1) {
                            this._calcPolyline(geometry.coordinates[j], properties);
                        }
                    }
                }
            }
        };
        ConnectionBucket.prototype.clear = function () {
            this._features.length = 0;
        };
        ConnectionBucket.prototype._calcPolyline = function (line, properties) {
            var offset = this._offset;
            var base = StyleUtils.getStyle(this._layout, 'base', properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);
            var color = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'color', properties));
            var width = StyleUtils.getStyle(this._layout, 'width', properties);
            var iconUrl = StyleUtils.getStyle(this._layout, 'icon', properties);
            var tubeUrl = './assets/tube1.png';
            var vertices = [];
            var normals = [];
            var texCoords = [];
            for (var i = 0; i < line.length; i += 1) {
                var point = [line[i][0] + offset[0], line[i][1] + offset[1], line[i][2]];
                if (i === 0) {
                    var start = [line[i][0] + offset[0], line[i][2]];
                    var end = [line[i + 1][0] + offset[0], line[i + 1][2]];
                    var normal = new Vector2(start, end).normal().unit();
                    normals.push(normal.x, normal.y, -normal.x, -normal.y);
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    texCoords.push(0, 1, 0, 0);
                }
                else if (i < line.length - 1) {
                    var last = [line[i - 1][0] + offset[0], line[i - 1][2]];
                    var cur = [line[i][0] + offset[0], line[i][2]];
                    var next = [line[i + 1][0] + offset[0], line[i + 1][2]];
                    var dir1 = new Vector2(last, cur);
                    var normal1 = dir1.normal().unit();
                    normals.push(normal1.x, normal1.y, -normal1.x, -normal1.y);
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    texCoords.push(1 * dir1.getLength(), 1, 1 * dir1.getLength(), 0);
                    var normal2 = new Vector2(cur, next).normal().unit();
                    normals.push(normal2.x, normal2.y, -normal2.x, -normal2.y);
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    texCoords.push(0, 1, 0, 0);
                }
                else {
                    var start = [line[i - 1][0] + offset[0], line[i - 1][2]];
                    var end = [line[i][0] + offset[0], line[i][2]];
                    var dir = new Vector2(start, end);
                    var normal = dir.normal().unit();
                    normals.push(normal.x, normal.y, -normal.x, -normal.y);
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    texCoords.push(1 * dir.getLength(), 1, 1 * dir.getLength(), 0);
                }
            }
            this._geometryInfo.push({
                vertices: vertices,
                normals: normals,
                base: base,
                opacity: opacity,
                width: width,
                color: color,
                iconUrl: iconUrl,
                tubeUrl: tubeUrl,
                texCoords: texCoords,
            });
        };
        return ConnectionBucket;
    }(AbstractBucket));

    var HeatmapBucket = (function (_super) {
        __extends$1(HeatmapBucket, _super);
        function HeatmapBucket() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HeatmapBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                if (visible) {
                    if (geometry.type === 'Point') {
                        this._calcPoint(geometry.coordinates, properties);
                    }
                    else if (geometry.type === 'MultiPoint') {
                        for (var j = 0; j < geometry.coordinates.length; j += 1) {
                            this._calcPoint(geometry.coordinates[j], properties);
                        }
                    }
                }
            }
        };
        HeatmapBucket.prototype.clear = function () {
            this._features.length = 0;
        };
        HeatmapBucket.prototype._calcPoint = function (point, properties) {
            var offset = this._offset;
            var p = [point[0] + offset[0], point[1] + offset[1]];
            var radius = StyleUtils.getStyle(this._layout, 'radius', properties);
            this._geometryInfo.push({
                point: p,
                radius: radius,
            });
        };
        return HeatmapBucket;
    }(AbstractBucket));

    var LineBucket = (function (_super) {
        __extends$1(LineBucket, _super);
        function LineBucket() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._geometryMap = {};
            return _this;
        }
        LineBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                var _a = this._features[i], properties = _a.properties, geometry = _a.geometry;
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                if (visible) {
                    if (geometry.type === 'LineString') {
                        this._calcPolyline(geometry.coordinates, properties);
                    }
                    else if (geometry.type === 'MultiLineString') {
                        for (var j = 0; j < geometry.coordinates.length; j += 1) {
                            this._calcPolyline(geometry.coordinates[j], properties);
                        }
                    }
                }
            }
            for (var key in this._geometryMap) {
                this._geometryInfo.push(__assign$1(__assign$1({}, this._geometryMap[key]), { indices: this._geometryMap[key].indices.getValue() }));
            }
        };
        LineBucket.prototype.clear = function () {
            this._geometryMap = {};
        };
        LineBucket.prototype._calcPolyline = function (polyline, properties) {
            var offset = this._offset;
            var base = StyleUtils.getStyle(this._layout, 'base', properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);
            var width = StyleUtils.getStyle(this._layout, 'lineWidth', properties);
            var color = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'lineColor', properties));
            var iconUrl = StyleUtils.getStyle(this._layout, 'lineImage', properties);
            var vertices = [];
            var normals = [];
            var deviation = [];
            var texCoords = [];
            var indices = [];
            for (var i = 0; i < polyline.length; i += 1) {
                var point = [polyline[i][0] + offset[0], polyline[i][1] + offset[1]];
                var startNum = vertices.length / 2;
                if (i === 0) {
                    var dir = new Vector2(polyline[i], polyline[i + 1]);
                    var normal = dir.normal().unit();
                    var length1 = dir.getLength();
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    texCoords.push(-1 * length1 * 0.14, 1, -1 * length1 * 0.14, 0);
                    deviation.push(0, 0, 0, 0, 0, 0);
                    normals.push(normal.x, normal.y, -normal.x, -normal.y);
                    indices.push(startNum + 0, startNum + 1);
                }
                else if (i < polyline.length - 1) {
                    var lastPoint = [polyline[i - 1][0] + offset[0], polyline[i - 1][1] + offset[1]];
                    var nextPoint = [polyline[i + 1][0] + offset[0], polyline[i + 1][1] + offset[1]];
                    var dir1 = new Vector2(lastPoint, point);
                    var length1 = dir1.getLength();
                    var unitDir1 = dir1.unit();
                    var normal1 = unitDir1.normal();
                    var dir2 = new Vector2(point, nextPoint);
                    var length2 = dir2.getLength();
                    var unitDir2 = dir2.unit();
                    var normal2 = unitDir2.normal();
                    var angle = Math.abs(normal1.angleTo(normal2));
                    angle = angle === 180 ? 0 : angle;
                    angle = angle / 180 * Math.PI;
                    var offsetNum = Math.tan(angle / 2);
                    unitDir1.multiply(-offsetNum);
                    unitDir2.multiply(offsetNum);
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    texCoords.push(1 * length1, 1, 1 * length1, 0);
                    deviation.push(unitDir1.x, unitDir1.y, length1, unitDir1.x, unitDir1.y, length1);
                    indices.push(startNum, startNum - 1, startNum, startNum + 1);
                    normals.push(normal1.x, normal1.y, -normal1.x, -normal1.y);
                    var flat = normal1.cross(normal2) <= 0 ? -1 : 1;
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    texCoords.push(0, flat === -1 ? 1 : 0, 0, flat === -1 ? 0 : 0.93);
                    deviation.push(unitDir1.x, unitDir1.y, length1, unitDir1.x, unitDir1.y, length1);
                    normals.push(normal1.x, normal1.y, -normal1.x, -normal1.y);
                    startNum += 2;
                    var _a = LineBucket.getLineJoin(point, normal1, normal2, vertices.length / 2), subIndices = _a.indices, subVertices = _a.vertices, subNormals = _a.normals, subTexCoords = _a.texCoords, subDeviation = _a.deviation;
                    vertices.push.apply(vertices, subVertices);
                    indices.push.apply(indices, subIndices);
                    normals.push.apply(normals, subNormals);
                    deviation.push.apply(deviation, subDeviation);
                    texCoords.push.apply(texCoords, subTexCoords);
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    texCoords.push(0, flat === -1 ? 1 : 0, 0, flat === -1 ? 0 : 0.93);
                    deviation.push(unitDir2.x, unitDir2.y, length2, unitDir2.x, unitDir2.y, length2);
                    normals.push(normal2.x, normal2.y, -normal2.x, -normal2.y);
                    startNum += 2;
                    var subNum = subVertices.length / 2;
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    texCoords.push(0, 1, 0, 0);
                    deviation.push(unitDir2.x, unitDir2.y, length2, unitDir2.x, unitDir2.y, length2);
                    indices.push(startNum + 2 + subNum, startNum + 3 + subNum);
                    normals.push(normal2.x, normal2.y, -normal2.x, -normal2.y);
                }
                else {
                    var lastPoint = [polyline[i - 1][0] + offset[0], polyline[i - 1][1] + offset[1]];
                    var dir = new Vector2(lastPoint, point);
                    var length = dir.getLength();
                    var normal = dir.normal().unit();
                    vertices.push.apply(vertices, __spreadArrays(point, point));
                    deviation.push(0, 0, 0, 0, 0, 0);
                    texCoords.push(1 * length, 1, 1 * length, 0);
                    indices.push(startNum, startNum - 1, startNum, startNum + 1);
                    normals.push(normal.x, normal.y, -normal.x, -normal.y);
                }
            }
            var key = this._getGeometryKey(properties);
            if (this._geometryMap[key] &&
                this._geometryMap[key].vertices.length / 2 + vertices.length / 2 < 65536) {
                var geometry = this._geometryMap[key];
                var oldVerticesCount = geometry.vertices.length / 2;
                geometry.indices.add(indices, oldVerticesCount);
                geometry.vertices = geometry.vertices.concat(vertices);
                geometry.texCoords = geometry.texCoords.concat(texCoords);
                geometry.normals = geometry.normals.concat(normals);
                geometry.deviation = geometry.deviation.concat(deviation);
            }
            else {
                this._geometryMap[key] = {
                    vertices: vertices,
                    normals: normals,
                    base: base,
                    opacity: opacity,
                    width: width,
                    color: color,
                    deviation: deviation,
                    iconUrl: iconUrl,
                    texCoords: texCoords,
                    indices: new Indices(indices),
                };
            }
        };
        LineBucket.prototype._getGeometryKey = function (properties) {
            var arr = [];
            for (var i = 0; i < LineBucket.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, LineBucket.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            return arr.join('-');
        };
        LineBucket.getLineJoin = function (point, v0, v1, indexOffset) {
            var vertices = [];
            var texCoords = [];
            var deviation = [];
            var normals = [];
            var indices = [];
            var step = Math.PI / 16;
            var maxAngle = Math.abs(v0.angleTo(v1)) / 180 * Math.PI + step;
            var dir = v0.clone().add(v1).unit();
            var normal = dir.normal();
            var dir1Normal = v0.unit().normal();
            var num = 1 / normal.dot(dir1Normal);
            var flat = v0.cross(v1) <= 0 ? -1 : 1;
            dir.multiply(num * flat);
            vertices.push.apply(vertices, point);
            texCoords.push(0, 0.7);
            deviation.push(0, 0, 0);
            normals.push(0, 0);
            if (maxAngle > step) {
                indices.push(indexOffset - 1, indexOffset, indexOffset + 1, indexOffset - 2, indexOffset - 1, flat === -1 ? indexOffset + 1 : indexOffset);
            }
            var v0_scale = v0.clone().multiply(-1 * flat);
            var index = indexOffset;
            for (var angle = 0; angle < maxAngle; angle += step) {
                var rotateVector = v0_scale.clone().rotate(angle * flat);
                vertices.push.apply(vertices, point);
                texCoords.push(0, 0.93);
                deviation.push(0, 0, 0);
                normals.push(rotateVector.x, rotateVector.y);
                if (angle + step < maxAngle) {
                    indices.push(indexOffset + 0);
                    indices.push(index + 1);
                    indices.push(index + 2);
                }
                else {
                    indices.push(indexOffset, index + 1, index + 3, flat === -1 ? index + 1 : indexOffset, index + 2, index + 3);
                }
                index += 1;
            }
            return { vertices: vertices, indices: indices, normals: normals, texCoords: texCoords, deviation: deviation };
        };
        LineBucket.GEOMETRY_KEYS = [
            'lineColor', 'lineWidth', 'base', 'opacity', 'lineImage',
        ];
        return LineBucket;
    }(AbstractBucket));

    var ModelBucket = (function (_super) {
        __extends$1(ModelBucket, _super);
        function ModelBucket() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ModelBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties, featureid = _a.featureid;
                if (featureid == undefined) {
                    if ((properties === null || properties === void 0 ? void 0 : properties.featureid) != null && (properties === null || properties === void 0 ? void 0 : properties.featureid) != undefined) {
                        featureid = properties === null || properties === void 0 ? void 0 : properties.featureid;
                    }
                    else if ((properties === null || properties === void 0 ? void 0 : properties.id) != null && (properties === null || properties === void 0 ? void 0 : properties.id) != undefined) {
                        featureid = properties === null || properties === void 0 ? void 0 : properties.id;
                    }
                }
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                if (visible) {
                    if (geometry.type === 'Point') {
                        this._calcPoint(geometry.coordinates, properties, featureid);
                    }
                    else if (geometry.type === 'MultiPoint') {
                        for (var j = 0; j < geometry.coordinates.length; j += 1) {
                            this._calcPoint(geometry.coordinates[j], properties, featureid);
                        }
                    }
                }
            }
        };
        ModelBucket.prototype.clear = function () {
            this._features.length = 0;
        };
        ModelBucket.prototype._calcPoint = function (point, properties, featureId) {
            var url = StyleUtils.getStyle(this._layout, 'url', properties);
            if (!url)
                return;
            var offset = this._offset;
            var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
            if (!visible)
                return;
            var matrix = new Matrix4$1();
            var p = [point[0] + offset[0], point[1] + offset[1]];
            var offsetArr = StyleUtils.getStyle(this._layout, 'offset', properties);
            if (offsetArr) {
                p[0] += offsetArr[0];
                p[1] += offsetArr[1];
            }
            var base = StyleUtils.getStyle(this._layout, 'base', properties);
            var size = StyleUtils.getStyle(this._layout, 'size', properties);
            var rotateX = StyleUtils.getStyle(this._layout, 'rotateX', properties);
            var rotateY = StyleUtils.getStyle(this._layout, 'rotateY', properties);
            var rotateZ = StyleUtils.getStyle(this._layout, 'rotateZ', properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);
            var stops = StyleUtils.getStyle(this._layout, 'stops', properties);
            var brightness = StyleUtils.getStyle(this._layout, 'brightness', properties);
            var isExtra = false;
            if (properties == null || properties == undefined) {
                isExtra = false;
            }
            else {
                if (properties.isExtra == null || properties.isExtra == undefined) {
                    isExtra = false;
                }
                else {
                    isExtra = properties.isExtra;
                }
            }
            if (brightness === null || brightness === undefined) {
                brightness = 1.0;
            }
            matrix.scale(size, size, size);
            matrix.rotate(rotateX, 1, 0, 0);
            matrix.rotate(rotateY, 0, 1, 0);
            matrix.rotate(rotateZ, 0, 0, 1);
            this._geometryInfo.push({
                matrix: matrix.getValue(),
                opacity: opacity,
                point: p,
                base: base,
                url: url,
                stops: stops,
                brightness: brightness,
                featureId: featureId,
                isExtra: isExtra,
            });
        };
        return ModelBucket;
    }(AbstractBucket));

    var TrackBucket = (function (_super) {
        __extends$1(TrackBucket, _super);
        function TrackBucket() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._geometryMap = {};
            return _this;
        }
        TrackBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                if (visible) {
                    if (geometry.type === 'LineString') {
                        this._calcPolyline(geometry.coordinates, properties);
                    }
                    else if (geometry.type === 'MultiLineString') {
                        for (var j = 0; j < geometry.coordinates.length; j += 1) {
                            this._calcPolyline(geometry.coordinates[j], properties);
                        }
                    }
                }
            }
            for (var key in this._geometryMap) {
                this._geometryInfo.push(__assign$1(__assign$1({}, this._geometryMap[key]), { indices: this._geometryMap[key].indices.getValue() }));
            }
        };
        TrackBucket.prototype.clear = function () {
            this._features.length = 0;
            this._geometryMap = {};
        };
        TrackBucket.prototype._calcPolyline = function (polyline, properties) {
            if (polyline.length < 2)
                return;
            var vertices = [];
            var offset = this._offset;
            var indices = [];
            for (var i = 0; i < polyline.length; i += 1) {
                var _a = polyline[i], x = _a[0], y = _a[1];
                vertices.push(x + offset[0], y + offset[1]);
                if (i + 1 < polyline.length) {
                    indices.push(i, i + 1);
                }
            }
            var color = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'color', properties));
            var base = StyleUtils.getStyle(this._layout, 'base', properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);
            var key = this._getGeometryKey(properties);
            if (this._geometryMap[key] &&
                this._geometryMap[key].vertices.length / 2 + vertices.length / 2 < 65536) {
                var geometry = this._geometryMap[key];
                var oldVerticesCount = geometry.vertices.length / 2;
                geometry.indices.add(indices, oldVerticesCount);
                geometry.vertices = geometry.vertices.concat(vertices);
            }
            else {
                if (this._geometryMap[key]) {
                    this._geometryMap[IdGenerator.getId()] = this._geometryMap[key];
                }
                this._geometryMap[key] = {
                    vertices: vertices,
                    color: color,
                    base: base,
                    indices: new Indices(indices),
                    opacity: opacity,
                };
            }
        };
        TrackBucket.prototype._getGeometryKey = function (properties) {
            var arr = [];
            for (var i = 0; i < TrackBucket.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, TrackBucket.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            return arr.join('-');
        };
        TrackBucket.GEOMETRY_KEYS = ['color', 'base', 'opacity'];
        return TrackBucket;
    }(AbstractBucket));

    var PictureBucket = (function (_super) {
        __extends$1(PictureBucket, _super);
        function PictureBucket() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PictureBucket.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                var _a = this._features[i], geometry = _a.geometry, properties = _a.properties;
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                if (visible) {
                    if (geometry.type === 'Point') {
                        this._calcPoint(geometry.coordinates, this._features[i]);
                    }
                    else if (geometry.type === 'MultiPoint') {
                        for (var j = 0; j < geometry.coordinates.length; j += 1) {
                            this._calcPoint(geometry.coordinates[j], this._features[i]);
                        }
                    }
                }
            }
        };
        PictureBucket.prototype.clear = function () {
            this._features.length = 0;
        };
        PictureBucket.prototype._calcPoint = function (point, item) {
            var offset = this._offset;
            var iconUrl = StyleUtils.getStyle(this._layout, 'iconImage', item.properties);
            if (!iconUrl)
                return;
            var p = [point[0] + offset[0], point[1] + offset[1]];
            var offsetArr = StyleUtils.getStyle(this._layout, 'offset', item.properties);
            if (offsetArr) {
                p[0] += offsetArr[0];
                p[1] += offsetArr[1];
            }
            var base = StyleUtils.getStyle(this._layout, 'base', item.properties);
            var size = StyleUtils.getStyle(this._layout, 'size', item.properties);
            var rotate = StyleUtils.getStyle(this._layout, 'rotate', item.properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', item.properties);
            var anchor = StyleUtils.getStyle(this._layout, 'anchor', item.properties);
            var width = item.imgSize[0] * size;
            var height = item.imgSize[1] * size;
            var geometry = createPointGeometry(p, width, height, anchor);
            this._geometryInfo.push({
                opacity: opacity,
                base: base,
                rotate: rotate,
                point: p,
                vertices: geometry.vertices,
                iconUrl: iconUrl,
                texCoords: geometry.texCoords,
                index: item.index,
            });
        };
        return PictureBucket;
    }(AbstractBucket));

    var FillExtrusionBucketNoCut = (function (_super) {
        __extends$1(FillExtrusionBucketNoCut, _super);
        function FillExtrusionBucketNoCut() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._geometryMap = {};
            return _this;
        }
        FillExtrusionBucketNoCut.prototype.init = function () {
            for (var i = 0; i < this._features.length; i += 1) {
                this._update(this._features[i]);
            }
            this._fireMessage();
        };
        FillExtrusionBucketNoCut.prototype.clear = function () {
            this._features.length = 0;
            this._geometryMap = {};
        };
        FillExtrusionBucketNoCut.prototype._fireMessage = function () {
            this._geometryInfo.length = 0;
            for (var key in this._geometryMap) {
                var item = this._geometryMap[key];
                this._geometryInfo.push({
                    vertices: item.vertices,
                    sideVertices: [],
                    fillIndices: item.fillIndices.getValue(),
                    sideIndices: [],
                    outlineIndices: item.outlineIndices.getValue(),
                    fillColor: item.fillColor,
                    outlineColor: item.outlineColor,
                    base: item.base,
                    opacity: item.opacity,
                    normals: item.normals,
                    sideNormals: [],
                    height: item.height,
                    stops: item.stops,
                    zoomRange: item.zoomRange,
                    floorString: item.floorString,
                    featureId: item.featureId,
                    colorId: item.colorId,
                    texCoordArray: item.texCoordArray,
                    sideTexCoordArray: [],
                    texCoord: [],
                    texture: null,
                    sideTexture: null,
                    isF0: item.isF0,
                    textureUrl: item.textureUrl,
                    sideTextureUrl: item.sideTextureUrl
                });
            }
        };
        FillExtrusionBucketNoCut.prototype.IsHideFeatureByCategoryId = function (categoryid) {
            for (var i = 0; i < this._hideCategoryId.length; i++) {
                if (categoryid == this._hideCategoryId[i]) {
                    return true;
                }
            }
            return false;
        };
        FillExtrusionBucketNoCut.prototype.isExtra = function (properties) {
            if (properties == null || properties == undefined) {
                return false;
            }
            if (properties.isExtra != null && properties.isExtra != undefined) {
                return properties.isExtra;
            }
            var colorid = properties === null || properties === void 0 ? void 0 : properties.colorid;
            if (colorid == null || colorid == undefined) {
                return false;
            }
            if (colorid == 7 || colorid == 8) {
                return true;
            }
            else {
                return false;
            }
        };
        FillExtrusionBucketNoCut.prototype.IsHideFeatureByColorId = function (colorId) {
            for (var i = 0; i < this._hideColorId.length; i++) {
                if (colorId == this._hideColorId[i]) {
                    return true;
                }
            }
            return false;
        };
        FillExtrusionBucketNoCut.prototype._update = function (feature) {
            var geometry = feature.geometry, properties = feature.properties, featureid = feature.featureid;
            if (featureid == undefined || featureid == null) {
                featureid = properties === null || properties === void 0 ? void 0 : properties.id;
            }
            if (properties
                && (this.IsHideFeatureByCategoryId(properties.categoryid) || this.IsHideFeatureByColorId(properties.colorid))) {
                LogMgr$1.log('鏈哄満蹇界暐鏌卞瓙');
                return;
            }
            var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
            if (visible) {
                if (geometry.type === 'Polygon') {
                    this._calcPolygon(geometry.coordinates, properties, featureid);
                }
                else if (geometry.type === 'MultiPolygon') {
                    for (var i = 0; i < geometry.coordinates.length; i += 1) {
                        this._calcPolygon(geometry.coordinates[i], properties, featureid);
                    }
                }
            }
        };
        FillExtrusionBucketNoCut.prototype._calcPolygon = function (polygon, properties, featureid) {
            var offset = this._offset;
            var vertices = [];
            var sideVertices = [];
            var sideIndices = [];
            var holes = [];
            var outlineIndices = [];
            var normals = [];
            var topNormals = [];
            var enableOutline = StyleUtils.getStyle(this._layout, 'enableOutline', properties);
            var height = StyleUtils.getStyle(this._layout, 'height', properties);
            var texCoordArray = [];
            var isF0 = this.IsF0(featureid);
            var factor = 1.0;
            var zoomRange = [0, 24];
            properties === null || properties === void 0 ? void 0 : properties.id;
            if (isF0 == false && featureid) {
                var featureType = featureid.charAt(9);
                zoomRange = ZoomRangeConfig.zoomRangeTable[parseInt(featureType)];
            }
            var floorStr = this.GetFloor(featureid);
            for (var i = 0; i < polygon.length; i += 1) {
                var face = polygon[i];
                for (var j = 0; j < face.length; j += 1) {
                    var curX = face[j][0] + offset[0];
                    var curY = face[j][1] + offset[1];
                    var sideCount = sideVertices.length / 3;
                    if (j < face.length - 1) {
                        if (enableOutline) {
                            var verticesCount = vertices.length / 3;
                            outlineIndices.push(verticesCount, verticesCount + 1);
                        }
                        var normalVector = new Vector2(face[j], face[j + 1]).normal();
                        normals.push(normalVector.x, normalVector.y, 0);
                        normals.push(normalVector.x, normalVector.y, 1);
                        normals.push(normalVector.x, normalVector.y, 0);
                        normals.push(normalVector.x, normalVector.y, 1);
                        var nextX = face[j + 1][0] + offset[0];
                        var nextY = face[j + 1][1] + offset[1];
                        sideVertices.push(curX, curY, 0);
                        sideVertices.push(curX, curY, 1);
                        sideVertices.push(nextX, nextY, 0);
                        sideVertices.push(nextX, nextY, 1);
                        sideIndices.push(sideCount + 0, sideCount + 1, sideCount + 2);
                        sideIndices.push(sideCount + 1, sideCount + 2, sideCount + 3);
                    }
                    topNormals.push(0, 0, FillExtrusionBucketNoCut.FACTOR + 1);
                    vertices.push(curX, curY, FillExtrusionBucketNoCut.FACTOR + 1);
                    if (Global.m_bTextureEnable) {
                        texCoordArray.push(curX * factor, curY * factor);
                    }
                }
                if (i < polygon.length - 1) {
                    holes.push(vertices.length / 3);
                }
            }
            var indices = earcut_1(vertices, holes.length === 0 ? undefined : holes, 3);
            var topFaceCount = vertices.length / 3;
            for (var i = 0; i < sideIndices.length; i += 1) {
                indices.push(sideIndices[i] + topFaceCount);
            }
            var totalCount = topFaceCount + sideVertices.length / 3;
            var fillColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'fillColor', properties));
            var outlineColor = StyleUtils.parseColor(StyleUtils.getStyle(this._layout, 'outlineColor', properties));
            var base = StyleUtils.getStyle(this._layout, 'base', properties);
            var opacity = StyleUtils.getStyle(this._layout, 'opacity', properties);
            var stops = StyleUtils.getStyle(this._layout, 'stops', properties);
            var featureTextureUrl = this.GetTextureByFeatureId(featureid);
            if (this.isExtra(properties) == false && featureTextureUrl == '') {
                featureid = '';
            }
            else {
                LogMgr$1.log('isExtra featureId: ' + featureid);
            }
            var key = this._getGeometryKey2(properties, featureTextureUrl + featureid + '-' + height);
            if (this._geometryMap[key] &&
                this._geometryMap[key].vertices.length / 3 + totalCount < 65536) {
                var geometry = this._geometryMap[key];
                var oldVerticesCount = geometry.vertices.length / 3;
                geometry.fillIndices.add(indices, oldVerticesCount);
                geometry.outlineIndices.add(outlineIndices, oldVerticesCount);
                geometry.vertices = geometry.vertices.concat(vertices).concat(sideVertices);
                geometry.normals = geometry.normals.concat(topNormals).concat(normals);
                geometry.floorString = floorStr;
                geometry.featureId = featureid;
                geometry.colorId = properties === null || properties === void 0 ? void 0 : properties.colorid;
                geometry.texCoordArray = geometry.texCoordArray.concat(texCoordArray);
                geometry.isF0 = isF0;
                geometry.textureUrl = featureTextureUrl;
                geometry.sideTextureUrl = '';
            }
            else {
                if (this._geometryMap[key]) {
                    this._geometryMap[IdGenerator.getId()] = this._geometryMap[key];
                }
                this._geometryMap[key] = {
                    fillIndices: new Indices(indices),
                    vertices: vertices.concat(sideVertices),
                    normals: topNormals.concat(normals),
                    outlineIndices: new Indices(outlineIndices),
                    zoomRange: zoomRange,
                    floorString: floorStr,
                    featureId: featureid,
                    colorId: properties === null || properties === void 0 ? void 0 : properties.colorid,
                    texCoordArray: texCoordArray,
                    fillColor: fillColor,
                    outlineColor: outlineColor,
                    height: height,
                    base: base,
                    opacity: opacity,
                    stops: stops,
                    isF0: isF0,
                    textureUrl: featureTextureUrl,
                    sideTextureUrl: '',
                };
            }
        };
        FillExtrusionBucketNoCut.prototype._getGeometryKey = function (properties) {
            var arr = [];
            for (var i = 0; i < FillExtrusionBucketNoCut.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucketNoCut.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            return arr.join('-');
        };
        FillExtrusionBucketNoCut.prototype._getGeometryKey2 = function (properties, textureUrl) {
            var arr = [];
            for (var i = 0; i < FillExtrusionBucketNoCut.GEOMETRY_KEYS.length; i += 1) {
                var style = StyleUtils.getStyle(this._layout, FillExtrusionBucketNoCut.GEOMETRY_KEYS[i], properties);
                style !== undefined && arr.push(style);
            }
            arr.push(textureUrl);
            return arr.join('-');
        };
        FillExtrusionBucketNoCut.GEOMETRY_KEYS = [
            'fillColor', 'outlineColor', 'height', 'base', 'opacity', 'stops',
        ];
        FillExtrusionBucketNoCut.FACTOR = Math.pow(2, 13);
        return FillExtrusionBucketNoCut;
    }(AbstractBucket));

    var BucketFactor = (function () {
        function BucketFactor() {
        }
        BucketFactor.prototype.calculate = function (data) {
            var bucket;
            var result = null;
            if (data.type === 'fill') {
                bucket = new FillBucket(data);
            }
            else if (data.type === 'fillExtrusion') {
                var bOnly2d = data.bOnly2d;
                var bCutFeature = data.bCutFeature;
                if (bOnly2d) {
                    bucket = new FillExtrusionBucket2d(data);
                }
                else if (bCutFeature) {
                    bucket = new FillExtrusionBucket(data);
                }
                else {
                    bucket = new FillExtrusionBucketNoCut(data);
                    LogMgr$1.log('use no cut fillExtrusion.');
                }
            }
            else if (data.type === 'circle') {
                bucket = new CircleBucket(data);
            }
            else if (data.type === 'symbol') {
                bucket = new SymbolBucket(data);
            }
            else if (data.type === 'connection') {
                bucket = new ConnectionBucket(data);
            }
            else if (data.type === 'heatmap') {
                bucket = new HeatmapBucket(data);
            }
            else if (data.type === 'line') {
                bucket = new LineBucket(data);
            }
            else if (data.type === 'model') {
                bucket = new ModelBucket(data);
            }
            else if (data.type === 'track') {
                bucket = new TrackBucket(data);
            }
            else if (data.type === 'picture') {
                bucket = new PictureBucket(data);
            }
            if (bucket) {
                bucket.init();
                result = bucket.getDrawInfo();
                bucket.clear();
            }
            return result;
        };
        return BucketFactor;
    }());

    var BucketManager = (function () {
        function BucketManager() {
            var _this = this;
            this._workerPool = [];
            this._freeIndies = [];
            this._dataList = new ArraySet();
            this._taskMap = new Map();
            this._isNeedUpdateCollision = false;
            this._factor = new BucketFactor();
            this._listeners = new Map();
            this._group = new Set();
            var num = (navigator.hardwareConcurrency || 4) - 1;
            var _loop_1 = function (i) {
                this_1._workerPool.push(new Worker$2());
                this_1._freeIndies.push(i);
                this_1._workerPool[i].addEventListener('message', function (e) {
                    _this._freeIndies.push(i);
                    _this._onMessage(e.data);
                    var nextData = _this._dataList.shift();
                    nextData && _this._update(nextData);
                });
            };
            var this_1 = this;
            for (var i = 0; i < num; i += 1) {
                _loop_1(i);
            }
        }
        BucketManager.prototype.normalize = function (ids) {
            this._group = new Set(ids);
        };
        BucketManager.prototype._onMessage = function (data) {
            var item = this._taskMap.get(data.id);
            if (!item)
                return;
            if (data.taskId === item[item.length - 1]) {
                this._taskMap.delete(data.id);
                this._group.delete(data.id);
            }
            {
                this._isNeedUpdateCollision = true;
            }
            if (this._group.size === 0) {
                data.isUpdateCollision = this._isNeedUpdateCollision;
                this._isNeedUpdateCollision = false;
            }
            data.isRender = this._group.size === 0;
            var listener = this._listeners.get(data.id);
            listener && listener(data);
        };
        BucketManager.prototype.update = function (data) {
            var item = this._taskMap.get(data.id);
            if (item) {
                item.push(data.taskId);
            }
            else {
                this._taskMap.set(data.id, [data.taskId]);
            }
            if (data.sync) {
                var result = this._factor.calculate(data);
                result && this._onMessage(result);
            }
            else if (this._freeIndies.length > 0) {
                this._update(data);
            }
            else {
                this._dataList.set(data);
            }
        };
        BucketManager.prototype._update = function (data) {
            if (this._freeIndies.length === 0)
                return;
            var index = this._freeIndies.pop();
            this._workerPool[index].postMessage(data);
        };
        BucketManager.prototype.register = function (id, listener) {
            this._listeners.set(id, listener);
        };
        BucketManager.prototype.unregister = function (id) {
            this._listeners.delete(id);
        };
        BucketManager.prototype.clearRegister = function () {
            this._listeners.clear();
        };
        BucketManager.prototype.clear = function () {
            this._dataList.clear();
            this._taskMap.clear();
        };
        BucketManager.prototype.destroy = function () {
            this.clear();
            for (var i = 0; i < this._workerPool.length; i += 1) {
                this._workerPool[i].terminate();
            }
            this._listeners.clear();
        };
        return BucketManager;
    }());

    function createCanvas(width, height, devicePixelRatio) {
        if (devicePixelRatio === void 0) { devicePixelRatio = 1; }
        var canvas = document.createElement('canvas');
        canvas.width = width * devicePixelRatio;
        canvas.height = height * devicePixelRatio;
        canvas.textContent = 'Your browser is not support canvas';
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        return canvas;
    }
    function getWebglRender(canvas, attributes) {
        var gl = canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes);
        if (!gl) {
            throw new Error('webgl is not support');
        }
        return gl;
    }
    function getContainerRange(rect) {
        var width = rect.width, height = rect.height;
        return {
            width: width || 400,
            height: height || 300,
        };
    }
    var EngineUtils = {
        createCanvas: createCanvas,
        getWebglRender: getWebglRender,
        getContainerRange: getContainerRange,
    };

    var Point3 = (function () {
        function Point3(x, y, z) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.x = x;
            this.y = y;
            this.z = z;
        }
        Point3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        Point3.prototype.add = function (point) {
            this.x += point.x;
            this.y += point.y;
            this.z += point.z;
            return this;
        };
        Point3.prototype.subtract = function (point) {
            this.x -= point.x;
            this.y -= point.y;
            this.z -= point.z;
            return this;
        };
        Point3.prototype.divide = function (num) {
            this.x /= num;
            this.y /= num;
            this.z /= num;
            return this;
        };
        Point3.prototype.equal = function (point) {
            return this.x === point.x && this.y === point.y && this.z == point.z;
        };
        Point3.prototype.clone = function () {
            return new Point3(this.x, this.y, this.z);
        };
        Point3.prototype.distanceTo = function (point) {
            return Math.sqrt(Math.pow((this.x - point.x), 2) + Math.pow((this.y - point.y), 2) + Math.pow((this.z - point.z), 2));
        };
        Point3.prototype.multiply = function (num) {
            this.x *= num;
            this.y *= num;
            this.z *= num;
            return this;
        };
        Point3.prototype.getLength = function () {
            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2));
        };
        Point3.prototype.floor = function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this;
        };
        Point3.prototype.ceil = function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this;
        };
        Point3.prototype.round = function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this;
        };
        Point3.prototype.normalize = function () {
            var length = this.getLength();
            this.x /= length;
            this.y /= length;
            this.z /= length;
        };
        Point3.prototype.cross = function (other) {
            this.x = this.y * other.z - other.y * this.z;
            this.y = this.z * other.x - other.z * this.x;
            this.z = this.x * other.y - other.x * this.y;
            return this;
        };
        Point3.prototype.GetRotate = function () {
            var radian = 0;
            if (this.x > 0 && this.y > 0) {
                radian = Math.atan(this.y / this.x);
            }
            else if (this.x < 0 && this.y > 0) {
                radian = 0.5 * Math.PI + Math.atan(Math.abs(this.x / this.y));
            }
            else if (this.x < 0 && this.y < 0) {
                radian = Math.PI + Math.atan(Math.abs(this.y / this.x));
            }
            else if (this.x > 0 && this.y < 0) {
                radian = 3.0 / 2.0 * Math.PI + Math.atan(Math.abs(this.x / this.y));
            }
            else if (this.x == 0 && this.y != 0) {
                if (this.y > 0) {
                    radian = 0.5 * Math.PI;
                }
                else {
                    radian = 3.0 / 2.0 * Math.PI;
                }
            }
            else if (this.y == 0 && this.x != 0) {
                if (this.x > 0) {
                    radian = 0;
                }
                else {
                    radian = Math.PI;
                }
            }
            else {
                radian = 0;
            }
            return radian / 2.0 / Math.PI * 360;
        };
        Point3.prototype.GetPitch = function () {
            var xyDis = Math.sqrt(this.x * this.x + this.y * this.y);
            var pitchRadian = Math.atan(xyDis / this.z);
            return pitchRadian / 2.0 / Math.PI * 360;
        };
        return Point3;
    }());

    var Color = (function () {
        function Color(r, g, b, a) {
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 0;
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        Color.prototype.clone = function () {
            return new Color(this.r, this.g, this.b, this.a);
        };
        return Color;
    }());

    var Texture = (function () {
        function Texture() {
            this.m_glTexture = null;
        }
        Texture.prototype.Destroy = function () {
        };
        return Texture;
    }());

    var ShadowTexture = (function (_super) {
        __extends$1(ShadowTexture, _super);
        function ShadowTexture() {
            var _this = _super.call(this) || this;
            _this.m_width = 0;
            _this.m_height = 0;
            _this.m_bDirty = false;
            _this.m_frameBuffer = null;
            _this.m_depthBuffer = null;
            _this.m_shadowTexture = null;
            _this.m_defaultWidth = 8192;
            _this.m_defaultHeight = 8192;
            return _this;
        }
        ShadowTexture.prototype.Destroy = function () {
            var engine = ShadowMgr$1.GetInstance().GetEngine();
            if (engine == null || engine == undefined) {
                _super.prototype.Destroy.call(this);
                return;
            }
            var gl = engine.getGl();
            if (gl == null || gl == undefined) {
                _super.prototype.Destroy.call(this);
                return;
            }
            gl.deleteFramebuffer(this.m_frameBuffer);
            gl.deleteRenderbuffer(this.m_depthBuffer);
            gl.deleteTexture(this.m_glTexture);
            _super.prototype.Destroy.call(this);
        };
        ShadowTexture.prototype.IsDirty = function () {
            return this.m_bDirty;
        };
        ShadowTexture.prototype.Init = function (engine, width, height) {
            if (engine == null || engine == undefined) {
                return false;
            }
            var gl = engine.getGl();
            if (gl == null || gl == undefined) {
                return false;
            }
            var frameBuffer = gl.createFramebuffer();
            if (frameBuffer == null || frameBuffer == undefined) {
                LogMgr$1.log('create shadow frame buffer failed');
            }
            var shadowTexture = gl.createTexture();
            if (shadowTexture == null || shadowTexture == undefined) {
                LogMgr$1.log('create shadow texture failed');
            }
            this.m_shadowTexture = shadowTexture;
            if (width == 0 || width == null || width == undefined) {
                width = this.m_defaultWidth;
            }
            if (height == 0 || height == null || height == undefined) {
                height = this.m_defaultHeight;
            }
            this.m_width = width;
            this.m_height = height;
            gl.bindTexture(gl.TEXTURE_2D, shadowTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.m_width, this.m_height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            var depthBuffer = gl.createRenderbuffer();
            if (depthBuffer == null || depthBuffer == undefined) {
                LogMgr$1.log('Create Render Buffer Failed');
                return false;
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.m_width, this.m_height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, shadowTexture, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);
            var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (e != gl.FRAMEBUFFER_COMPLETE) {
                return false;
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            this.m_frameBuffer = frameBuffer;
            return true;
        };
        ShadowTexture.prototype.SwitchFrameBuffer = function () {
            var engine = ShadowMgr$1.GetInstance().GetEngine();
            if (engine == null || engine == undefined) {
                return;
            }
            var gl = engine.getGl();
            if (gl == null || gl == undefined) {
                return;
            }
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.m_frameBuffer);
            gl.viewport(0, 0, this.m_width, this.m_height);
            gl.clearDepth(1.0);
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
        };
        ShadowTexture.prototype.SwitchRenderBuffer = function () {
            var engine = ShadowMgr$1.GetInstance().GetEngine();
            if (engine == null || engine == undefined) {
                return;
            }
            var gl = engine.getGl();
            if (gl == null || gl == undefined) {
                return;
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.clearDepth(1.0);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
        };
        ShadowTexture.prototype.GetWebGLTexture = function () {
            return this.m_shadowTexture;
        };
        return ShadowTexture;
    }(Texture));

    var ShadowCamera = (function (_super) {
        __extends$1(ShadowCamera, _super);
        function ShadowCamera(width, height, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, width, height, options) || this;
            _this.m_pos = new Point3(0, 0, 0);
            _this.m_up = new Point3(0, 1, 0);
            _this.m_dir = new Point3(0, 0, 0);
            _this.m_width = 0;
            _this.m_height = 0;
            _this.m_worldMatrix = new Matrix4$1();
            _this._far = 10000.0;
            _this.m_worldMatrix.setIdentity();
            return _this;
        }
        ShadowCamera.prototype.Destroy = function () {
        };
        ShadowCamera.prototype.UpdatePos = function (pos) {
            this.m_pos = pos;
        };
        ShadowCamera.prototype.UpdateRotate = function (rotate) {
            this._rotate = rotate;
        };
        ShadowCamera.prototype.UpdatePitch = function (pitch) {
            this._pitch = pitch;
        };
        ShadowCamera.prototype.Init = function (pos, dir, up, width, height) {
            this.m_pos = pos;
            this.m_up = up;
            this.m_dir = dir;
            this.m_width = width;
            this.m_height = height;
            this._calcProjectionMatrix();
            this._calcViewMatrix();
        };
        ShadowCamera.prototype.UpdateMVPMatrix = function () {
            this._calcProjectionMatrix();
            this._calcViewMatrix();
        };
        ShadowCamera.prototype._calcProjectionMatrix = function () {
            this._projectionMatrix.setPerspective(this._fov, this._width / this._height, this._near, this._far);
        };
        ShadowCamera.prototype._calcViewMatrix = function () {
            var focalLength = Math.pow(2, (this._NATIVE_ZOOM - this._zoom));
            if (focalLength > this._far) {
                this._far = focalLength + 100;
                this._calcProjectionMatrix();
            }
            if (this.m_up == null || this.m_up == undefined
                || this.m_pos == null || this.m_pos == undefined) {
                return;
            }
            var center = { x: this._center.x + this._offset[0], y: this._center.y + this._offset[1] };
            var _a = AbstractCamera.calcEyeTargetUp(this._rotate, this._pitch, focalLength); _a.eye; _a.target; _a.up;
            this._up = [this.m_up.x, this.m_up.y, this.m_up.z];
            this._eye = [this.m_pos.x + center.x, this.m_pos.y + center.y, this.m_pos.z];
            this._target = [center.x, center.y, 0];
            this._viewMatrix.setLookAt(this._eye, this._target, this._up);
            this.m_worldMatrix.setIdentity();
            this.m_worldMatrix.translate(this.m_pos.x, this.m_pos.y, this.m_pos.z);
        };
        return ShadowCamera;
    }(Camera));

    var ShadowLight = (function () {
        function ShadowLight(pos, dir, up, width, height) {
            this.m_shadowTexture = null;
            this.m_bDirty = false;
            this.m_shadowCamera = null;
            this.m_width = 0;
            this.m_height = 0;
            this.m_pos = pos;
            this.m_dir = dir;
            this.m_up = up;
            this.m_width = width;
            this.m_height = height;
            this.m_bDirty = true;
        }
        ShadowLight.prototype.Destroy = function () {
            if (this.m_shadowTexture) {
                this.m_shadowTexture.Destroy();
            }
        };
        ShadowLight.prototype.UpdatePitch = function (pitch) {
            if (this.m_shadowCamera == null || this.m_shadowCamera == undefined) {
                return;
            }
            this.m_shadowCamera.UpdatePitch(pitch);
        };
        ShadowLight.prototype.UpdateRotate = function (rotate) {
            if (this.m_shadowCamera == null || this.m_shadowCamera == undefined) {
                return;
            }
            this.m_shadowCamera.UpdateRotate(rotate);
        };
        ShadowLight.prototype.UpdatePos = function (pos) {
            if (this.m_shadowCamera == null || this.m_shadowCamera == undefined) {
                return;
            }
            this.m_shadowCamera.UpdatePos(pos);
        };
        ShadowLight.prototype.Init = function () {
            var engine = ShadowMgr$1.GetInstance().GetEngine();
            this.m_shadowTexture = new ShadowTexture();
            this.m_shadowTexture.Init(engine, 0, 0);
            this.m_shadowCamera = new ShadowCamera(this.m_width, this.m_height);
            this.m_shadowCamera.Init(this.m_pos, this.m_dir, this.m_up, this.m_width, this.m_height);
        };
        ShadowLight.prototype.IsDirty = function () {
            return this.m_bDirty;
        };
        ShadowLight.prototype.Render = function () {
            var engine = ShadowMgr$1.GetInstance().GetEngine();
            if (engine == null || engine == undefined) {
                return;
            }
            if (this.m_shadowCamera == null || this.m_shadowCamera == undefined) {
                return;
            }
            if (this.m_shadowTexture == null || this.m_shadowTexture == undefined) {
                return;
            }
            this.m_shadowCamera.UpdateMVPMatrix();
            engine.SetCurCamera(this.m_shadowCamera);
            this.m_shadowTexture.SwitchFrameBuffer();
            engine._drawLayers(true);
            this.m_shadowTexture.SwitchRenderBuffer();
        };
        ShadowLight.prototype.GetShadowCamera = function () {
            return this.m_shadowCamera;
        };
        ShadowLight.prototype.GetShadowTexture = function () {
            return this.m_shadowTexture;
        };
        ShadowLight.prototype.ForceUpdate = function () {
            this.m_bDirty = true;
        };
        return ShadowLight;
    }());

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    var _Math = {

    	DEG2RAD: Math.PI / 180,
    	RAD2DEG: 180 / Math.PI,

    	generateUUID: ( function () {

    		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

    		var lut = [];

    		for ( var i = 0; i < 256; i ++ ) {

    			lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

    		}

    		return function generateUUID() {

    			var d0 = Math.random() * 0xffffffff | 0;
    			var d1 = Math.random() * 0xffffffff | 0;
    			var d2 = Math.random() * 0xffffffff | 0;
    			var d3 = Math.random() * 0xffffffff | 0;
    			var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
    				lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
    				lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
    				lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

    			// .toUpperCase() here flattens concatenated strings to save heap memory space.
    			return uuid.toUpperCase();

    		};

    	} )(),

    	clamp: function ( value, min, max ) {

    		return Math.max( min, Math.min( max, value ) );

    	},

    	// compute euclidian modulo of m % n
    	// https://en.wikipedia.org/wiki/Modulo_operation

    	euclideanModulo: function ( n, m ) {

    		return ( ( n % m ) + m ) % m;

    	},

    	// Linear mapping from range <a1, a2> to range <b1, b2>

    	mapLinear: function ( x, a1, a2, b1, b2 ) {

    		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    	},

    	// https://en.wikipedia.org/wiki/Linear_interpolation

    	lerp: function ( x, y, t ) {

    		return ( 1 - t ) * x + t * y;

    	},

    	// http://en.wikipedia.org/wiki/Smoothstep

    	smoothstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * ( 3 - 2 * x );

    	},

    	smootherstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    	},

    	// Random integer from <low, high> interval

    	randInt: function ( low, high ) {

    		return low + Math.floor( Math.random() * ( high - low + 1 ) );

    	},

    	// Random float from <low, high> interval

    	randFloat: function ( low, high ) {

    		return low + Math.random() * ( high - low );

    	},

    	// Random float from <-range/2, range/2> interval

    	randFloatSpread: function ( range ) {

    		return range * ( 0.5 - Math.random() );

    	},

    	degToRad: function ( degrees ) {

    		return degrees * _Math.DEG2RAD;

    	},

    	radToDeg: function ( radians ) {

    		return radians * _Math.RAD2DEG;

    	},

    	isPowerOfTwo: function ( value ) {

    		return ( value & ( value - 1 ) ) === 0 && value !== 0;

    	},

    	ceilPowerOfTwo: function ( value ) {

    		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

    	},

    	floorPowerOfTwo: function ( value ) {

    		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Matrix4() {

    	this.elements = [

    		1, 0, 0, 0,
    		0, 1, 0, 0,
    		0, 0, 1, 0,
    		0, 0, 0, 1

    	];

    	if ( arguments.length > 0 ) {

    		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    	}

    }

    Object.assign( Matrix4.prototype, {

    	isMatrix4: true,

    	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    		var te = this.elements;

    		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    		return this;

    	},

    	identity: function () {

    		this.set(

    			1, 0, 0, 0,
    			0, 1, 0, 0,
    			0, 0, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	clone: function () {

    		return new Matrix4().fromArray( this.elements );

    	},

    	copy: function ( m ) {

    		var te = this.elements;
    		var me = m.elements;

    		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
    		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
    		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
    		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

    		return this;

    	},

    	copyPosition: function ( m ) {

    		var te = this.elements, me = m.elements;

    		te[ 12 ] = me[ 12 ];
    		te[ 13 ] = me[ 13 ];
    		te[ 14 ] = me[ 14 ];

    		return this;

    	},

    	extractBasis: function ( xAxis, yAxis, zAxis ) {

    		xAxis.setFromMatrixColumn( this, 0 );
    		yAxis.setFromMatrixColumn( this, 1 );
    		zAxis.setFromMatrixColumn( this, 2 );

    		return this;

    	},

    	makeBasis: function ( xAxis, yAxis, zAxis ) {

    		this.set(
    			xAxis.x, yAxis.x, zAxis.x, 0,
    			xAxis.y, yAxis.y, zAxis.y, 0,
    			xAxis.z, yAxis.z, zAxis.z, 0,
    			0, 0, 0, 1
    		);

    		return this;

    	},

    	extractRotation: function () {

    		var v1 = new Vector3();

    		return function extractRotation( m ) {

    			// this method does not support reflection matrices

    			var te = this.elements;
    			var me = m.elements;

    			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
    			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
    			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

    			te[ 0 ] = me[ 0 ] * scaleX;
    			te[ 1 ] = me[ 1 ] * scaleX;
    			te[ 2 ] = me[ 2 ] * scaleX;
    			te[ 3 ] = 0;

    			te[ 4 ] = me[ 4 ] * scaleY;
    			te[ 5 ] = me[ 5 ] * scaleY;
    			te[ 6 ] = me[ 6 ] * scaleY;
    			te[ 7 ] = 0;

    			te[ 8 ] = me[ 8 ] * scaleZ;
    			te[ 9 ] = me[ 9 ] * scaleZ;
    			te[ 10 ] = me[ 10 ] * scaleZ;
    			te[ 11 ] = 0;

    			te[ 12 ] = 0;
    			te[ 13 ] = 0;
    			te[ 14 ] = 0;
    			te[ 15 ] = 1;

    			return this;

    		};

    	}(),

    	makeRotationFromEuler: function ( euler ) {

    		if ( ! ( euler && euler.isEuler ) ) {

    			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    		}

    		var te = this.elements;

    		var x = euler.x, y = euler.y, z = euler.z;
    		var a = Math.cos( x ), b = Math.sin( x );
    		var c = Math.cos( y ), d = Math.sin( y );
    		var e = Math.cos( z ), f = Math.sin( z );

    		if ( euler.order === 'XYZ' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - c * f;
    			te[ 8 ] = d;

    			te[ 1 ] = af + be * d;
    			te[ 5 ] = ae - bf * d;
    			te[ 9 ] = - b * c;

    			te[ 2 ] = bf - ae * d;
    			te[ 6 ] = be + af * d;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YXZ' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce + df * b;
    			te[ 4 ] = de * b - cf;
    			te[ 8 ] = a * d;

    			te[ 1 ] = a * f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b;

    			te[ 2 ] = cf * b - de;
    			te[ 6 ] = df + ce * b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZXY' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce - df * b;
    			te[ 4 ] = - a * f;
    			te[ 8 ] = de + cf * b;

    			te[ 1 ] = cf + de * b;
    			te[ 5 ] = a * e;
    			te[ 9 ] = df - ce * b;

    			te[ 2 ] = - a * d;
    			te[ 6 ] = b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZYX' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = be * d - af;
    			te[ 8 ] = ae * d + bf;

    			te[ 1 ] = c * f;
    			te[ 5 ] = bf * d + ae;
    			te[ 9 ] = af * d - be;

    			te[ 2 ] = - d;
    			te[ 6 ] = b * c;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YZX' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = bd - ac * f;
    			te[ 8 ] = bc * f + ad;

    			te[ 1 ] = f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b * e;

    			te[ 2 ] = - d * e;
    			te[ 6 ] = ad * f + bc;
    			te[ 10 ] = ac - bd * f;

    		} else if ( euler.order === 'XZY' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - f;
    			te[ 8 ] = d * e;

    			te[ 1 ] = ac * f + bd;
    			te[ 5 ] = a * e;
    			te[ 9 ] = ad * f - bc;

    			te[ 2 ] = bc * f - ad;
    			te[ 6 ] = b * e;
    			te[ 10 ] = bd * f + ac;

    		}

    		// bottom row
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// last column
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	},

    	makeRotationFromQuaternion: function () {

    		var zero = new Vector3( 0, 0, 0 );
    		var one = new Vector3( 1, 1, 1 );

    		return function makeRotationFromQuaternion( q ) {

    			return this.compose( zero, q, one );

    		};

    	}(),

    	lookAt: function () {

    		var x = new Vector3();
    		var y = new Vector3();
    		var z = new Vector3();

    		return function lookAt( eye, target, up ) {

    			var te = this.elements;

    			z.subVectors( eye, target );

    			if ( z.lengthSq() === 0 ) {

    				// eye and target are in the same position

    				z.z = 1;

    			}

    			z.normalize();
    			x.crossVectors( up, z );

    			if ( x.lengthSq() === 0 ) {

    				// up and z are parallel

    				if ( Math.abs( up.z ) === 1 ) {

    					z.x += 0.0001;

    				} else {

    					z.z += 0.0001;

    				}

    				z.normalize();
    				x.crossVectors( up, z );

    			}

    			x.normalize();
    			y.crossVectors( z, x );

    			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
    			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
    			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

    			return this;

    		};

    	}(),

    	multiply: function ( m, n ) {

    		if ( n !== undefined ) {

    			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
    			return this.multiplyMatrices( m, n );

    		}

    		return this.multiplyMatrices( this, m );

    	},

    	premultiply: function ( m ) {

    		return this.multiplyMatrices( m, this );

    	},

    	multiplyMatrices: function ( a, b ) {

    		var ae = a.elements;
    		var be = b.elements;
    		var te = this.elements;

    		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    		return this;

    	},

    	multiplyScalar: function ( s ) {

    		var te = this.elements;

    		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    		return this;

    	},

    	applyToBufferAttribute: function () {

    		var v1 = new Vector3();

    		return function applyToBufferAttribute( attribute ) {

    			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

    				v1.x = attribute.getX( i );
    				v1.y = attribute.getY( i );
    				v1.z = attribute.getZ( i );

    				v1.applyMatrix4( this );

    				attribute.setXYZ( i, v1.x, v1.y, v1.z );

    			}

    			return attribute;

    		};

    	}(),

    	determinant: function () {

    		var te = this.elements;

    		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    		//TODO: make this more efficient
    		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    		return (
    			n41 * (
    				+ n14 * n23 * n32
    				 - n13 * n24 * n32
    				 - n14 * n22 * n33
    				 + n12 * n24 * n33
    				 + n13 * n22 * n34
    				 - n12 * n23 * n34
    			) +
    			n42 * (
    				+ n11 * n23 * n34
    				 - n11 * n24 * n33
    				 + n14 * n21 * n33
    				 - n13 * n21 * n34
    				 + n13 * n24 * n31
    				 - n14 * n23 * n31
    			) +
    			n43 * (
    				+ n11 * n24 * n32
    				 - n11 * n22 * n34
    				 - n14 * n21 * n32
    				 + n12 * n21 * n34
    				 + n14 * n22 * n31
    				 - n12 * n24 * n31
    			) +
    			n44 * (
    				- n13 * n22 * n31
    				 - n11 * n23 * n32
    				 + n11 * n22 * n33
    				 + n13 * n21 * n32
    				 - n12 * n21 * n33
    				 + n12 * n23 * n31
    			)

    		);

    	},

    	transpose: function () {

    		var te = this.elements;
    		var tmp;

    		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    		return this;

    	},

    	setPosition: function ( v ) {

    		var te = this.elements;

    		te[ 12 ] = v.x;
    		te[ 13 ] = v.y;
    		te[ 14 ] = v.z;

    		return this;

    	},

    	getInverse: function ( m, throwOnDegenerate ) {

    		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    		var te = this.elements,
    			me = m.elements,

    			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
    			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
    			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
    			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

    			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
    			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
    			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
    			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    		if ( det === 0 ) {

    			var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

    			if ( throwOnDegenerate === true ) {

    				throw new Error( msg );

    			} else {

    				console.warn( msg );

    			}

    			return this.identity();

    		}

    		var detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
    		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
    		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

    		te[ 4 ] = t12 * detInv;
    		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
    		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
    		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

    		te[ 8 ] = t13 * detInv;
    		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
    		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
    		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

    		te[ 12 ] = t14 * detInv;
    		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
    		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
    		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

    		return this;

    	},

    	scale: function ( v ) {

    		var te = this.elements;
    		var x = v.x, y = v.y, z = v.z;

    		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    		return this;

    	},

    	getMaxScaleOnAxis: function () {

    		var te = this.elements;

    		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

    	},

    	makeTranslation: function ( x, y, z ) {

    		this.set(

    			1, 0, 0, x,
    			0, 1, 0, y,
    			0, 0, 1, z,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationX: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			1, 0, 0, 0,
    			0, c, - s, 0,
    			0, s, c, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationY: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			 c, 0, s, 0,
    			 0, 1, 0, 0,
    			- s, 0, c, 0,
    			 0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationZ: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			c, - s, 0, 0,
    			s, c, 0, 0,
    			0, 0, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationAxis: function ( axis, angle ) {

    		// Based on http://www.gamedev.net/reference/articles/article1199.asp

    		var c = Math.cos( angle );
    		var s = Math.sin( angle );
    		var t = 1 - c;
    		var x = axis.x, y = axis.y, z = axis.z;
    		var tx = t * x, ty = t * y;

    		this.set(

    			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
    			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
    			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
    			0, 0, 0, 1

    		);

    		 return this;

    	},

    	makeScale: function ( x, y, z ) {

    		this.set(

    			x, 0, 0, 0,
    			0, y, 0, 0,
    			0, 0, z, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	makeShear: function ( x, y, z ) {

    		this.set(

    			1, y, z, 0,
    			x, 1, z, 0,
    			x, y, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	compose: function ( position, quaternion, scale ) {

    		var te = this.elements;

    		var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    		var x2 = x + x,	y2 = y + y, z2 = z + z;
    		var xx = x * x2, xy = x * y2, xz = x * z2;
    		var yy = y * y2, yz = y * z2, zz = z * z2;
    		var wx = w * x2, wy = w * y2, wz = w * z2;

    		var sx = scale.x, sy = scale.y, sz = scale.z;

    	        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
    	        te[ 1 ] = ( xy + wz ) * sx;
    	        te[ 2 ] = ( xz - wy ) * sx;
    	        te[ 3 ] = 0;

    	        te[ 4 ] = ( xy - wz ) * sy;
    	        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
    	        te[ 6 ] = ( yz + wx ) * sy;
    	        te[ 7 ] = 0;

    	        te[ 8 ] = ( xz + wy ) * sz;
    	        te[ 9 ] = ( yz - wx ) * sz;
    	        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
    	        te[ 11 ] = 0;

    	        te[ 12 ] = position.x;
    	        te[ 13 ] = position.y;
    	        te[ 14 ] = position.z;
    	        te[ 15 ] = 1;

    	        return this;

    	},

    	decompose: function () {

    		var vector = new Vector3();
    		var matrix = new Matrix4();

    		return function decompose( position, quaternion, scale ) {

    			var te = this.elements;

    			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
    			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
    			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

    			// if determine is negative, we need to invert one scale
    			var det = this.determinant();
    			if ( det < 0 ) sx = - sx;

    			position.x = te[ 12 ];
    			position.y = te[ 13 ];
    			position.z = te[ 14 ];

    			// scale the rotation part
    			matrix.copy( this );

    			var invSX = 1 / sx;
    			var invSY = 1 / sy;
    			var invSZ = 1 / sz;

    			matrix.elements[ 0 ] *= invSX;
    			matrix.elements[ 1 ] *= invSX;
    			matrix.elements[ 2 ] *= invSX;

    			matrix.elements[ 4 ] *= invSY;
    			matrix.elements[ 5 ] *= invSY;
    			matrix.elements[ 6 ] *= invSY;

    			matrix.elements[ 8 ] *= invSZ;
    			matrix.elements[ 9 ] *= invSZ;
    			matrix.elements[ 10 ] *= invSZ;

    			quaternion.setFromRotationMatrix( matrix );

    			scale.x = sx;
    			scale.y = sy;
    			scale.z = sz;

    			return this;

    		};

    	}(),

    	makePerspective: function ( left, right, top, bottom, near, far ) {

    		if ( far === undefined ) {

    			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

    		}

    		var te = this.elements;
    		var x = 2 * near / ( right - left );
    		var y = 2 * near / ( top - bottom );

    		var a = ( right + left ) / ( right - left );
    		var b = ( top + bottom ) / ( top - bottom );
    		var c = - ( far + near ) / ( far - near );
    		var d = - 2 * far * near / ( far - near );

    		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
    		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

    		return this;

    	},

    	makeOrthographic: function ( left, right, top, bottom, near, far ) {

    		var te = this.elements;
    		var w = 1.0 / ( right - left );
    		var h = 1.0 / ( top - bottom );
    		var p = 1.0 / ( far - near );

    		var x = ( right + left ) * w;
    		var y = ( top + bottom ) * h;
    		var z = ( far + near ) * p;

    		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
    		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

    		return this;

    	},

    	equals: function ( matrix ) {

    		var te = this.elements;
    		var me = matrix.elements;

    		for ( var i = 0; i < 16; i ++ ) {

    			if ( te[ i ] !== me[ i ] ) return false;

    		}

    		return true;

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		for ( var i = 0; i < 16; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		var te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];
    		array[ offset + 3 ] = te[ 3 ];

    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];
    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];

    		array[ offset + 8 ] = te[ 8 ];
    		array[ offset + 9 ] = te[ 9 ];
    		array[ offset + 10 ] = te[ 10 ];
    		array[ offset + 11 ] = te[ 11 ];

    		array[ offset + 12 ] = te[ 12 ];
    		array[ offset + 13 ] = te[ 13 ];
    		array[ offset + 14 ] = te[ 14 ];
    		array[ offset + 15 ] = te[ 15 ];

    		return array;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author kile / http://kile.stravaganza.org/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector3( x, y, z ) {

    	this.x = x || 0;
    	this.y = y || 0;
    	this.z = z || 0;

    }

    Object.assign( Vector3.prototype, {

    	isVector3: true,

    	set: function ( x, y, z ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setZ: function ( z ) {

    		this.z = z;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    		return this;

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y, this.z );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;

    		return this;

    	},

    	multiply: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
    			return this.multiplyVectors( v, w );

    		}

    		this.x *= v.x;
    		this.y *= v.y;
    		this.z *= v.z;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		this.x *= scalar;
    		this.y *= scalar;
    		this.z *= scalar;

    		return this;

    	},

    	multiplyVectors: function ( a, b ) {

    		this.x = a.x * b.x;
    		this.y = a.y * b.y;
    		this.z = a.z * b.z;

    		return this;

    	},

    	applyEuler: function () {

    		var quaternion = new Quaternion();

    		return function applyEuler( euler ) {

    			if ( ! ( euler && euler.isEuler ) ) {

    				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

    			}

    			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

    		};

    	}(),

    	applyAxisAngle: function () {

    		var quaternion = new Quaternion();

    		return function applyAxisAngle( axis, angle ) {

    			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

    		};

    	}(),

    	applyMatrix3: function ( m ) {

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    		return this;

    	},

    	applyMatrix4: function ( m ) {

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

    		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
    		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
    		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

    		return this;

    	},

    	applyQuaternion: function ( q ) {

    		var x = this.x, y = this.y, z = this.z;
    		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

    		// calculate quat * vector

    		var ix = qw * x + qy * z - qz * y;
    		var iy = qw * y + qz * x - qx * z;
    		var iz = qw * z + qx * y - qy * x;
    		var iw = - qx * x - qy * y - qz * z;

    		// calculate result * inverse quat

    		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    		return this;

    	},

    	project: function ( camera ) {

    		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

    	},

    	unproject: function () {

    		var matrix = new Matrix4();

    		return function unproject( camera ) {

    			return this.applyMatrix4( matrix.getInverse( camera.projectionMatrix ) ).applyMatrix4( camera.matrixWorld );

    		};

    	}(),

    	transformDirection: function ( m ) {

    		// input: THREE.Matrix4 affine matrix
    		// vector interpreted as a direction

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    		return this.normalize();

    	},

    	divide: function ( v ) {

    		this.x /= v.x;
    		this.y /= v.y;
    		this.z /= v.z;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// assumes min < max, componentwise

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min = new Vector3();
    		var max = new Vector3();

    		return function clampScalar( minVal, maxVal ) {

    			min.set( minVal, minVal, minVal );
    			max.set( maxVal, maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	clampLength: function ( min, max ) {

    		var length = this.length();

    		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

    	},

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z;

    	},

    	// TODO lengthSquared?

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y + this.z * this.z;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    	},

    	manhattanLength: function () {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() || 1 );

    	},

    	setLength: function ( length ) {

    		return this.normalize().multiplyScalar( length );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	cross: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
    			return this.crossVectors( v, w );

    		}

    		return this.crossVectors( this, v );

    	},

    	crossVectors: function ( a, b ) {

    		var ax = a.x, ay = a.y, az = a.z;
    		var bx = b.x, by = b.y, bz = b.z;

    		this.x = ay * bz - az * by;
    		this.y = az * bx - ax * bz;
    		this.z = ax * by - ay * bx;

    		return this;

    	},

    	projectOnVector: function ( vector ) {

    		var scalar = vector.dot( this ) / vector.lengthSq();

    		return this.copy( vector ).multiplyScalar( scalar );

    	},

    	projectOnPlane: function () {

    		var v1 = new Vector3();

    		return function projectOnPlane( planeNormal ) {

    			v1.copy( this ).projectOnVector( planeNormal );

    			return this.sub( v1 );

    		};

    	}(),

    	reflect: function () {

    		// reflect incident vector off plane orthogonal to normal
    		// normal is assumed to have unit length

    		var v1 = new Vector3();

    		return function reflect( normal ) {

    			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    		};

    	}(),

    	angleTo: function ( v ) {

    		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

    		// clamp, to handle numerical problems

    		return Math.acos( _Math.clamp( theta, - 1, 1 ) );

    	},

    	distanceTo: function ( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	},

    	distanceToSquared: function ( v ) {

    		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

    		return dx * dx + dy * dy + dz * dz;

    	},

    	manhattanDistanceTo: function ( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

    	},

    	setFromSpherical: function ( s ) {

    		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

    	},

    	setFromSphericalCoords: function ( radius, phi, theta ) {

    		var sinPhiRadius = Math.sin( phi ) * radius;

    		this.x = sinPhiRadius * Math.sin( theta );
    		this.y = Math.cos( phi ) * radius;
    		this.z = sinPhiRadius * Math.cos( theta );

    		return this;

    	},

    	setFromCylindrical: function ( c ) {

    		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

    	},

    	setFromCylindricalCoords: function ( radius, theta, y ) {

    		this.x = radius * Math.sin( theta );
    		this.y = y;
    		this.z = radius * Math.cos( theta );

    		return this;

    	},

    	setFromMatrixPosition: function ( m ) {

    		var e = m.elements;

    		this.x = e[ 12 ];
    		this.y = e[ 13 ];
    		this.z = e[ 14 ];

    		return this;

    	},

    	setFromMatrixScale: function ( m ) {

    		var sx = this.setFromMatrixColumn( m, 0 ).length();
    		var sy = this.setFromMatrixColumn( m, 1 ).length();
    		var sz = this.setFromMatrixColumn( m, 2 ).length();

    		this.x = sx;
    		this.y = sy;
    		this.z = sz;

    		return this;

    	},

    	setFromMatrixColumn: function ( m, index ) {

    		return this.fromArray( m.elements, index * 4 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;

    		return array;

    	},

    	fromBufferAttribute: function ( attribute, index, offset ) {

    		if ( offset !== undefined ) {

    			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

    		}

    		this.x = attribute.getX( index );
    		this.y = attribute.getY( index );
    		this.z = attribute.getZ( index );

    		return this;

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Quaternion( x, y, z, w ) {

    	this._x = x || 0;
    	this._y = y || 0;
    	this._z = z || 0;
    	this._w = ( w !== undefined ) ? w : 1;

    }

    Object.assign( Quaternion, {

    	slerp: function ( qa, qb, qm, t ) {

    		return qm.copy( qa ).slerp( qb, t );

    	},

    	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

    		// fuzz-free, array-based Quaternion SLERP operation

    		var x0 = src0[ srcOffset0 + 0 ],
    			y0 = src0[ srcOffset0 + 1 ],
    			z0 = src0[ srcOffset0 + 2 ],
    			w0 = src0[ srcOffset0 + 3 ],

    			x1 = src1[ srcOffset1 + 0 ],
    			y1 = src1[ srcOffset1 + 1 ],
    			z1 = src1[ srcOffset1 + 2 ],
    			w1 = src1[ srcOffset1 + 3 ];

    		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

    			var s = 1 - t,

    				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

    				dir = ( cos >= 0 ? 1 : - 1 ),
    				sqrSin = 1 - cos * cos;

    			// Skip the Slerp for tiny steps to avoid numeric problems:
    			if ( sqrSin > Number.EPSILON ) {

    				var sin = Math.sqrt( sqrSin ),
    					len = Math.atan2( sin, cos * dir );

    				s = Math.sin( s * len ) / sin;
    				t = Math.sin( t * len ) / sin;

    			}

    			var tDir = t * dir;

    			x0 = x0 * s + x1 * tDir;
    			y0 = y0 * s + y1 * tDir;
    			z0 = z0 * s + z1 * tDir;
    			w0 = w0 * s + w1 * tDir;

    			// Normalize in case we just did a lerp:
    			if ( s === 1 - t ) {

    				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

    				x0 *= f;
    				y0 *= f;
    				z0 *= f;
    				w0 *= f;

    			}

    		}

    		dst[ dstOffset ] = x0;
    		dst[ dstOffset + 1 ] = y0;
    		dst[ dstOffset + 2 ] = z0;
    		dst[ dstOffset + 3 ] = w0;

    	}

    } );

    Object.defineProperties( Quaternion.prototype, {

    	x: {

    		get: function () {

    			return this._x;

    		},

    		set: function ( value ) {

    			this._x = value;
    			this.onChangeCallback();

    		}

    	},

    	y: {

    		get: function () {

    			return this._y;

    		},

    		set: function ( value ) {

    			this._y = value;
    			this.onChangeCallback();

    		}

    	},

    	z: {

    		get: function () {

    			return this._z;

    		},

    		set: function ( value ) {

    			this._z = value;
    			this.onChangeCallback();

    		}

    	},

    	w: {

    		get: function () {

    			return this._w;

    		},

    		set: function ( value ) {

    			this._w = value;
    			this.onChangeCallback();

    		}

    	}

    } );

    Object.assign( Quaternion.prototype, {

    	isQuaternion: true,

    	set: function ( x, y, z, w ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._w = w;

    		this.onChangeCallback();

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this._x, this._y, this._z, this._w );

    	},

    	copy: function ( quaternion ) {

    		this._x = quaternion.x;
    		this._y = quaternion.y;
    		this._z = quaternion.z;
    		this._w = quaternion.w;

    		this.onChangeCallback();

    		return this;

    	},

    	setFromEuler: function ( euler, update ) {

    		if ( ! ( euler && euler.isEuler ) ) {

    			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

    		}

    		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

    		// http://www.mathworks.com/matlabcentral/fileexchange/
    		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    		//	content/SpinCalc.m

    		var cos = Math.cos;
    		var sin = Math.sin;

    		var c1 = cos( x / 2 );
    		var c2 = cos( y / 2 );
    		var c3 = cos( z / 2 );

    		var s1 = sin( x / 2 );
    		var s2 = sin( y / 2 );
    		var s3 = sin( z / 2 );

    		if ( order === 'XYZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'YXZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'ZXY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'ZYX' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'YZX' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'XZY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		}

    		if ( update !== false ) this.onChangeCallback();

    		return this;

    	},

    	setFromAxisAngle: function ( axis, angle ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    		// assumes axis is normalized

    		var halfAngle = angle / 2, s = Math.sin( halfAngle );

    		this._x = axis.x * s;
    		this._y = axis.y * s;
    		this._z = axis.z * s;
    		this._w = Math.cos( halfAngle );

    		this.onChangeCallback();

    		return this;

    	},

    	setFromRotationMatrix: function ( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

    			trace = m11 + m22 + m33,
    			s;

    		if ( trace > 0 ) {

    			s = 0.5 / Math.sqrt( trace + 1.0 );

    			this._w = 0.25 / s;
    			this._x = ( m32 - m23 ) * s;
    			this._y = ( m13 - m31 ) * s;
    			this._z = ( m21 - m12 ) * s;

    		} else if ( m11 > m22 && m11 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

    			this._w = ( m32 - m23 ) / s;
    			this._x = 0.25 * s;
    			this._y = ( m12 + m21 ) / s;
    			this._z = ( m13 + m31 ) / s;

    		} else if ( m22 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

    			this._w = ( m13 - m31 ) / s;
    			this._x = ( m12 + m21 ) / s;
    			this._y = 0.25 * s;
    			this._z = ( m23 + m32 ) / s;

    		} else {

    			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

    			this._w = ( m21 - m12 ) / s;
    			this._x = ( m13 + m31 ) / s;
    			this._y = ( m23 + m32 ) / s;
    			this._z = 0.25 * s;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	setFromUnitVectors: function () {

    		// assumes direction vectors vFrom and vTo are normalized

    		var v1 = new Vector3();
    		var r;

    		var EPS = 0.000001;

    		return function setFromUnitVectors( vFrom, vTo ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			r = vFrom.dot( vTo ) + 1;

    			if ( r < EPS ) {

    				r = 0;

    				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

    					v1.set( - vFrom.y, vFrom.x, 0 );

    				} else {

    					v1.set( 0, - vFrom.z, vFrom.y );

    				}

    			} else {

    				v1.crossVectors( vFrom, vTo );

    			}

    			this._x = v1.x;
    			this._y = v1.y;
    			this._z = v1.z;
    			this._w = r;

    			return this.normalize();

    		};

    	}(),

    	angleTo: function ( q ) {

    		return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );

    	},

    	rotateTowards: function ( q, step ) {

    		var angle = this.angleTo( q );

    		if ( angle === 0 ) return this;

    		var t = Math.min( 1, step / angle );

    		this.slerp( q, t );

    		return this;

    	},

    	inverse: function () {

    		// quaternion is assumed to have unit length

    		return this.conjugate();

    	},

    	conjugate: function () {

    		this._x *= - 1;
    		this._y *= - 1;
    		this._z *= - 1;

    		this.onChangeCallback();

    		return this;

    	},

    	dot: function ( v ) {

    		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    	},

    	lengthSq: function () {

    		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    	},

    	length: function () {

    		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    	},

    	normalize: function () {

    		var l = this.length();

    		if ( l === 0 ) {

    			this._x = 0;
    			this._y = 0;
    			this._z = 0;
    			this._w = 1;

    		} else {

    			l = 1 / l;

    			this._x = this._x * l;
    			this._y = this._y * l;
    			this._z = this._z * l;
    			this._w = this._w * l;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	multiply: function ( q, p ) {

    		if ( p !== undefined ) {

    			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
    			return this.multiplyQuaternions( q, p );

    		}

    		return this.multiplyQuaternions( this, q );

    	},

    	premultiply: function ( q ) {

    		return this.multiplyQuaternions( q, this );

    	},

    	multiplyQuaternions: function ( a, b ) {

    		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    		this.onChangeCallback();

    		return this;

    	},

    	slerp: function ( qb, t ) {

    		if ( t === 0 ) return this;
    		if ( t === 1 ) return this.copy( qb );

    		var x = this._x, y = this._y, z = this._z, w = this._w;

    		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    		if ( cosHalfTheta < 0 ) {

    			this._w = - qb._w;
    			this._x = - qb._x;
    			this._y = - qb._y;
    			this._z = - qb._z;

    			cosHalfTheta = - cosHalfTheta;

    		} else {

    			this.copy( qb );

    		}

    		if ( cosHalfTheta >= 1.0 ) {

    			this._w = w;
    			this._x = x;
    			this._y = y;
    			this._z = z;

    			return this;

    		}

    		var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    		if ( sqrSinHalfTheta <= Number.EPSILON ) {

    			var s = 1 - t;
    			this._w = s * w + t * this._w;
    			this._x = s * x + t * this._x;
    			this._y = s * y + t * this._y;
    			this._z = s * z + t * this._z;

    			return this.normalize();

    		}

    		var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
    		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
    		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    		this._w = ( w * ratioA + this._w * ratioB );
    		this._x = ( x * ratioA + this._x * ratioB );
    		this._y = ( y * ratioA + this._y * ratioB );
    		this._z = ( z * ratioA + this._z * ratioB );

    		this.onChangeCallback();

    		return this;

    	},

    	equals: function ( quaternion ) {

    		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this._x = array[ offset ];
    		this._y = array[ offset + 1 ];
    		this._z = array[ offset + 2 ];
    		this._w = array[ offset + 3 ];

    		this.onChangeCallback();

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._w;

    		return array;

    	},

    	onChange: function ( callback ) {

    		this.onChangeCallback = callback;

    		return this;

    	},

    	onChangeCallback: function () {}

    } );

    var OrthoShadowCamera = (function (_super) {
        __extends$1(OrthoShadowCamera, _super);
        function OrthoShadowCamera(width, height, options) {
            if (options === void 0) { options = {}; }
            return _super.call(this, width, height, options) || this;
        }
        OrthoShadowCamera.prototype.Destroy = function () {
        };
        OrthoShadowCamera.prototype.Init = function (pos, dir, up, width, height) {
            this.m_pos = pos;
            this.m_dir = dir;
            this.m_up = up;
            this.m_width = width;
            this.m_height = height;
            this._calcProjectionMatrix();
            this._calcViewMatrix();
        };
        OrthoShadowCamera.prototype._calcProjectionMatrix = function () {
            this._projectionMatrix.setOrtho(-this._width * 0.5, this._width * 0.5, -this._height * 0.5, this._height * 0.5, this._near, this._far);
        };
        OrthoShadowCamera.prototype._calcViewMatrix = function () {
            var focalLength = Math.pow(2, (this._NATIVE_ZOOM - this._zoom));
            focalLength = 20000.0;
            if (focalLength > this._far) {
                this._far = focalLength + 100;
                this._calcProjectionMatrix();
            }
            if (this.m_up == null || this.m_up == undefined
                || this.m_pos == null || this.m_pos == undefined) {
                return;
            }
            this.m_pos.GetRotate();
            this.m_pos.GetPitch();
            this.m_pos.getLength();
            var v1 = new Vector3(0, 1, 0);
            var v2 = new Vector3(-this.m_pos.x, -this.m_pos.y, -this.m_pos.z);
            v2.normalize();
            var cameraDir = new Vector3(-this.m_pos.x, -this.m_pos.y, -this.m_pos.z);
            cameraDir.normalize();
            var up = new Vector3(0, 0, 1);
            var cameraRight = up.cross(cameraDir);
            var cameraUp = cameraDir.cross(cameraRight);
            var q = new Quaternion();
            q.setFromUnitVectors(v1, v2);
            var upDir = new Vector3(0, 0, 1);
            var rotateMatrix = new Matrix4();
            rotateMatrix.makeRotationFromQuaternion(q);
            upDir.applyMatrix4(rotateMatrix);
            upDir.z = Math.abs(upDir.z);
            var viewDir = new Vector3(-this.m_pos.x, -this.m_pos.y, -this.m_pos.z);
            viewDir.normalize();
            rotateMatrix.lookAt(new Vector3(this.m_pos.x, this.m_pos.y, this.m_pos.z), new Vector3(0, 0, 0), cameraUp);
            this._eye = [this.m_pos.x, this.m_pos.y, this.m_pos.z];
            this._target = [0, 0, 0];
            this._up = [cameraUp.x, cameraUp.y, cameraUp.z];
            this._viewMatrix.setLookAt(this._eye, this._target, this._up);
            upDir.applyMatrix4(rotateMatrix);
        };
        return OrthoShadowCamera;
    }(ShadowCamera));

    var OrthoShadowLight = (function (_super) {
        __extends$1(OrthoShadowLight, _super);
        function OrthoShadowLight(pos, dir, up, width, height) {
            var _this = _super.call(this, pos, dir, up, width, height) || this;
            _this.m_pos = pos;
            _this.m_dir = dir;
            _this.m_up = up;
            _this.m_viewWidth = width;
            _this.m_viewHeight = height;
            _this.m_bDirty = true;
            return _this;
        }
        OrthoShadowLight.prototype.Destroy = function () {
            _super.prototype.Destroy.call(this);
        };
        OrthoShadowLight.prototype.Init = function () {
            var engine = ShadowMgr$1.GetInstance().GetEngine();
            this.m_shadowTexture = new ShadowTexture();
            this.m_shadowTexture.Init(engine, 0, 0);
            this.m_shadowCamera = new OrthoShadowCamera(this.m_viewWidth, this.m_viewHeight);
            this.m_shadowCamera.Init(this.m_pos, this.m_dir, this.m_up, this.m_viewWidth, this.m_viewHeight);
        };
        OrthoShadowLight.prototype.SetViewSize = function (width, height) {
            this.m_viewWidth = width;
            this.m_viewHeight = height;
            this.m_bDirty = true;
        };
        return OrthoShadowLight;
    }(ShadowLight));

    var ShadowMgr = (function () {
        function ShadowMgr() {
            this.m_mapView = null;
            this.m_shadowTextureArray = [];
            this.m_shadowLightArray = [];
            this.m_engine = null;
        }
        ShadowMgr.GetInstance = function () {
            if (ShadowMgr.m_instance === null) {
                ShadowMgr.m_instance = new ShadowMgr();
            }
            return ShadowMgr.m_instance;
        };
        ShadowMgr.prototype.SetMapView = function (mapView) {
            this.m_mapView = mapView;
        };
        ShadowMgr.prototype.IsShadowUpdated = function () {
            for (var i = 0; i < this.m_shadowTextureArray.length; i++) {
                var shadowTexture = this.m_shadowTextureArray[i];
                if (shadowTexture && shadowTexture.IsDirty()) {
                    return true;
                }
            }
            return false;
        };
        ShadowMgr.prototype.Init = function (engine) {
            this.m_engine = engine;
            if (this.m_engine == null || this.m_engine == undefined) {
                return false;
            }
            var gl = this.m_engine.getGl();
            if (gl == null || gl == undefined) {
                return false;
            }
            return true;
        };
        ShadowMgr.prototype.AddShadowLight = function (pos, dir, up, width, height) {
            var orthoShadowLight = new OrthoShadowLight(pos, dir, up, width, height);
            orthoShadowLight.Init();
            this.m_shadowLightArray.push(orthoShadowLight);
        };
        ShadowMgr.prototype.RemoveShadowLight = function (index) {
            if (index < 0 && index >= this.m_shadowLightArray.length) {
                return;
            }
            var shadowLight = this.m_shadowLightArray[index];
            shadowLight.Destroy();
            this.m_shadowLightArray.splice(index, 1);
        };
        ShadowMgr.prototype.RemoveAllShadowLight = function () {
            for (var i = 0; i < this.m_shadowLightArray.length; i++) {
                var shadowLight = this.m_shadowLightArray[i];
                shadowLight.Destroy();
            }
            this.m_shadowLightArray = [];
        };
        ShadowMgr.prototype.GetShadowLightByIndex = function (index) {
            if (index < 0 || index >= this.m_shadowLightArray.length) {
                return null;
            }
            return this.m_shadowLightArray[index];
        };
        ShadowMgr.prototype.GetShadowLightCount = function () {
            return this.m_shadowLightArray.length;
        };
        ShadowMgr.prototype.Render = function () {
            for (var i = 0; i < this.m_shadowLightArray.length; i++) {
                var shadowLight = this.m_shadowLightArray[i];
                if (shadowLight == null || shadowLight == undefined) {
                    continue;
                }
                if (shadowLight.IsDirty() == false) {
                    continue;
                }
                else {
                    shadowLight.Render();
                }
            }
        };
        ShadowMgr.prototype.SetEngine = function (engine) {
            this.m_engine = engine;
        };
        ShadowMgr.prototype.GetEngine = function () {
            return this.m_engine;
        };
        ShadowMgr.prototype.ForceUpdate = function () {
            for (var i = 0; i < this.m_shadowLightArray.length; i++) {
                var shadowLight = this.m_shadowLightArray[i];
                shadowLight.ForceUpdate();
            }
        };
        ShadowMgr.m_instance = null;
        return ShadowMgr;
    }());
    var ShadowMgr$1 = ShadowMgr;

    var ExtraInfo = (function () {
        function ExtraInfo() {
            this.m_featureId = '';
            this.m_opacity = 1.0;
            this.m_zScale = 1.0;
            this.m_alpha = 1.0;
            this.m_bInAnim = false;
            this.m_animTimePassed = 0.0;
            this.m_animTime = 0.0;
            this.m_alphaAnimTimePassed = 0.0;
            this.m_alphaAnimTime = 0.2;
        }
        return ExtraInfo;
    }());
    var ExtraMgr = (function () {
        function ExtraMgr() {
            this.m_extraTable = [];
            this.m_bAnim = false;
            this.m_startZ = 1.0;
            this.m_endZ = 1.0;
            this.m_exceptFeatureId = '';
            this.m_animTime = 1.0;
            this.m_animTimePassed = 0.0;
            this.m_extraZ = 0.0;
            this.m_animStartTime = 0.0;
        }
        ExtraMgr.GetInstance = function () {
            if (ExtraMgr.m_instance == null) {
                ExtraMgr.m_instance = new ExtraMgr();
            }
            return ExtraMgr.m_instance;
        };
        ExtraMgr.prototype.AddExtraInfo = function (featureId, opacity) {
            var bFind = false;
            for (var i = 0; i < this.m_extraTable.length; i++) {
                if (this.m_extraTable[i].m_featureId == featureId) {
                    this.m_extraTable[i].m_opacity = opacity;
                    bFind = true;
                    break;
                }
            }
            if (bFind == false) {
                var extra = new ExtraInfo();
                extra.m_featureId = featureId;
                extra.m_opacity = opacity;
                extra.m_zScale = 1.0;
                this.m_extraTable.push(extra);
            }
        };
        ExtraMgr.prototype.GetCoveredExtra = function () {
            var result = [];
            for (var i = 0; i < this.m_extraTable.length; i++) {
                if (this.m_extraTable[i].m_opacity < 1) {
                    result.push(this.m_extraTable[i].m_featureId);
                }
            }
            return result;
        };
        ExtraMgr.prototype.ResetExtraOpacity = function () {
            if (this.m_extraTable == null || this.m_extraTable == undefined) {
                return;
            }
            for (var i = 0; i < this.m_extraTable.length; i++) {
                this.m_extraTable[i].m_opacity = 1.0;
            }
        };
        ExtraMgr.prototype.GetExtraOpacity = function (featureId) {
            for (var i = 0; i < this.m_extraTable.length; i++) {
                if (this.m_extraTable[i].m_featureId == featureId) {
                    return this.m_extraTable[i].m_alpha;
                }
            }
            return 1.0;
        };
        ExtraMgr.prototype.GetExtraAnimZ = function (featureId) {
            if (featureId == null || featureId == undefined || featureId == '') {
                return 1.0;
            }
            if (this.m_extraTable == null || this.m_extraTable == undefined || this.m_extraTable.length == 0) {
                return 1.0;
            }
            for (var i = 0; i < this.m_extraTable.length; i++) {
                if (this.m_extraTable[i].m_featureId == featureId) {
                    return this.m_extraTable[i].m_zScale;
                }
            }
            return 1.0;
        };
        ExtraMgr.prototype.IsExtra = function (featureId) {
            if (featureId == null || featureId == undefined || featureId == '') {
                return false;
            }
            if (this.m_extraTable == null || this.m_extraTable == undefined) {
                return false;
            }
            for (var i = 0; i < this.m_extraTable.length; i++) {
                if (this.m_extraTable[i].m_featureId == featureId) {
                    return true;
                }
            }
            return false;
        };
        ExtraMgr.prototype.TickExtraAnim = function (dt) {
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined || mapView.getExtraPerspective() == false) {
                return;
            }
            var animTime = 0.2;
            if (this.m_extraTable == null || this.m_extraTable == undefined || this.m_extraTable.length == 0) {
                return;
            }
            var bHasExtraPerspective = this.HasExtraPerspective();
            if (bHasExtraPerspective) {
                for (var i = 0; i < this.m_extraTable.length; i++) {
                    var extraInfo = this.m_extraTable[i];
                    if (extraInfo == null || extraInfo == undefined) {
                        continue;
                    }
                    if (extraInfo.m_opacity == 1.0) {
                        extraInfo.m_zScale -= dt / animTime * (1.0 - 0.3);
                        extraInfo.m_zScale = Math.max(0.3, extraInfo.m_zScale);
                        extraInfo.m_alpha += dt / animTime;
                        extraInfo.m_alpha = Math.min(1.0, extraInfo.m_alpha);
                    }
                    else if (extraInfo.m_opacity == 0.0) {
                        extraInfo.m_zScale = 0.3;
                        extraInfo.m_alpha -= dt / animTime;
                        extraInfo.m_alpha = Math.max(0, extraInfo.m_alpha);
                    }
                }
            }
            else {
                for (var i = 0; i < this.m_extraTable.length; i++) {
                    var extraInfo = this.m_extraTable[i];
                    if (extraInfo == null || extraInfo == undefined) {
                        continue;
                    }
                    extraInfo.m_zScale += dt / animTime * (1.0 - 0.3);
                    extraInfo.m_zScale = Math.min(1.0, extraInfo.m_zScale);
                    extraInfo.m_alpha += dt / animTime;
                    extraInfo.m_alpha = Math.min(1.0, extraInfo.m_alpha);
                }
            }
        };
        ExtraMgr.prototype.Tick = function (dt) {
            this.TickExtraAnim(dt);
        };
        ExtraMgr.prototype.HasExtraPerspective = function () {
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined) {
                return;
            }
            var camera = mapView.getCamera();
            if (camera == null || camera == undefined) {
                return;
            }
            var zoom = camera.getZoom();
            var extraPrespectiveStartZoom = mapView.getExtraPrespectiveStartZoom();
            if (zoom >= extraPrespectiveStartZoom) {
                return true;
            }
            else {
                return false;
            }
        };
        ExtraMgr.prototype.StartZScaleAnim = function (startZ, endZ, animTime, exceptFeatureId) {
            this.m_bAnim = true;
            this.m_startZ = startZ;
            this.m_endZ = endZ;
            this.m_animTime = animTime;
            this.m_exceptFeatureId = exceptFeatureId;
            this.m_animTimePassed = 0;
            this.m_extraZ = this.m_startZ;
            this.m_animStartTime = Date.now();
        };
        ExtraMgr.m_instance = null;
        return ExtraMgr;
    }());

    var Engine = (function (_super) {
        __extends$1(Engine, _super);
        function Engine(container, options) {
            var _this = _super.call(this) || this;
            _this._layers = new ArraySet();
            _this._tileLayers = new ArraySet();
            _this._lightPos = [1, -1, 1];
            _this._ambientColor = [0.8, 0.8, 0.8];
            _this._ambientMaterial = [1, 1, 1];
            _this._diffuseColor = [0.1, 0.1, 0.1];
            _this._diffuseMaterial = [1, 1, 1];
            _this._bucketMng = new BucketManager();
            _this.m_curTime = 0;
            _this.m_lastUpdateTime = 0;
            _this.m_bLastFindExtra = false;
            _this._renderQueue = [];
            _this.m_lastRenderStartTime = 0;
            _this.m_renderMode = 'continious';
            _this.m_renderDelayTime = 20.0;
            _this.m_renderTimer = null;
            bindAll([
                '_frameRender',
                '_onCollisionChange',
            ], _this);
            _this._container = container;
            _this._rect = _this._container.getBoundingClientRect();
            var _a = EngineUtils.getContainerRange(_this._rect), width = _a.width, height = _a.height;
            _this._canvas = EngineUtils.createCanvas(width, height, devicePixelRatio);
            _this._container.appendChild(_this._canvas);
            _this._mapView = MapView$1.GetInstance();
            _this._setupLight(options);
            _this._gl = EngineUtils.getWebglRender(_this._canvas, {
                antialias: true,
                depth: true,
                premultipliedAlpha: true,
                preserveDrawingBuffer: false,
                alpha: true,
                failIfMajorPerformanceCaveat: false,
            });
            _this._gl.viewport(0, 0, width * devicePixelRatio, height * devicePixelRatio);
            _this._camera = new Camera(width, height, {
                zoom: options.zoom,
                rotate: options.rotate,
                pitch: options.pitch,
            });
            _this._collisionMng = new CollisionManager(_this._camera, {
                viewWidth: width,
                viewHeight: height,
                animateDuration: 300,
                collisionDuration: 600,
            });
            _this._collisionMng.on('change', _this._onCollisionChange);
            _this._textureMng = new TextureManager(_this._gl);
            _this._glyphMng = new GlyphManager(_this._gl, {
                fontWeight: options.fontWeight,
                fontFamily: options.localFontFamily,
                buffer: 3,
                textMaxWidth: options.maxTextSize,
                textSplit: options.textSplit,
            });
            _this._glContext = new GLContext(_this._gl, {
                width: width * devicePixelRatio,
                height: height * devicePixelRatio,
            });
            return _this;
        }
        Engine.prototype.getMapView = function () {
            return this._mapView;
        };
        Engine.prototype.getBucketMng = function () {
            return this._bucketMng;
        };
        Engine.prototype.getCollisionMng = function () {
            return this._collisionMng;
        };
        Engine.prototype._onCollisionChange = function (data) {
            data.isForce && this.render();
        };
        Engine.prototype._startRenderQueue = function () {
            !this._renderTimer && this._frameRender();
        };
        Engine.prototype._frameRender = function () {
            if (this._renderQueue.length !== 0 || this._collisionMng.isNeedCollisionRender()) {
                this._renderQueue.pop();
                this.DoRender();
                this._renderTimer = requestAnimationFrame(this._frameRender);
            }
            else {
                this._stopRenderQueue();
            }
        };
        Engine.prototype.DoRender = function () {
            this.m_curTime = Date.now();
            var dt = (this.m_curTime - this.m_lastUpdateTime) / 1000.0;
            this.m_lastUpdateTime = this.m_curTime;
            ExtraMgr.GetInstance().Tick(dt);
            this._updateFrame(dt);
            this._draw();
        };
        Engine.prototype.UpdateExtraFace = function () {
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined || mapView.getExtraPerspective() == false) {
                return;
            }
            if (this._camera == null && this._camera == undefined) {
                return;
            }
            this._rect.width * 0.5;
            this._rect.height * 0.5;
            var xCenter = 0.5;
            var yCenter = 0.5;
            var offset = 0.02;
            if (this._camera.getPitch() > 30) {
                yCenter = 0.65;
            }
            var factor = [xCenter, yCenter,
                xCenter - offset, yCenter,
                xCenter + offset, yCenter,
                xCenter, yCenter - offset,
                xCenter, yCenter + offset,
                xCenter - offset, yCenter - offset,
                xCenter + offset, yCenter - offset,
                xCenter - offset, yCenter + offset,
                xCenter + offset, yCenter - offset];
            var extra = [];
            for (var i = 0; i < 9; i++) {
                var xIndex = i * 2;
                var yIndex = xIndex + 1;
                var x_1 = this._rect.width * factor[xIndex];
                var y_1 = this._rect.height * factor[yIndex];
                var tempExtra = mapView.queryExtraByPoint(x_1, y_1);
                for (var j = 0; j < tempExtra.length; j++) {
                    extra.push(tempExtra[j]);
                }
            }
            var origionCoveredExtra = ExtraMgr.GetInstance().GetCoveredExtra();
            ExtraMgr.GetInstance().ResetExtraOpacity();
            var newEnteredExtraIdArray = [];
            for (var i = 0; i < extra.length; i++) {
                var featureId = '';
                if (extra[i].properties.id != null && extra[i].properties.id != undefined) {
                    featureId = extra[i].properties.id;
                }
                else if (extra[i].properties.featureid != null && extra[i].properties.featureid != undefined) {
                    featureId = extra[i].properties.featureid;
                }
                ExtraMgr.GetInstance().AddExtraInfo(featureId, 0.0);
                newEnteredExtraIdArray.push(featureId);
            }
            var leavedExtraIdArray = this.GetLeavedExtra(origionCoveredExtra, newEnteredExtraIdArray);
            var enteredExtraIdArray = this.GetNewEnteredExtraId(origionCoveredExtra, newEnteredExtraIdArray);
            if (leavedExtraIdArray.length > 0) {
                this._mapView.fire('leaveExtra', leavedExtraIdArray);
            }
            if (enteredExtraIdArray.length > 0) {
                this._mapView.fire('enterExtra', enteredExtraIdArray);
            }
            this.m_bLastFindExtra = true;
        };
        Engine.prototype.GetLeavedExtra = function (origionCoveredExtraIdArray, newEnteredExtraIdArray) {
            var result = [];
            if (origionCoveredExtraIdArray == null || origionCoveredExtraIdArray == undefined
                || newEnteredExtraIdArray == null || newEnteredExtraIdArray == undefined) {
                return result;
            }
            for (var i = 0; i < origionCoveredExtraIdArray.length; i++) {
                var bFind = false;
                var checkFeatureId = origionCoveredExtraIdArray[i];
                for (var j = 0; j < newEnteredExtraIdArray.length; j++) {
                    if (newEnteredExtraIdArray[j] == checkFeatureId) {
                        bFind = true;
                        break;
                    }
                }
                if (bFind == false) {
                    result.push(checkFeatureId);
                }
            }
            return result;
        };
        Engine.prototype.GetNewEnteredExtraId = function (origionCoveredExtraIdArray, newEnteredExtraIdArray) {
            var result = [];
            if (origionCoveredExtraIdArray == null || origionCoveredExtraIdArray == undefined
                || newEnteredExtraIdArray == null || newEnteredExtraIdArray == undefined) {
                return result;
            }
            for (var i = 0; i < newEnteredExtraIdArray.length; i++) {
                var checkFeatureId = newEnteredExtraIdArray[i];
                var bFind = false;
                for (var j = 0; j < origionCoveredExtraIdArray.length; j++) {
                    if (checkFeatureId == origionCoveredExtraIdArray[j]) {
                        bFind = true;
                        break;
                    }
                }
                if (bFind == false) {
                    result.push(checkFeatureId);
                }
            }
            return result;
        };
        Engine.prototype._updateFrame = function (dt) {
            this.UpdateExtraFace();
            if (this._mapView) {
                this._mapView.Tick(dt);
            }
        };
        Engine.prototype._stopRenderQueue = function () {
            if (this._renderTimer) {
                cancelAnimationFrame(this._renderTimer);
                delete this._renderTimer;
            }
        };
        Engine.prototype.resize = function () {
            console.log('Engine.ts resize 1');
            this._rect = this._container.getBoundingClientRect();
            var _a = this._rect, width = _a.width, height = _a.height;
            console.log('Engine.ts resize 2 width:' + width + ' height:' + height);
            if (width === 0 || height === 0)
                return;
            this._canvas.width = width * devicePixelRatio;
            this._canvas.height = height * devicePixelRatio;
            this._canvas.style.width = width + "px";
            this._canvas.style.height = height + "px";
            this._gl.viewport(0, 0, width * devicePixelRatio, height * devicePixelRatio);
            this._glContext.resize(width * devicePixelRatio, height * devicePixelRatio);
            this._camera.resize(width, height);
            this._collisionMng.resize(width, height);
            this.updateCollision();
        };
        Engine.prototype.setOffset = function (offsetX, offsetY) {
            this._camera.setOffset([offsetX, offsetY]);
        };
        Engine.prototype.getOffset = function () {
            return this._camera.getOffset();
        };
        Engine.prototype.getRect = function () {
            return this._rect;
        };
        Engine.prototype.addLayer = function (layer) {
            this._layers.set(layer);
            layer.onAdd(this);
        };
        Engine.prototype.hasLayer = function (layer) {
            return this._layers.has(layer);
        };
        Engine.prototype.removeLayer = function (layer, isDestroy) {
            if (isDestroy === void 0) { isDestroy = true; }
            if (!this._layers.has(layer))
                return;
            layer.unbind();
            this._layers.delete(layer);
            isDestroy && layer.onRemove();
        };
        Engine.prototype.addTileLayer = function (layer) {
            this._tileLayers.set(layer);
            layer.onAdd(this);
        };
        Engine.prototype.removeTileLayer = function (layer) {
            if (!this._tileLayers.has(layer))
                return;
            this._tileLayers.delete(layer);
            layer.onRemove();
        };
        Engine.prototype.updateCollision = function (isForce) {
            if (isForce === void 0) { isForce = true; }
            this._collisionMng.update(isForce);
        };
        Engine.prototype.sortLayer = function () {
            var map = new Map();
            for (var i = 0; i < this._layers.size(); i += 1) {
                var layer = this._layers.get(i);
                var groupId = layer.getGroupId();
                if (groupId) {
                    var item = map.get(groupId);
                    item ? item.push(layer) : map.set(groupId, [layer]);
                }
            }
            var newArr = [];
            map.forEach(function (item) {
                sort(item, function (a, b) { return a.getOrder() - b.getOrder(); });
                newArr.push.apply(newArr, item);
            });
            this._layers = new ArraySet(newArr);
        };
        Engine.prototype.clear = function () {
            for (var i = 0; i < this._layers.size(); i += 1) {
                this._layers.get(i).unbind();
            }
            this._layers.clear();
            this._collisionMng.clear();
        };
        Engine.prototype.reset = function () {
            this._bucketMng.clear();
            this._bucketMng.clearRegister();
            this._collisionMng.clear();
            this._collisionMng.clearRegister();
            this._layers.clear();
            this.clearRegister();
        };
        Engine.prototype.render = function () {
            if (this.m_renderMode == 'continious') {
                var thisEngine_1 = this;
                if (this.m_renderTimer == null || this.m_renderTimer == undefined) {
                    this.m_renderTimer = setInterval(function () {
                        thisEngine_1.DoRender();
                    }, 1000 / 30);
                    this.DoRender();
                }
            }
            else if (this.m_renderMode == 'oneTime') {
                if (this._renderQueue.length !== 0)
                    return;
                this._renderQueue.push('render');
                this._startRenderQueue();
            }
            else if (this.m_renderMode == 'delay') {
                this.m_lastRenderStartTime = Date.now();
                var thisEngine_2 = this;
                if (this.m_renderTimer == null || this.m_renderTimer == undefined) {
                    this.m_renderTimer = setInterval(function () {
                        var curTime = Date.now();
                        if ((curTime - thisEngine_2.m_lastRenderStartTime) / 1000.0 > thisEngine_2.m_renderDelayTime) {
                            clearInterval(thisEngine_2.m_renderTimer);
                            thisEngine_2.m_renderTimer = null;
                        }
                        else {
                            thisEngine_2.DoRender();
                        }
                    }, 1000 / 30);
                    this.DoRender();
                }
            }
        };
        Engine.prototype.SetRenderMode = function (renderMode) {
            if (this.m_renderMode == renderMode) {
                return;
            }
            if (this.m_renderTimer) {
                clearInterval(this.m_renderTimer);
                this.m_renderTimer = null;
            }
            this.m_renderMode = renderMode;
            this.render();
        };
        Engine.prototype._draw = function () {
            var mapView = this._mapView;
            if (mapView == null || mapView == undefined) {
                return;
            }
            if (ShadowMgr$1.GetInstance().IsShadowUpdated()) {
                this.DrawShadowMapBegin();
                this.DrawShadowMap();
                this.DrawShadowMapEnd();
            }
            this._collisionMng.updateFadeResult();
            this._drawLayers(false);
        };
        Engine.prototype.DrawShadowMapBegin = function () {
            this.m_renderCamera = this._camera;
        };
        Engine.prototype.DrawShadowMapEnd = function () {
            this._camera = this.m_renderCamera;
        };
        Engine.prototype.DrawShadowMap = function () {
            ShadowMgr$1.GetInstance().ForceUpdate();
            ShadowMgr$1.GetInstance().Render();
        };
        Engine.prototype.SetCurCamera = function (camera) {
            this._camera = camera;
        };
        Engine.prototype._drawLayers = function (bDepthRender) {
            this._camera.getZoom();
            if (bDepthRender == false) {
                var _a = EngineUtils.getContainerRange(this._rect), width = _a.width, height = _a.height;
                this._gl.viewport(0, 0, width * devicePixelRatio, height * devicePixelRatio);
                this._glContext.clear();
            }
            for (var i = 0; i < this._tileLayers.size(); i += 1) {
                this._drawTile(this._tileLayers.get(i), bDepthRender);
            }
            for (var i = 0; i < this._layers.size(); i += 1) {
                var type = this._layers.get(i).getType();
                this._layers.get(i);
                if (type === 'Fill') {
                    this._drawFill(this._layers.get(i), bDepthRender);
                }
                else if (type === 'FillExtrusion') {
                    this._drawFillExtrusion(this._layers.get(i), bDepthRender);
                }
                else if (type === 'Symbol') {
                    this._drawSymbol(this._layers.get(i), bDepthRender);
                }
                else if (type === 'Line') {
                    this._drawLine(this._layers.get(i), bDepthRender);
                }
                else if (type === 'Track') {
                    this._drawTrack(this._layers.get(i), bDepthRender);
                }
                else if (type === 'Circle') {
                    this._drawCircle(this._layers.get(i), bDepthRender);
                }
                else if (type === 'Picture') {
                    this._drawPicture(this._layers.get(i), bDepthRender);
                }
                else if (type === 'Model') {
                    this._drawModel(this._layers.get(i), bDepthRender);
                }
                else if (type === 'Heatmap') {
                    this._drawHeatmap(this._layers.get(i), bDepthRender);
                }
                else if (type === 'Connection') {
                    this._drawConnection(this._layers.get(i), bDepthRender);
                }
            }
        };
        Engine.prototype._drawTile = function (layer, bDepthRender) {
            var geometryRenderList = layer.getGeometryRenderList();
            if (bDepthRender) {
                return;
            }
            if (bDepthRender == false) {
                this._glContext.use('tile');
            }
            else {
                this._glContext.use('shadowMap');
            }
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            this._glContext.disableDepthTest();
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            this.initShadowMapViewProjectMatrix(program);
            if (bDepthRender == false) {
                this.syncShadowMapTextureToShader(program);
            }
            var u_matrix = program.getUniformLocation('u_matrix');
            var u_offset = program.getUniformLocation('u_offset');
            var a_position = program.getAttribLocation('a_position');
            var a_texCoord = program.getAttribLocation('a_texCoord');
            var u_opacity = program.getUniformLocation('u_opacity');
            var u_sampler = program.getUniformLocation('u_sampler');
            var u_scale = program.getUniformLocation('u_scale');
            var scale = layer.getOriginRatio() / this._camera.getOnePixelToWorld();
            this._gl.uniform1f(u_scale, scale);
            this._gl.uniform1i(u_sampler, 0);
            this._gl.uniformMatrix4fv(u_matrix, false, this._camera.tileMatrix);
            var num = this._camera.getOnePixelToWorld() / this._camera.getTileRatio();
            var offset = layer.getOriginCenter().subtract(this._camera.getCenter()).divide(num);
            this._gl.uniform2fv(u_offset, [offset.x, offset.y]);
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                var _a = geometryRenderList[i], buffer = _a.buffer, opacity = _a.opacity;
                this._gl.uniform1f(u_opacity, opacity);
                buffer.bind(a_position, a_texCoord);
                this._gl.drawArrays(this._gl.TRIANGLE_STRIP, 0, buffer.verticesNum);
            }
        };
        Engine.prototype._drawConnection = function (layer, bDepthRender) {
            if (bDepthRender) {
                return;
            }
            this._glContext.use(layer.getShaderName());
            this._glContext.enableDepthTest();
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            this._initViewProjectionMatrix(program);
            var geometryRenderList = layer.getGeometryRenderList();
            var a_position = program.getAttribLocation('a_position');
            var a_texCoord = program.getAttribLocation('a_texCoord');
            var a_normal = program.getAttribLocation('a_normal');
            var u_base = program.getUniformLocation('u_base');
            var u_opacity = program.getUniformLocation('u_opacity');
            var u_color = program.getUniformLocation('u_color');
            var u_onePixelToWorld = program.getUniformLocation('u_onePixelToWorld');
            var u_useTexture = program.getUniformLocation('u_useTexture');
            var u_imgSize = program.getUniformLocation('u_imgSize');
            var u_width = program.getUniformLocation('u_width');
            var u_time = program.getUniformLocation('u_time');
            var curTime = Date.now();
            var floatTime = curTime / 1000.0 / 4.0;
            floatTime = floatTime - Math.floor(floatTime);
            this._gl.uniform1f(u_time, floatTime);
            this._gl.uniform1f(u_onePixelToWorld, this._camera.getOnePixelToWorld());
            var u_modelMatrix = program.getUniformLocation('u_modelMatrix');
            this._gl.uniformMatrix4fv(u_modelMatrix, false, this._camera.rotateMatrix);
            var multiLayout = layer.getMultiLayout();
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                var _a = geometryRenderList[i], buffer = _a.buffer, base = _a.base, opacity = _a.opacity, color = _a.color, width = _a.width, useTexture = _a.useTexture, imgSize = _a.imgSize;
                buffer.bind({ a_position: a_position, a_normal: a_normal, a_texCoord: a_texCoord }, program);
                this._gl.uniform1f(u_base, base + multiLayout.base);
                this._gl.uniform1i(u_useTexture, useTexture ? 1 : 0);
                this._gl.uniform1f(u_width, width);
                this._gl.uniform2fv(u_imgSize, imgSize);
                this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity);
                this._gl.uniform4fv(u_color, color);
                this._gl.drawArrays(this._gl.TRIANGLE_STRIP, 0, buffer.verticesNum);
            }
        };
        Engine.prototype._drawHeatmap = function (layer, bDepthRender) {
            if (bDepthRender) {
                return;
            }
            this._glContext.use(layer.getShaderName());
            this._glContext.disableDepthTest();
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE);
            var buffer = layer.getBuffer();
            var program = this._glContext.getActiveProgram();
            if (!buffer || !program)
                return;
            this._initViewProjectionMatrix(program);
            var u_radius = program.getUniformLocation('u_radius');
            var a_normal = program.getAttribLocation('a_normal');
            var u_resolution = program.getUniformLocation('u_resolution');
            this._gl.uniform2fv(u_resolution, [this._camera.getWidth(), this._camera.getHeight()]);
            var u_position = program.getUniformLocation('u_position');
            buffer.bind(a_normal);
            this._glContext.enableFrameBuffer();
            var geometryRenderList = layer.getGeometryRenderList();
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                var _a = geometryRenderList[i], point = _a.point, radius = _a.radius;
                this._gl.uniform2fv(u_position, point);
                this._gl.uniform1f(u_radius, radius);
                this._gl.drawArrays(this._gl.TRIANGLE_FAN, 0, buffer.verticesNum);
            }
            this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
            this._drawHeatMapTexture(layer);
        };
        Engine.prototype._drawHeatMapTexture = function (layer) {
            this._glContext.use('heatmapTexture');
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            this._glContext.disableDepthTest();
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            var a_position = program.getAttribLocation('a_position');
            var u_resolution = program.getUniformLocation('u_resolution');
            var u_opacity = program.getUniformLocation('u_opacity');
            var opacity = layer.getLayout().opacity;
            var multiLayout = layer.getMultiLayout();
            this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity);
            var _a = this._glContext.getViewRect(), width = _a.width, height = _a.height;
            this._gl.uniform2fv(u_resolution, [width, height]);
            var vertices = [-1, -1, -1, 1, 1, -1, 1, 1];
            this._glContext.initArrayBuffer(a_position, new Float32Array(vertices), 2);
            this._gl.drawArrays(this._gl.TRIANGLE_STRIP, 0, 4);
        };
        Engine.prototype._drawModel = function (layer, bDepthRender) {
            var generalShaderName = layer.getShaderName();
            if (bDepthRender == false) {
                this._glContext.use(generalShaderName);
            }
            else {
                this._glContext.use('shadowMap');
            }
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            this._glContext.enableDepthTest();
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            this._initViewProjectionMatrix(program);
            this._setLight(program);
            var zScale = 1.0;
            var u_color = program.getUniformLocation('u_color');
            var u_modelMatrix = program.getUniformLocation('u_modelMatrix');
            var u_opacity = program.getUniformLocation('u_opacity');
            var u_position = program.getUniformLocation('u_position');
            var u_base = program.getUniformLocation('u_base');
            var a_position = program.getAttribLocation('a_position');
            var a_texCoord = program.getAttribLocation('a_texCoord');
            var a_normal = program.getAttribLocation('a_normal');
            var u_zScale = program.getUniformLocation('u_zScale');
            var u_useTexture = program.getUniformLocation('u_useTexture');
            var u_brightness = program.getUniformLocation('u_brightness');
            var multiLayout = layer.getMultiLayout();
            var geometryRenderList = layer.getGeometryRenderList();
            var zoom = this._camera.getZoom();
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                for (var j = 0; j < geometryRenderList[i].length; j += 1) {
                    var _a = geometryRenderList[i][j], color = _a.color, matrix = _a.matrix, buffer = _a.buffer, useTexture = _a.useTexture, opacity = _a.opacity, point = _a.point, base = _a.base, stops = _a.stops, brightness = _a.brightness, featureId = _a.featureId;
                    buffer.bind(a_position, a_texCoord, a_normal);
                    var zoomOpacity = StyleUtils.getStopsOpacity(zoom, stops);
                    var cameraExtraOpacity = ExtraMgr.GetInstance().GetExtraOpacity(featureId);
                    if (cameraExtraOpacity == 0.0) {
                        continue;
                    }
                    this._gl.uniform4fv(u_color, color);
                    this._gl.uniform2fv(u_position, point);
                    this._gl.uniform1f(u_base, base + multiLayout.base);
                    this._gl.uniform1i(u_useTexture, useTexture);
                    this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity * zoomOpacity * cameraExtraOpacity);
                    zScale = ExtraMgr.GetInstance().GetExtraAnimZ(featureId);
                    this._gl.uniform1f(u_zScale, zScale);
                    this._gl.uniform1f(u_brightness, brightness);
                    this._gl.uniformMatrix4fv(u_modelMatrix, false, matrix);
                    this._gl.drawArrays(this._gl.TRIANGLES, 0, buffer.verticesNum);
                }
            }
        };
        Engine.prototype._drawCircle = function (layer, bDepthRender) {
            if (bDepthRender) {
                return;
            }
            this._glContext.use(layer.getShaderName());
            this._glContext.disableDepthTest();
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            var buffer = layer.getBuffer();
            var program = this._glContext.getActiveProgram();
            if (!program || !buffer)
                return;
            this._initViewProjectionMatrix(program);
            var u_color = program.getUniformLocation('u_color');
            var u_radius = program.getUniformLocation('u_radius');
            var u_base = program.getUniformLocation('u_base');
            var u_opacity = program.getUniformLocation('u_opacity');
            var a_normal = program.getAttribLocation('a_normal');
            var u_resolution = program.getUniformLocation('u_resolution');
            this._gl.uniform2fv(u_resolution, [this._camera.getWidth(), this._camera.getHeight()]);
            var u_position = program.getUniformLocation('u_position');
            var geometryRenderList = layer.getGeometryRenderList();
            buffer.bind(a_normal);
            var multiLayout = layer.getMultiLayout();
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                var _a = geometryRenderList[i], base = _a.base, radius = _a.radius, color = _a.color, point = _a.point, opacity = _a.opacity;
                this._gl.uniform2fv(u_position, point);
                this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity);
                this._gl.uniform1f(u_base, base + multiLayout.base);
                this._gl.uniform1f(u_radius, radius);
                this._gl.uniform4fv(u_color, color);
                this._gl.drawArrays(this._gl.TRIANGLE_FAN, 0, buffer.verticesNum);
            }
        };
        Engine.prototype._drawTrack = function (track, bDepthRender) {
            if (bDepthRender) {
                return;
            }
            this._glContext.use(track.getShaderName());
            this._glContext.disableDepthTest();
            this._glContext.disableAlpha();
            var geometryRenderList = track.getGeometryRenderList();
            var program = this._glContext.getActiveProgram();
            if (program === null) {
                return;
            }
            this._initViewProjectionMatrix(program);
            var a_position = program.getAttribLocation('a_position');
            var u_color = program.getUniformLocation('u_color');
            var u_base = program.getUniformLocation('u_base');
            var u_opacity = program.getUniformLocation('u_opacity');
            var multiLayout = track.getMultiLayout();
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                var _a = geometryRenderList[i], buffer = _a.buffer, color = _a.color, base = _a.base, opacity = _a.opacity;
                buffer.bind(a_position);
                this._gl.uniform4fv(u_color, color);
                this._gl.uniform1f(u_base, base + multiLayout.base);
                this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity);
                this._gl.drawElements(this._gl.LINES, buffer.indicesNum, this._gl.UNSIGNED_SHORT, 0);
            }
        };
        Engine.prototype.checkZoomRange = function (zoomRange) {
            var zoom = this._camera.getZoom();
            if ((this._mapView
                && this._mapView.getFeatureZoomRangeEnabled() == false)
                || (zoom && zoomRange && zoom >= zoomRange[0] && zoom <= zoomRange[1])
                || zoom >= 18.5) {
                return true;
            }
            else {
                return false;
            }
        };
        Engine.prototype.recalculateFloorHeightByNavi = function (floorString) {
            if (floorString == undefined) {
                return 0;
            }
            if (this._mapView.m_navi && this._mapView.m_navi.IsInNaviMode() && this._mapView.m_navi._naviMng) {
                var floorArray = this._mapView.m_navi._naviMng.getFloorOrder();
                for (var i = 0; i < floorArray.length; i++) {
                    var floorId = floorArray[i];
                    if (floorString == floorId) {
                        return i * 10;
                    }
                }
                return 0;
            }
            else {
                return 0;
            }
        };
        Engine.prototype.IsF0 = function (floorString) {
            var floorType = floorString.charAt(6);
            var floorLevel = floorString.charAt(8);
            if (floorType == 'F' && floorLevel == '0') {
                return true;
            }
            else {
                return false;
            }
        };
        Engine.prototype.checkNaviRenderFloor = function (floorString) {
            if (floorString == undefined) {
                return true;
            }
            if (this._mapView.currentFloor == floorString) {
                return true;
            }
            if (this._mapView.m_navi && this._mapView.m_navi.IsInNaviMode() && this._mapView.m_navi._naviMng) {
                var floorArray = this._mapView.m_navi._naviMng.getFloorOrder();
                for (var i = 0; i < floorArray.length; i++) {
                    var floorId = floorArray[i];
                    if (floorString == floorId) {
                        return true;
                    }
                }
                return false;
            }
            else {
                return true;
            }
        };
        Engine.prototype.needDraw = function (zoomRange, floorString, isF0) {
            var mapView = this._mapView;
            if (mapView == null || mapView == undefined) {
                return false;
            }
            mapView.currentFloor.charAt(6);
            if (isF0 == true) {
                return true;
            }
            if (this.checkZoomRange(zoomRange) == false) {
                return false;
            }
            return true;
        };
        Engine.prototype._drawFill = function (fill, bDepthRender) {
            this._camera.getZoom();
            var shadowEnable = this._mapView.getShadowEnable();
            var generalShaderName = fill.getShaderName();
            this._mapView.getLowDisplay();
            if (bDepthRender == true) {
                return;
            }
            if (bDepthRender == false) {
                this._glContext.use(generalShaderName);
            }
            else {
                this._glContext.use('shadowMap');
            }
            if (bDepthRender == false) {
                this._glContext.disableDepthTest();
            }
            else {
                this._glContext.enableDepthTest();
            }
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            var geometryRenderList = fill.getGeometryRenderList();
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            this._initViewProjectionMatrix(program);
            this.initShadowMapViewProjectMatrix(program);
            if (bDepthRender == false && shadowEnable == true) {
                this.syncShadowMapTextureToShader(program);
            }
            var a_position = program.getAttribLocation('a_position');
            var a_texCoord = program.getAttribLocation('a_texCoord');
            var u_color = program.getUniformLocation('u_color');
            var u_base = program.getUniformLocation('u_base');
            var u_opacity = program.getUniformLocation('u_opacity');
            var multiLayout = fill.getMultiLayout();
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                var _a = geometryRenderList[i], outlineColor = _a.outlineColor, fillColor = _a.fillColor, buffer = _a.buffer, base = _a.base, opacity = _a.opacity, zoomRange = _a.zoomRange, floorString = _a.floorString, bHasTexture = _a.bHasTexture, texCoordFactor = _a.texCoordFactor; _a.featureId; var isF0 = _a.isF0;
                if (this.needDraw(zoomRange, floorString, isF0) == true) ;
                else {
                    continue;
                }
                {
                    this.syncBrightnessSaturationContrastToShader();
                    this.syncTextureParamToShader(bHasTexture);
                    this.syncTextureCoordFactor(texCoordFactor);
                }
                buffer.bindData(a_position, a_texCoord);
                this._gl.uniform1f(u_base, base + multiLayout.base);
                this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity);
                this._gl.uniform4fv(u_color, fillColor);
                buffer.bindIndices('fill');
                this._gl.drawElements(this._gl.TRIANGLES, buffer.fillIndicesNum, this._gl.UNSIGNED_SHORT, 0);
                this._gl.uniform4fv(u_color, outlineColor);
                buffer.bindIndices('outline');
                this._gl.drawElements(this._gl.LINES, buffer.outlineIndicesNum, this._gl.UNSIGNED_SHORT, 0);
            }
        };
        Engine.prototype.syncBrightnessSaturationContrastToShader = function () {
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            var brightness = this._mapView.getBrightness();
            var u_brightness = program.getUniformLocation('u_brightness');
            this._gl.uniform1f(u_brightness, brightness);
            var saturation = this._mapView.getSaturation();
            var u_saturation = program.getUniformLocation('u_saturation');
            this._gl.uniform1f(u_saturation, saturation);
            var contrast = this._mapView.getContrast();
            var u_contrast = program.getUniformLocation('u_contrast');
            this._gl.uniform1f(u_contrast, contrast);
        };
        Engine.prototype.syncTextureCoordFactor = function (texCoordFactor) {
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            var u_texCoordFactor = program.getUniformLocation('u_texCoordFactor');
            this._gl.uniform1f(u_texCoordFactor, texCoordFactor);
        };
        Engine.prototype.syncTextureParamToShader = function (bHasTexture) {
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            var bTextureEnable = this._mapView.getTextureEnable();
            var u_textureFactor = program.getUniformLocation('u_textureFactor');
            var textureFactor = 0;
            if (bHasTexture == false || bTextureEnable == false) {
                textureFactor = 0;
            }
            else {
                textureFactor = 1;
            }
            this._gl.uniform1f(u_textureFactor, textureFactor);
        };
        Engine.prototype.syncLightsParamToShader = function () {
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            var lights = this._mapView.getLights();
            var u_pointLightFactor = program.getUniformLocation('u_pointLightFactor');
            if (lights.length <= 0) {
                this._gl.uniform4f(u_pointLightFactor, 0, 0, 0, 0);
            }
            else if (lights.length <= 1) {
                this._gl.uniform4f(u_pointLightFactor, 1, 0, 0, 0);
            }
            else if (lights.length <= 2) {
                this._gl.uniform4f(u_pointLightFactor, 1, 1, 0, 0);
            }
            else if (lights.length <= 3) {
                this._gl.uniform4f(u_pointLightFactor, 1, 1, 1, 0);
            }
            else if (lights.length <= 4) {
                this._gl.uniform4f(u_pointLightFactor, 1, 1, 1, 1);
            }
            var lightPos = new Point3(0, 0, 0);
            var lightDiffuse = new Color(0, 0, 0, 1);
            if (lights.length >= 1) {
                lightPos = lights[0].m_pos;
                lightDiffuse = lights[0].m_color;
                var u_pointLightPos1 = program.getUniformLocation('u_pointLightPos1');
                this._gl.uniform3f(u_pointLightPos1, lightPos.x, lightPos.y, lightPos.z);
                var u_pointLightDiffuse1 = program.getUniformLocation('u_pointLightDiffuse1');
                this._gl.uniform3f(u_pointLightDiffuse1, lightDiffuse.r, lightDiffuse.g, lightDiffuse.b);
            }
            else {
                var u_pointLightPos1 = program.getUniformLocation('u_pointLightPos1');
                this._gl.uniform3f(u_pointLightPos1, 0, 0, 0);
                var u_pointLightDiffuse1 = program.getUniformLocation('u_pointLightDiffuse1');
                this._gl.uniform3f(u_pointLightDiffuse1, 0, 0, 0);
            }
            if (lights.length >= 2) {
                lightPos = lights[1].m_pos;
                lightDiffuse = lights[1].m_color;
                var u_pointLightPos2 = program.getUniformLocation('u_pointLightPos2');
                this._gl.uniform3f(u_pointLightPos2, lightPos.x, lightPos.y, lightPos.z);
                var u_pointLightDiffuse2 = program.getUniformLocation('u_pointLightDiffuse2');
                this._gl.uniform3f(u_pointLightDiffuse2, lightDiffuse.r, lightDiffuse.g, lightDiffuse.b);
            }
            else {
                var u_pointLightPos2 = program.getUniformLocation('u_pointLightPos2');
                this._gl.uniform3f(u_pointLightPos2, 0, 0, 0);
                var u_pointLightDiffuse2 = program.getUniformLocation('u_pointLightDiffuse2');
                this._gl.uniform3f(u_pointLightDiffuse2, 0, 0, 0);
            }
            if (lights.length >= 3) {
                lightPos = lights[2].m_pos;
                lightDiffuse = lights[2].m_color;
                var u_pointLightPos3 = program.getUniformLocation('u_pointLightPos3');
                this._gl.uniform3f(u_pointLightPos3, lightPos.x, lightPos.y, lightPos.z);
                var u_pointLightDiffuse3 = program.getUniformLocation('u_pointLightDiffuse3');
                this._gl.uniform3f(u_pointLightDiffuse3, lightDiffuse.r, lightDiffuse.g, lightDiffuse.b);
            }
            else {
                var u_pointLightPos3 = program.getUniformLocation('u_pointLightPos3');
                this._gl.uniform3f(u_pointLightPos3, 0, 0, 0);
                var u_pointLightDiffuse3 = program.getUniformLocation('u_pointLightDiffuse3');
                this._gl.uniform3f(u_pointLightDiffuse3, 0, 0, 0);
            }
            if (lights.length >= 4) {
                lightPos = lights[3].m_pos;
                lightDiffuse = lights[3].m_color;
                var u_pointLightPos4 = program.getUniformLocation('u_pointLightPos4');
                this._gl.uniform3f(u_pointLightPos4, lightPos.x, lightPos.y, lightPos.z);
                var u_pointLightDiffuse4 = program.getUniformLocation('u_pointLightDiffuse4');
                this._gl.uniform3f(u_pointLightDiffuse4, lightDiffuse.r, lightDiffuse.g, lightDiffuse.b);
            }
            else {
                var u_pointLightPos4 = program.getUniformLocation('u_pointLightPos4');
                this._gl.uniform3f(u_pointLightPos4, 0, 0, 0);
                var u_pointLightDiffuse4 = program.getUniformLocation('u_pointLightDiffuse4');
                this._gl.uniform3f(u_pointLightDiffuse4, 0, 0, 0);
            }
        };
        Engine.prototype.drawFillExtrusionTopFace = function (fillExtrusion, bDepthRender) {
            var generalShaderName = fillExtrusion.getShaderName();
            var mapView = this.getMapView();
            if (mapView == null || mapView == undefined) {
                return;
            }
            var bEnableShadow = mapView.getShadowEnable();
            var bLowDisplay = mapView.getLowDisplay();
            if (mapView.getLowDisplay() == true) {
                generalShaderName = "fillExtrusion2";
            }
            if (bDepthRender == false) {
                this._glContext.use(generalShaderName);
            }
            else {
                this._glContext.use('shadowMap');
            }
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            this._glContext.enableDepthTest();
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            this._initViewProjectionMatrix(program);
            this.initShadowMapViewProjectMatrix(program);
            if (bDepthRender == false && bEnableShadow == true) {
                this.syncShadowMapTextureToShader(program);
            }
            this._setLight(program);
            var u_color = program.getUniformLocation('u_color');
            var u_height = program.getUniformLocation('u_height');
            var u_base = program.getUniformLocation('u_base');
            var u_opacity = program.getUniformLocation('u_opacity');
            var a_position = program.getAttribLocation('a_position');
            var a_normal = program.getAttribLocation('a_normal');
            var u_drawLine = program.getUniformLocation('u_drawLine');
            var a_texCoord = program.getAttribLocation('a_texCoord');
            var u_sampler = program.getUniformLocation('u_sampler');
            var u_timer = program.getUniformLocation('u_timer');
            program.getUniformLocation('u_textureFactor');
            this._gl.uniform1i(u_sampler, 0);
            var sec = new Date().getSeconds();
            var sec2 = Math.floor(sec / 10.0);
            var sec3 = sec2 % 2;
            this._gl.uniform1f(u_timer, sec3);
            var geometryRenderList = fillExtrusion.getGeometryRenderList();
            var multiLayout = fillExtrusion.getMultiLayout();
            var zoom = this._camera.getZoom();
            var maxRenderCount = geometryRenderList.length;
            var maxDisplayedRoomCount = this._mapView.getMaxDisplayedRoomCount();
            var count = 0;
            var interval = Math.max(1, maxRenderCount / maxDisplayedRoomCount);
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                count++;
                if (count < interval) {
                    continue;
                }
                else {
                    count -= interval;
                }
                var _a = geometryRenderList[i], fillColor = _a.fillColor, base = _a.base, buffer = _a.buffer, height = _a.height, outlineColor = _a.outlineColor, opacity = _a.opacity, stops = _a.stops, zoomRange = _a.zoomRange, floorString = _a.floorString; _a.texture; var featureId = _a.featureId, bHasTexture = _a.bHasTexture, texCoordFactor = _a.texCoordFactor, isF0 = _a.isF0;
                if (bDepthRender == true
                    && isF0 == true) {
                    continue;
                }
                if (bLowDisplay == false) {
                    this.syncLightsParamToShader();
                }
                this.syncTextureParamToShader(bHasTexture);
                this.syncBrightnessSaturationContrastToShader();
                this.syncTextureCoordFactor(texCoordFactor);
                if (bDepthRender == true || this.needDraw(zoomRange, floorString, isF0) == true) ;
                else {
                    continue;
                }
                var featureHeight = this._mapView.GetFeatureHeight(featureId);
                if (featureHeight != null && featureHeight != undefined) {
                    height = featureHeight;
                }
                var cameraExtraOpacity = ExtraMgr.GetInstance().GetExtraOpacity(featureId);
                if (cameraExtraOpacity == 0.0) {
                    continue;
                }
                this._gl.uniform1f(u_base, base + multiLayout.base);
                buffer.bindData(a_position, a_normal, a_texCoord);
                if (ExtraMgr.GetInstance().IsExtra(featureId) == true) {
                    height = height * ExtraMgr.GetInstance().GetExtraAnimZ(featureId);
                }
                this._gl.uniform1f(u_height, height);
                var zoomOpacity = StyleUtils.getStopsOpacity(zoom, stops);
                this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity * zoomOpacity * cameraExtraOpacity);
                this._gl.uniform4fv(u_color, outlineColor);
                this._gl.uniform1i(u_drawLine, 1);
                buffer.bindIndices('outline');
                this._gl.drawElements(this._gl.LINES, buffer.outlineIndicesNum, this._gl.UNSIGNED_SHORT, 0);
                this._gl.uniform4fv(u_color, fillColor);
                this._gl.uniform1i(u_drawLine, 0);
                buffer.bindIndices('fill');
                this._gl.drawElements(this._gl.TRIANGLES, buffer.fillIndicesNum, this._gl.UNSIGNED_SHORT, 0);
            }
        };
        Engine.prototype.drawFillExtrusionSideFace = function (fillExtrusion, bDepthRender) {
            var generalShaderName = fillExtrusion.getShaderName();
            var bLowDisplay = this._mapView.getLowDisplay();
            if (bDepthRender == false) {
                if (Global.m_bLowDisplay) {
                    generalShaderName = 'fillExtrusion2';
                }
                this._glContext.use(generalShaderName);
            }
            else {
                this._glContext.use('shadowMap');
            }
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            this._glContext.enableDepthTest();
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            this._initViewProjectionMatrix(program);
            this._setLight(program);
            var u_color = program.getUniformLocation('u_color');
            var u_height = program.getUniformLocation('u_height');
            var u_base = program.getUniformLocation('u_base');
            var u_opacity = program.getUniformLocation('u_opacity');
            var a_position = program.getAttribLocation('a_position');
            var a_normal = program.getAttribLocation('a_normal');
            var u_drawLine = program.getUniformLocation('u_drawLine');
            var a_texCoord = program.getAttribLocation('a_texCoord');
            var u_sampler = program.getUniformLocation('u_sampler');
            var u_timer = program.getUniformLocation('u_timer');
            program.getUniformLocation('u_textureFactor');
            this._gl.uniform1i(u_sampler, 0);
            var sec = new Date().getSeconds();
            var sec2 = Math.floor(sec / 10.0);
            var sec3 = sec2 % 2;
            this._gl.uniform1f(u_timer, sec3);
            var geometryRenderList = fillExtrusion.getGeometryRenderList();
            var multiLayout = fillExtrusion.getMultiLayout();
            var zoom = this._camera.getZoom();
            var maxRenderCount = geometryRenderList.length;
            var maxDisplayedRoomCount = this._mapView.getMaxDisplayedRoomCount();
            var count = 0;
            var interval = Math.max(1, maxRenderCount / maxDisplayedRoomCount);
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                count++;
                if (count < interval) {
                    continue;
                }
                else {
                    count -= interval;
                }
                var _a = geometryRenderList[i], fillColor = _a.fillColor, base = _a.base, buffer = _a.buffer, height = _a.height; _a.outlineColor; var opacity = _a.opacity, stops = _a.stops, zoomRange = _a.zoomRange, floorString = _a.floorString; _a.texture; var featureId = _a.featureId, bHasTexture = _a.bHasTexture, texCoordFactor = _a.texCoordFactor, isF0 = _a.isF0;
                if (bDepthRender == true
                    && isF0 == true) {
                    continue;
                }
                if (bLowDisplay == false) {
                    this.syncLightsParamToShader();
                }
                this.syncTextureParamToShader(bHasTexture);
                this.syncBrightnessSaturationContrastToShader();
                this.syncTextureCoordFactor(texCoordFactor);
                if (bDepthRender == true || this.needDraw(zoomRange, floorString, isF0) == true) ;
                else {
                    continue;
                }
                var featureHeight = this._mapView.GetFeatureHeight(featureId);
                if (featureHeight != null && featureHeight != undefined) {
                    height = featureHeight;
                }
                var cameraExtraOpacity = ExtraMgr.GetInstance().GetExtraOpacity(featureId);
                if (cameraExtraOpacity == 0.0) {
                    continue;
                }
                this._gl.uniform1f(u_base, base + multiLayout.base);
                buffer.bindSideFaceData(a_position, a_normal, a_texCoord);
                if (ExtraMgr.GetInstance().IsExtra(featureId) == true) {
                    height = height * ExtraMgr.GetInstance().GetExtraAnimZ(featureId);
                }
                this._gl.uniform1f(u_height, height);
                var zoomOpacity = StyleUtils.getStopsOpacity(zoom, stops);
                this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity * zoomOpacity * cameraExtraOpacity);
                this._gl.uniform4fv(u_color, fillColor);
                this._gl.uniform1i(u_drawLine, 0);
                buffer.bindSideIndices('fill');
                this._gl.drawElements(this._gl.TRIANGLES, buffer.sideIndicesNum, this._gl.UNSIGNED_SHORT, 0);
            }
        };
        Engine.prototype._drawFillExtrusion = function (fillExtrusion, bDepthRender) {
            var mapView = this._mapView;
            if (mapView == null || mapView == undefined) {
                return;
            }
            var bOnly2d = this._mapView.getOnly2d();
            var bCutFillExtrusion = this._mapView.getTextureEnable();
            this.drawFillExtrusionTopFace(fillExtrusion, bDepthRender);
            if (bOnly2d == false && bCutFillExtrusion) {
                this.drawFillExtrusionSideFace(fillExtrusion, bDepthRender);
            }
        };
        Engine.prototype._drawSymbol = function (symbol, bDepthRender) {
            if (bDepthRender == true) {
                return;
            }
            this._glContext.use(symbol.getShaderName());
            this._glContext.enableAlpha();
            this._gl.blendFuncSeparate(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
            this._glContext.disableDepthTest();
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            this._initViewProjectionMatrix(program);
            var u_rotateMatrix = program.getUniformLocation('u_rotateMatrix');
            this._gl.uniformMatrix4fv(u_rotateMatrix, false, this._camera.rotateMatrix);
            var u_pitchMatrix = program.getUniformLocation('u_pitchMatrix');
            this._gl.uniformMatrix4fv(u_pitchMatrix, false, this._camera.pitchMatrix);
            var u_resolution = program.getUniformLocation('u_resolution');
            this._gl.uniform2fv(u_resolution, [this._camera.getWidth(), this._camera.getHeight()]);
            var u_position = program.getUniformLocation('u_position');
            var u_offset = program.getUniformLocation('u_offset');
            var u_opacity = program.getUniformLocation('u_opacity');
            var u_sampler = program.getUniformLocation('u_sampler');
            this._gl.uniform1i(u_sampler, 0);
            var u_base = program.getUniformLocation('u_base');
            var a_position = program.getAttribLocation('a_position');
            var a_texCoord = program.getAttribLocation('a_texCoord');
            var geometryRenderList = symbol.getGeometryRenderList();
            var multiLayout = symbol.getMultiLayout();
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                for (var j = 0; j < geometryRenderList[i].length; j += 1) {
                    var _a = geometryRenderList[i][j], buffer = _a.buffer, point = _a.point, offset = _a.offset, base = _a.base, opacity = _a.opacity, floorString_1 = _a.floorString, height = _a.height; _a.featureId;
                    var zoomRange_1 = [0, 24];
                    if (this.needDraw(zoomRange_1, floorString_1, false) == true) ;
                    else {
                        continue;
                    }
                    if (height !== null && height !== undefined && height !== 0) {
                        base = height;
                    }
                    this._gl.uniform2fv(u_position, point);
                    this._gl.uniform2fv(u_offset, offset);
                    this._gl.uniform1f(u_base, base + multiLayout.base);
                    this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity);
                    buffer.bind(a_position, a_texCoord);
                    this._gl.drawArrays(this._gl.TRIANGLE_STRIP, 0, buffer.verticesNum);
                }
            }
            var data = {
                u_position: u_position,
                u_offset: u_offset,
                u_base: u_base,
                u_opacity: u_opacity,
                a_position: a_position,
                a_texCoord: a_texCoord,
            };
            var floorString = symbol._floorId;
            var zoomRange = [0, 24];
            if (this.needDraw(zoomRange, floorString, false) == true) {
                var hideResult = this._collisionMng.getHideResult();
                hideResult && this._drawCollisionResult(hideResult, symbol, data);
                var showResult = this._collisionMng.getShowResult();
                showResult && this._drawCollisionResult(showResult, symbol, data);
                this._drawCollisionResult(this._collisionMng.getNormalResult(), symbol, data);
            }
        };
        Engine.prototype._drawCollisionResult = function (result, layer, locations) {
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined) {
                return;
            }
            var arr = result.data[layer.id];
            if (!arr)
                return;
            var renderList = layer.getCollisionRenderList();
            var multiLayout = layer.getMultiLayout();
            if (renderList == null || renderList == undefined) {
                return;
            }
            var totalPoiCount = 0;
            for (var i = 0; i < arr.length; i++) {
                var list = renderList[arr[i]];
                if (list == null || list == undefined) {
                    continue;
                }
                totalPoiCount += list.length;
            }
            var maxAllowedPoiCount = mapView.getMaxDisplayedPOICount();
            var interval = totalPoiCount / maxAllowedPoiCount;
            interval = Math.max(1, interval);
            var count = 0;
            for (var i = 0; i < arr.length; i += 1) {
                var list = renderList[arr[i]] || [];
                for (var j = 0; j < list.length; j += 1) {
                    count++;
                    if (count < interval) {
                        continue;
                    }
                    else {
                        count -= interval;
                    }
                    var _a = list[j], buffer = _a.buffer, point = _a.point, offset = _a.offset, base = _a.base, opacity = _a.opacity; _a.featureId; var height = _a.height;
                    if (height != null && height != undefined && height != 0 && height != NaN) {
                        base = height;
                    }
                    this._gl.uniform2fv(locations.u_position, point);
                    this._gl.uniform2fv(locations.u_offset, offset);
                    this._gl.uniform1f(locations.u_base, base + multiLayout.base);
                    this._gl.uniform1f(locations.u_opacity, opacity * multiLayout.opacity * result.opacity);
                    buffer.bind(locations.a_position, locations.a_texCoord);
                    this._gl.drawArrays(this._gl.TRIANGLE_STRIP, 0, buffer.verticesNum);
                }
            }
        };
        Engine.prototype._drawPicture = function (picture, bDepthRender) {
            if (bDepthRender) {
                return;
            }
            var geometryRenderList = picture.getGeometryRenderList();
            this._glContext.use(picture.getShaderName());
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            this._glContext.disableDepthTest();
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            this._initViewProjectionMatrix(program);
            var a_position = program.getAttribLocation('a_position');
            var a_texCoord = program.getAttribLocation('a_texCoord');
            var u_opacity = program.getUniformLocation('u_opacity');
            var u_base = program.getUniformLocation('u_base');
            var u_rotate = program.getUniformLocation('u_rotate');
            var u_position = program.getUniformLocation('u_position');
            var u_sampler = program.getUniformLocation('u_sampler');
            this._gl.uniform1i(u_sampler, 0);
            var multiLayout = picture.getMultiLayout();
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                var _a = geometryRenderList[i], buffer = _a.buffer, point = _a.point, rotate = _a.rotate, base = _a.base, opacity = _a.opacity;
                this._gl.uniform1f(u_base, base + multiLayout.base);
                this._gl.uniform1f(u_rotate, rotate);
                this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity);
                this._gl.uniform2fv(u_position, point);
                buffer.bind(a_position, a_texCoord);
                this._gl.drawArrays(this._gl.TRIANGLE_STRIP, 0, buffer.verticesNum);
            }
        };
        Engine.prototype._drawLine = function (line, bDepthRender) {
            if (bDepthRender) {
                return;
            }
            if (this._mapView == null || this._mapView == undefined) {
                return;
            }
            var geometryRenderList = line.getGeometryRenderList();
            this._glContext.use(line.getShaderName());
            this._glContext.disableDepthTest();
            this._glContext.enableAlpha();
            this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
            var program = this._glContext.getActiveProgram();
            if (!program)
                return;
            this._initViewProjectionMatrix(program);
            var a_position = program.getAttribLocation('a_position');
            var a_normal = program.getAttribLocation('a_normal');
            var a_texCoord = program.getAttribLocation('a_texCoord');
            var a_deviation = program.getAttribLocation('a_deviation');
            var u_color = program.getUniformLocation('u_color');
            var u_onePixelToWorld = program.getUniformLocation('u_onePixelToWorld');
            var u_sampler = program.getUniformLocation('u_sampler');
            this._gl.uniform1i(u_sampler, 0);
            var u_lineWidth = program.getUniformLocation('u_lineWidth');
            var u_imgSize = program.getUniformLocation('u_imgSize');
            var u_opacity = program.getUniformLocation('u_opacity');
            var u_useTexture = program.getUniformLocation('u_useTexture');
            var u_base = program.getUniformLocation('u_base');
            var u_time = program.getUniformLocation('u_time');
            this._gl.uniform1f(u_onePixelToWorld, this._camera.getOnePixelToWorld());
            var multiLayout = line.getMultiLayout();
            var curTime = Date.now();
            var timePassed = (curTime - this._mapView.GetMapViewStartTime()) / 1000.0;
            for (var i = 0; i < geometryRenderList.length; i += 1) {
                var _a = geometryRenderList[i], lineColor = _a.lineColor, buffer = _a.buffer, useTexture = _a.useTexture, imgSize = _a.imgSize, lineWidth = _a.lineWidth, base = _a.base, opacity = _a.opacity, bGray = _a.bGray;
                if (bGray) {
                    timePassed = 0;
                }
                this._gl.uniform1i(u_useTexture, useTexture ? 1 : 0);
                this._gl.uniform1f(u_lineWidth, lineWidth);
                this._gl.uniform1f(u_base, base + multiLayout.base);
                this._gl.uniform1f(u_opacity, opacity * multiLayout.opacity);
                this._gl.uniform2fv(u_imgSize, imgSize);
                this._gl.uniform4fv(u_color, lineColor);
                this._gl.uniform1f(u_time, timePassed);
                buffer.bind({ a_position: a_position, a_normal: a_normal, a_deviation: a_deviation, a_texCoord: a_texCoord });
                this._gl.drawElements(this._gl.TRIANGLES, buffer.indicesNum, this._gl.UNSIGNED_SHORT, 0);
            }
        };
        Engine.prototype._setLight = function (program) {
            var u_normalMatrix = program.getUniformLocation('u_normalMatrix');
            this._gl.uniformMatrix4fv(u_normalMatrix, false, this._camera.rotateMatrix);
            var u_lightPos = program.getUniformLocation('u_lightPos');
            this._gl.uniform3fv(u_lightPos, this._lightPos);
            var u_ambientColor = program.getUniformLocation('u_ambientColor');
            this._gl.uniform3fv(u_ambientColor, this._ambientColor);
            var u_ambientMaterial = program.getUniformLocation('u_ambientMaterial');
            this._gl.uniform3fv(u_ambientMaterial, this._ambientMaterial);
            var u_diffuseColor = program.getUniformLocation('u_diffuseColor');
            this._gl.uniform3fv(u_diffuseColor, this._diffuseColor);
            var u_diffuseMaterial = program.getUniformLocation('u_diffuseMaterial');
            this._gl.uniform3fv(u_diffuseMaterial, this._diffuseMaterial);
        };
        Engine.prototype.destroy = function () {
            this._canvas.remove();
            this._collisionMng.off('change', this._onCollisionChange);
            this._collisionMng.destroy();
            this._bucketMng.destroy();
        };
        Engine.prototype.getCamera = function () {
            return this._camera;
        };
        Engine.prototype.getTextureMng = function () {
            return this._textureMng;
        };
        Engine.prototype.getGlyphMng = function () {
            return this._glyphMng;
        };
        Engine.prototype.getCanvas = function () {
            return this._canvas;
        };
        Engine.prototype.getLayers = function () {
            return this._layers;
        };
        Engine.prototype.contains = function (layer) {
            return this._layers.has(layer);
        };
        Engine.prototype.getGl = function () {
            return this._gl;
        };
        Engine.prototype._initViewProjectionMatrix = function (program) {
            if (program == null) {
                return;
            }
            var u_projectionMatrix = program === null || program === void 0 ? void 0 : program.getUniformLocation('u_projectionMatrix');
            var u_viewMatrix = program === null || program === void 0 ? void 0 : program.getUniformLocation('u_viewMatrix');
            this._gl.uniformMatrix4fv(u_projectionMatrix, false, this._camera.projectionMatrix);
            this._gl.uniformMatrix4fv(u_viewMatrix, false, this._camera.viewMatrix);
        };
        Engine.prototype.syncShadowMapTextureToShader = function (program) {
            if (program == null || program == undefined) {
                return;
            }
            var shadowLight = ShadowMgr$1.GetInstance().GetShadowLightByIndex(0);
            if (shadowLight == null || shadowLight == undefined) {
                return;
            }
            var shadowTexture = shadowLight.GetShadowTexture();
            if (shadowTexture == null || shadowTexture == undefined) {
                return;
            }
            var glShadowMapTexture = shadowTexture.GetWebGLTexture();
            if (glShadowMapTexture == null || glShadowMapTexture == undefined) {
                return;
            }
            this._gl.activeTexture(this._gl.TEXTURE1);
            this._gl.bindTexture(this._gl.TEXTURE_2D, glShadowMapTexture);
            var u_shadowSampler = program.getUniformLocation('u_shadowSampler');
            this._gl.uniform1i(u_shadowSampler, 1);
            this._gl.activeTexture(this._gl.TEXTURE0);
        };
        Engine.prototype.initShadowMapViewProjectMatrix = function (program) {
            if (program == null || program == undefined) {
                return;
            }
            var u_shadowMatrix = program.getUniformLocation('u_shadowMatrix');
            var shadowLightCount = ShadowMgr$1.GetInstance().GetShadowLightCount();
            if (shadowLightCount <= 0) {
                return;
            }
            var shadowLight = ShadowMgr$1.GetInstance().GetShadowLightByIndex(0);
            if (shadowLight == null || shadowLight == undefined) {
                return;
            }
            var shadowCamera = shadowLight.GetShadowCamera();
            if (shadowCamera == null || shadowCamera == undefined) {
                return;
            }
            var shadowMatrix = shadowCamera.GetMVP();
            this._gl.uniformMatrix4fv(u_shadowMatrix, false, shadowMatrix.getValue());
        };
        Engine.prototype._setupLight = function (options) {
            var lightPos = options.lightPos, ambientColor = options.ambientColor, ambientMaterial = options.ambientMaterial, diffuseColor = options.diffuseColor, diffuseMaterial = options.diffuseMaterial;
            if (lightPos) {
                this._lightPos = [lightPos.x, lightPos.y, lightPos.z];
            }
            if (ambientColor) {
                this._ambientColor = StyleUtils.parseColor(ambientColor);
            }
            if (ambientMaterial) {
                this._ambientMaterial = StyleUtils.parseColor(ambientMaterial);
            }
            if (diffuseColor) {
                this._diffuseColor = StyleUtils.parseColor(diffuseColor);
            }
            if (diffuseMaterial) {
                this._diffuseMaterial = StyleUtils.parseColor(diffuseMaterial);
            }
        };
        Engine.prototype.getZHeightByFloorString = function (floorString) {
            if (floorString == undefined || floorString == null || typeof floorString != 'string') {
                return 0;
            }
            var floorIndex = floorString.charAt(6);
            var signHeight = 1;
            if (floorIndex == 'B') {
                signHeight = -1;
            }
            var floorStr = floorString.substr(7, 2);
            var floor = Number(floorStr);
            if (floorIndex == 'F') {
                floor -= 1;
            }
            var result = signHeight * floor * 20;
            return result;
        };
        return Engine;
    }(NCore$1));

    var config = {
        Fill: { order: 1, shaderName: 'fill' },
        Picture: { order: 2, shaderName: 'picture' },
        Line: { order: 7, shaderName: 'line' },
        Connection: { order: 2, shaderName: 'connection' },
        FillExtrusion: { order: 3, shaderName: 'fillExtrusion' },
        Track: { order: 4, shaderName: 'track' },
        Circle: { order: 5, shaderName: 'circle' },
        Heatmap: { order: 5, shaderName: 'heatmap' },
        Symbol: { order: 10, shaderName: 'symbol' },
        Model: { order: 11, shaderName: 'model' },
        FillExtrusion2: { order: 3, shaderName: 'fillExtrusion2' },
    };

    var AbstractLayer = (function (_super) {
        __extends$1(AbstractLayer, _super);
        function AbstractLayer(type, layout) {
            var _this = _super.call(this) || this;
            _this._id = IdGenerator.getId();
            _this._name = 'layer';
            _this._features = [];
            _this._alwaysShow = false;
            _this._isSync = false;
            _this._ignoreMultiFade = false;
            _this._bindMap = new Map();
            bindAll([
                '_onBucketChange',
                '_onclick',
                '_onmousedown',
                '_onmousemove',
                '_onmouseup',
                '_ontouchstart',
                '_ontouchmove',
                '_ontouchend',
            ], _this);
            var _a = config[type], shaderName = _a.shaderName, order = _a.order;
            _this._shaderName = shaderName;
            _this._order = order;
            _this._type = type;
            _this._layout = __assign$1({}, layout);
            _this._lastLayout = __assign$1({}, layout);
            _this._multiLayout = { opacity: 1, base: 0 };
            return _this;
        }
        AbstractLayer.prototype._getTaskId = function () {
            return IdGenerator.getId('task');
        };
        AbstractLayer.prototype.on = function (type, listener) {
            _super.prototype.on.call(this, type, listener);
            switch (type) {
                case 'click':
                    this._checkBind('click', this._onclick);
                    break;
                case 'mousedown':
                    this._checkBind('mousedown', this._onmousedown);
                    break;
                case 'mousemove':
                    this._checkBind('mousemove', this._onmousemove);
                    break;
                case 'mouseup':
                    this._checkBind('mouseup', this._onmouseup);
                    break;
                case 'touchstart':
                    this._checkBind('touchstart', this._ontouchstart);
                    break;
                case 'touchmove':
                    this._checkBind('touchmove', this._ontouchmove);
                    break;
                case 'touchend':
                    this._checkBind('touchend', this._ontouchend);
                    break;
            }
            return this;
        };
        AbstractLayer.prototype.off = function (type, listener) {
            _super.prototype.off.call(this, type, listener);
            switch (type) {
                case 'click':
                    this._checkOff('click', this._onclick);
                    break;
                case 'mousedown':
                    this._checkOff('mousedown', this._onmousedown);
                    break;
                case 'mousemove':
                    this._checkOff('mousemove', this._onmousemove);
                    break;
                case 'mouseup':
                    this._checkOff('mouseup', this._onmouseup);
                    break;
                case 'touchstart':
                    this._checkOff('touchstart', this._ontouchstart);
                    break;
                case 'touchmove':
                    this._checkOff('touchmove', this._ontouchmove);
                    break;
                case 'touchend':
                    this._checkOff('touchend', this._ontouchend);
                    break;
            }
            return this;
        };
        AbstractLayer.prototype._checkBind = function (type, listener) {
            if (this._bindMap.has(type) || !this._engine)
                return;
            var listeners = this.getListeners(type);
            if (listeners && listeners.length !== 0) {
                this._engine.on(type, listener, { order: this._order, type: 'top' });
                this._bindMap.set(type, true);
            }
        };
        AbstractLayer.prototype._checkOff = function (type, listener) {
            var listeners = this.getListeners(type);
            if (!listeners || listeners.length === 0) {
                this._bindMap.delete(type);
                this._engine && this._engine.off(type, listener);
            }
        };
        AbstractLayer.prototype.setIgnoreMultiFade = function (flag) {
            this._ignoreMultiFade = flag;
        };
        AbstractLayer.prototype.getIgnoreMultiFade = function () {
            return this._ignoreMultiFade;
        };
        AbstractLayer.prototype.setVisible = function (bVisible) {
            this._layout.visible = bVisible;
        };
        AbstractLayer.prototype.getVisible = function () {
            return this._layout.visible;
        };
        AbstractLayer.prototype.setSync = function (sync) {
            this._isSync = sync;
        };
        AbstractLayer.prototype.getSync = function () {
            return this._isSync;
        };
        AbstractLayer.prototype.setAlwaysShow = function (alwaysShow) {
            this._alwaysShow = alwaysShow;
        };
        AbstractLayer.prototype.getAlwaysShow = function () {
            return this._alwaysShow;
        };
        AbstractLayer.prototype.getLayout = function () {
            return this._layout;
        };
        AbstractLayer.prototype.setMultiLayout = function (multiLayout) {
            this._multiLayout = __assign$1(__assign$1({}, this._multiLayout), multiLayout);
        };
        AbstractLayer.prototype.getMultiLayout = function () {
            return this._multiLayout;
        };
        AbstractLayer.prototype.setFeatures = function (features) {
            this._features = features;
            this._update();
            return this;
        };
        AbstractLayer.prototype.getFeatures = function () {
            return this._features;
        };
        AbstractLayer.prototype.resetLayout = function () {
            this._layout = __assign$1({}, this._lastLayout);
            this._update();
        };
        AbstractLayer.prototype.setFloorId = function (floorId) {
            this._floorId = floorId;
            this._groupId = floorId;
            return this;
        };
        AbstractLayer.prototype.getFloorId = function () {
            return this._floorId;
        };
        AbstractLayer.prototype.IsF1 = function () {
            if (this._floorId == null || this._floorId == undefined) {
                return false;
            }
            if (this._floorId.charAt(6) == 'F' && this._floorId.charAt(8) == '1') {
                return true;
            }
            else {
                return false;
            }
        };
        AbstractLayer.prototype.getShaderName = function () {
            return this._shaderName;
        };
        AbstractLayer.prototype.getType = function () {
            return this._type;
        };
        AbstractLayer.prototype.setName = function (name) {
            this._name = name;
            return this;
        };
        AbstractLayer.prototype.getName = function () {
            return this._name;
        };
        AbstractLayer.prototype.getOrder = function () {
            return this._order;
        };
        AbstractLayer.prototype.setOrder = function (order) {
            this._order = order;
        };
        AbstractLayer.prototype.setGroupId = function (groupId) {
            this._groupId = groupId;
        };
        AbstractLayer.prototype.getGroupId = function () {
            return this._groupId;
        };
        AbstractLayer.prototype.onAdd = function (engine) {
            var isHasAdd = Boolean(this._engine);
            this._engine = engine;
            this._checkBind('click', this._onclick);
            this._checkBind('mousedown', this._onmousedown);
            this._checkBind('mousemove', this._onmousemove);
            this._checkBind('mouseup', this._onmouseup);
            this._checkBind('touchstart', this._ontouchstart);
            this._checkBind('touchmove', this._ontouchmove);
            this._checkBind('touchend', this._ontouchend);
            if (!isHasAdd) {
                var bucketMng = this._engine.getBucketMng();
                bucketMng.register(this._id, this._onBucketChange);
                this._update();
            }
        };
        AbstractLayer.prototype.unbind = function () {
            if (this._engine) {
                this._engine.off('click', this._onclick);
                this._engine.off('mousedown', this._onmousedown);
                this._engine.off('mousemove', this._onmousemove);
                this._engine.off('mouseup', this._onmouseup);
                this._engine.off('touchstart', this._ontouchstart);
                this._engine.off('touchmove', this._ontouchmove);
                this._engine.off('touchend', this._ontouchend);
                this._bindMap.clear();
            }
        };
        AbstractLayer.prototype.onRemove = function () {
            this.clear();
            this.unbind();
            if (this._engine) {
                var bucketMng = this._engine.getBucketMng();
                bucketMng.unregister(this._id);
                delete this._engine;
            }
        };
        AbstractLayer.prototype._onBucketChange = function (data) {
            this._updateRenderList(data);
            if (this._engine) {
                data.isRender && this._engine.render();
                data.isUpdateCollision && this._engine.updateCollision();
            }
            this.OnRenderDataUpdated();
        };
        AbstractLayer.prototype.OnRenderDataUpdated = function () {
        };
        AbstractLayer.prototype._fireEvent = function (type, e) {
            var world = e.getWorld();
            var features = this.queryFeaturesByWorld(world.x, world.y);
            features.length !== 0 && this.fire(type, { e: e, features: features });
        };
        AbstractLayer.prototype._onclick = function (e) {
            !e.isCancel() && this._fireEvent('click', e);
        };
        AbstractLayer.prototype._onmousedown = function (e) {
            !e.isCancel() && this._fireEvent('mousedown', e);
        };
        AbstractLayer.prototype._onmousemove = function (e) {
            !e.isCancel() && this._fireEvent('mousemove', e);
        };
        AbstractLayer.prototype._onmouseup = function (e) {
            !e.isCancel() && this._fireEvent('mouseup', e);
        };
        AbstractLayer.prototype._ontouchstart = function (e) {
            !e.isCancel() && this._fireEvent('touchstart', e);
        };
        AbstractLayer.prototype._ontouchmove = function (e) {
            !e.isCancel() && this._fireEvent('touchmove', e);
        };
        AbstractLayer.prototype._ontouchend = function (e) {
            !e.isCancel() && this._fireEvent('touchend', e);
        };
        Object.defineProperty(AbstractLayer.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        AbstractLayer.prototype.UpdateLayer = function () {
            this._update();
        };
        AbstractLayer.prototype.QuickUpdateFeatureColor = function (featureId, colorString) {
        };
        return AbstractLayer;
    }(NCore$1));

    var AbstractBuffer = (function () {
        function AbstractBuffer(gl) {
            this.m_bInitSuccess = false;
            this._gl = gl;
        }
        AbstractBuffer.prototype._initArrayBuffer = function (buffer, data) {
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer);
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), this._gl.STATIC_DRAW);
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);
        };
        AbstractBuffer.prototype._initIndexBuffer = function (buffer, indices) {
            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, buffer);
            var uint16 = new Uint16Array(indices);
            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, uint16, this._gl.STATIC_DRAW);
            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, null);
        };
        AbstractBuffer.prototype._vertexAttribPointer = function (location, buffer, size) {
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer);
            var FSIZE = Float32Array.BYTES_PER_ELEMENT;
            if (location != -1) {
                this._gl.vertexAttribPointer(location, size, this._gl.FLOAT, false, FSIZE * size, 0);
                this._gl.enableVertexAttribArray(location);
            }
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);
        };
        AbstractBuffer.prototype.clear = function () {
        };
        return AbstractBuffer;
    }());

    var FillBuffer = (function (_super) {
        __extends$1(FillBuffer, _super);
        function FillBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this.fillIndicesNum = 0;
            _this.outlineIndicesNum = 0;
            _this._verticesBuffer = _this._gl.createBuffer();
            if (Global.m_bTextureEnable) {
                _this._texCoordBuffer = _this._gl.createBuffer();
            }
            _this._fillIndicesBuffer = _this._gl.createBuffer();
            _this._outlineIndicesBuffer = _this._gl.createBuffer();
            if (_this._verticesBuffer
                && _this._fillIndicesBuffer && _this._outlineIndicesBuffer) {
                _this.m_bInitSuccess = true;
            }
            return _this;
        }
        FillBuffer.prototype.clear = function () {
            if (this._verticesBuffer) {
                this._gl.deleteBuffer(this._verticesBuffer);
                this._verticesBuffer = null;
            }
            if (this._texCoordBuffer) {
                this._gl.deleteBuffer(this._texCoordBuffer);
                this._texCoordBuffer = null;
            }
            if (this._fillIndicesBuffer) {
                this._gl.deleteBuffer(this._fillIndicesBuffer);
                this._fillIndicesBuffer = null;
            }
            if (this._outlineIndicesBuffer) {
                this._gl.deleteBuffer(this._outlineIndicesBuffer);
                this._outlineIndicesBuffer = null;
            }
        };
        FillBuffer.prototype.update = function (data) {
            var vertices = data.vertices, fillIndices = data.fillIndices, outlineIndices = data.outlineIndices, texCoord = data.texCoord, texture = data.texture;
            if (this.m_bInitSuccess == false) {
                return;
            }
            this._initArrayBuffer(this._verticesBuffer, vertices);
            if (Global.m_bTextureEnable) {
                this._initArrayBuffer(this._texCoordBuffer, texCoord);
            }
            this._texture = texture;
            this.fillIndicesNum = fillIndices.length;
            this.outlineIndicesNum = outlineIndices.length;
            this._initIndexBuffer(this._fillIndicesBuffer, fillIndices);
            this._initIndexBuffer(this._outlineIndicesBuffer, outlineIndices);
        };
        FillBuffer.prototype.bindData = function (a_position, a_texCoord) {
            if (this.m_bInitSuccess == false) {
                return;
            }
            this._vertexAttribPointer(a_position, this._verticesBuffer, 2);
            if (Global.m_bTextureEnable) {
                this._vertexAttribPointer(a_texCoord, this._texCoordBuffer, 2);
            }
            else {
                this._vertexAttribPointer(a_texCoord, this._verticesBuffer, 2);
            }
            if (this._texture) {
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
            }
        };
        FillBuffer.prototype.bindIndices = function (indicesType) {
            if (this.m_bInitSuccess == false) {
                return;
            }
            if (indicesType === 'fill') {
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._fillIndicesBuffer);
            }
            else if (indicesType === 'outline') {
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._outlineIndicesBuffer);
            }
        };
        return FillBuffer;
    }(AbstractBuffer));

    var EPSILON = 1e-6;
    function contain(polygon, point) {
        var px = point[0], py = point[1];
        var flag = false;
        for (var m = 0; m < polygon.length; m += 1) {
            var face = polygon[m];
            for (var i = 0, l = face.length, j = l - 1; i < l; j = i, i++) {
                var sx = face[i][0];
                var sy = face[i][1];
                var tx = face[j][0];
                var ty = face[j][1];
                if ((sx === px && sy === py) || (tx === px && ty === py)) {
                    return true;
                }
                if ((sy < py && ty >= py) || (sy >= py && ty < py)) {
                    var x = sx + (py - sy) * (tx - sx) / (ty - sy);
                    if (Math.abs(x - px) <= EPSILON) {
                        return true;
                    }
                    if (x > px) {
                        flag = !flag;
                    }
                }
            }
        }
        return flag;
    }
    function measure(points) {
        var result = 0;
        var n = points.length - 1;
        for (var i = 0; i < n; i += 1) {
            result += (points[i][0] * points[i + 1][1] - points[i][1] * points[i + 1][0]) / 2;
        }
        result += (points[n][0] * points[0][1] - points[n][1] * points[0][0]) / 2;
        return Math.abs(result);
    }
    function measurePolygon(polygon) {
        var total = measure(polygon[0]);
        var divide = 0;
        for (var i = 1; i < polygon.length; i += 1) {
            divide += measure(polygon[i]);
        }
        return total - divide;
    }
    function equalCoordinate(coord1, coord2) {
        return coord1 && coord2 && coord1.x === coord2.x && coord1.y === coord2.y;
    }

    var AREA = /*#__PURE__*/Object.freeze({
        __proto__: null,
        EPSILON: EPSILON,
        contain: contain,
        measure: measure,
        measurePolygon: measurePolygon,
        equalCoordinate: equalCoordinate
    });

    var Line = (function () {
        function Line(start, end) {
            this._start = new Point(start[0], start[1]);
            this._end = new Point(end[0], end[1]);
        }
        Line.prototype.getVector2 = function () {
            var x = this._end.x - this._start.x;
            var y = this._end.y - this._start.y;
            return new Vector2([x, y]);
        };
        Line.prototype.getLength = function () {
            return this._start.distanceTo(this._end);
        };
        Line.prototype.getClosest = function (coordinate) {
            var x0 = coordinate.x, y0 = coordinate.y;
            var point = new Point(x0, y0);
            var vector = this.getVector2();
            var m = vector.x, n = vector.y;
            var _a = this._start, x1 = _a.x, y1 = _a.y;
            var _b = this._end, x2 = _b.x, y2 = _b.y;
            if (this.getLength() === 0) {
                var distance = point.distanceTo(this._start);
                return { distance: distance, coordinate: { x: x1, y: y1 } };
            }
            var y = (m * n * x0 - m * n * x1 + n * n * y0 + m * m * y1) / (n * n + m * m);
            var x;
            if (Math.abs(m) <= EPSILON) {
                x = (n * x1 + m * y - m * y1) / n;
            }
            else {
                x = (m * x0 - n * y + n * y0) / m;
            }
            if (this._checkIsInSegment(x, y)) {
                var resultPoint = new Point(x, y);
                var distance = resultPoint.distanceTo(point);
                return { distance: distance, coordinate: { x: x, y: y } };
            }
            else {
                var distance1 = point.distanceTo(this._start);
                var distance2 = point.distanceTo(this._end);
                if (distance1 < distance2) {
                    return { distance: distance1, coordinate: { x: x1, y: y1 } };
                }
                else {
                    return { distance: distance2, coordinate: { x: x2, y: y2 } };
                }
            }
        };
        Line.prototype.getStart = function () {
            return this._start;
        };
        Line.prototype.getEnd = function () {
            return this._end;
        };
        Line.prototype._checkIsInSegment = function (x, y) {
            return (x - this._start.x) * (x - this._end.x) <= EPSILON &&
                (y - this._start.y) * (y - this._end.y) <= EPSILON;
        };
        return Line;
    }());

    function polygonsContain(layout, features, point) {
        var result = [];
        for (var i = 0; i < features.length; i += 1) {
            var geometry = features[i].geometry;
            var visible = StyleUtils.getStyle(layout, 'visible', features[i].properties);
            if (visible) {
                if (geometry.type === 'Polygon') {
                    var isContain = contain(geometry.coordinates, [point.x, point.y]);
                    isContain && result.push(__assign$1(__assign$1({}, features[i]), { index: i }));
                }
                else if (geometry.type === 'MultiPolygon') {
                    for (var j = 0; j < geometry.coordinates.length; j += 1) {
                        var isContain = contain(geometry.coordinates[j], [point.x, point.y]);
                        if (isContain) {
                            result.push(__assign$1(__assign$1({}, features[i]), { index: i }));
                            break;
                        }
                    }
                }
            }
        }
        return result;
    }
    function pointsContain(layout, features, point, unit) {
        var result = [];
        var x = point.x, y = point.y;
        for (var i = 0; i < features.length; i += 1) {
            var _a = features[i], geometry = _a.geometry, properties = _a.properties;
            var visible = StyleUtils.getStyle(layout, 'visible', properties);
            var maxDis = (StyleUtils.getStyle(layout, 'radius', properties) || 5) * unit;
            if (visible) {
                if (geometry.type === 'Point') {
                    var _b = geometry.coordinates, x1 = _b[0], y1 = _b[1];
                    var dis = Math.sqrt(Math.pow((x - x1), 2) + Math.pow((y - y1), 2));
                    dis < maxDis && result.push(__assign$1(__assign$1({}, features[i]), { index: i, dis: dis }));
                }
                else if (geometry.type === 'MultiPoint') {
                    for (var j = 0; j < geometry.coordinates.length; j += 1) {
                        var _c = geometry.coordinates[j], x1 = _c[0], y1 = _c[1];
                        var dis = Math.sqrt(Math.pow((x - x1), 2) + Math.pow((y - y1), 2));
                        if (dis < maxDis) {
                            result.push(__assign$1(__assign$1({}, features[i]), { index: i, dis: dis }));
                            break;
                        }
                    }
                }
            }
        }
        return result;
    }
    function linesGetMinDis(lines, point) {
        var start = [lines[0][0], lines[0][1]];
        var end = [lines[1][0], lines[1][1]];
        var minDis = new Line(start, end).getClosest(point).distance;
        for (var i = 1; i < lines.length - 1; i += 1) {
            var itemStart = [lines[i][0], lines[i][1]];
            var itemEnd = [lines[i + 1][0], lines[i + 1][1]];
            var distance = new Line(itemStart, itemEnd).getClosest(point).distance;
            if (distance < minDis) {
                minDis = distance;
            }
        }
        return minDis;
    }
    function linesContain(layout, features, point, unit) {
        var result = [];
        for (var i = 0; i < features.length; i += 1) {
            var _a = features[i], geometry = _a.geometry, properties = _a.properties;
            var visible = StyleUtils.getStyle(layout, 'visible', properties);
            var lineWidth = StyleUtils.getStyle(layout, 'lineWidth', properties) || 0;
            var maxDis = Math.max(lineWidth, 10) / 2 * unit;
            if (visible) {
                if (geometry.type === 'LineString') {
                    var dis = linesGetMinDis(geometry.coordinates, point);
                    dis < maxDis && result.push(__assign$1(__assign$1({}, features[i]), { index: i }));
                }
                else if (geometry.type === 'MultiLineString') {
                    for (var j = 0; j < geometry.coordinates.length; j += 1) {
                        var dis = linesGetMinDis(geometry.coordinates[j], point);
                        if (dis < maxDis) {
                            result.push(__assign$1(__assign$1({}, features[i]), { index: i }));
                            break;
                        }
                    }
                }
            }
        }
        return result;
    }

    var ParkListener = (function () {
        function ParkListener() {
        }
        ParkListener.prototype.OnMessage = function (msg) {
            if (msg == null || msg == undefined) {
                return;
            }
            var msgJsonString = msg.data;
            if (msgJsonString == null || msgJsonString == undefined) {
                return;
            }
            var msgObj = JSON.parse(msgJsonString);
            if (msgObj == null || msgObj == undefined) {
                return;
            }
            switch (msgObj.msgId) {
                case 1001:
                    var parkInfoArray = msgObj.data;
                    this.OnUpdateParkInfo(parkInfoArray);
                    break;
            }
        };
        return ParkListener;
    }());

    var ParkingMgr = (function (_super) {
        __extends$1(ParkingMgr, _super);
        function ParkingMgr() {
            var _this = _super.call(this) || this;
            _this.m_stateColorStringMap = new Map();
            _this.m_parkInfoMap = new Map();
            return _this;
        }
        ParkingMgr.getInstance = function () {
            if (ParkingMgr.m_instance == null) {
                ParkingMgr.m_instance = new ParkingMgr();
            }
            return ParkingMgr.m_instance;
        };
        ParkingMgr.prototype.Init = function () {
            return;
        };
        ParkingMgr.prototype.requestAllParkInfo = function () {
        };
        ParkingMgr.prototype.GetParkColorStringByFeatureId = function (featureId) {
            var state = this.m_parkInfoMap.get(featureId);
            if (state == null || state == undefined) {
                return null;
            }
            return this.GetParkStateColorString(state);
        };
        ParkingMgr.prototype.SetParkStateColorString = function (state, color) {
            this.m_stateColorStringMap.set(state, color);
        };
        ParkingMgr.prototype.GetParkStateColorString = function (state) {
            return this.m_stateColorStringMap.get(state);
        };
        ParkingMgr.prototype.UpdateParkInfoToMapView = function () {
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined) {
                return;
            }
            var stateColorStringMap = this.m_stateColorStringMap;
            this.m_parkInfoMap.forEach(function (state, featureId) {
                var colorString = stateColorStringMap.get(state);
                if (colorString == null || colorString == undefined) ;
                else {
                    mapView.quickSetColorById(featureId, colorString);
                }
            });
            mapView.render();
        };
        ParkingMgr.prototype.SetParkInfo = function (featureId, state) {
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined) {
                return;
            }
            if (featureId == null || featureId == undefined) {
                return;
            }
            this.m_parkInfoMap.set(featureId, state);
            var colorString = this.m_stateColorStringMap.get(state);
            if (colorString == null || colorString == undefined) {
                return;
            }
            mapView.quickSetColorById(featureId, colorString);
        };
        ParkingMgr.prototype.OnUpdateParkInfo = function (parkInfoArray) {
            if (parkInfoArray == null || parkInfoArray == undefined) {
                return;
            }
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined) {
                return;
            }
            for (var i = 0; i < parkInfoArray.length; i++) {
                var park = parkInfoArray[i];
                var featureId = park.featureId;
                var state = park.state;
                this.GetParkStateColorString(state);
                this.m_parkInfoMap.set(featureId, state);
            }
        };
        ParkingMgr.prototype.Tick = function (dt) {
        };
        ParkingMgr.m_instance = null;
        return ParkingMgr;
    }(ParkListener));

    var FillLayer = (function (_super) {
        __extends$1(FillLayer, _super);
        function FillLayer(layout) {
            var _this = _super.call(this, 'Fill', __assign$1(__assign$1({}, FillLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._geometryRenderList = [];
            return _this;
        }
        FillLayer.prototype.clear = function () {
            this._features.length = 0;
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                var geo = this._geometryRenderList[i];
                geo.buffer.clear();
            }
            this._geometryRenderList.length = 0;
        };
        FillLayer.prototype.clearGeoRenderList = function () {
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                var geo = this._geometryRenderList[i];
                geo.buffer.clear();
            }
            this._geometryRenderList.length = 0;
        };
        FillLayer.prototype.OnRenderDataUpdated = function () {
            if (this._engine == null || this._engine == undefined) {
                return;
            }
            var mapView = this._engine.getMapView();
            if (mapView == null || mapView == undefined) {
                return;
            }
            mapView.OnRenderDataUpdated(this.getFloorId());
        };
        FillLayer.prototype._updateRenderList = function (data) {
            return __awaiter(this, void 0, void 0, function () {
                var info, textureMng, texCoordFactor, texture, mapView, i, buffer, bHasTexture, textureURL, fillColorString, fillColor;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._engine)
                                return [2];
                            this.clearGeoRenderList();
                            info = data.info;
                            textureMng = this._engine.getTextureMng();
                            texCoordFactor = 0.5;
                            texture = textureMng.getTexture('', FillLayer.TEXTURE_PARAMS);
                            textureMng.getTexture('', FillLayer.TEXTURE_PARAMS);
                            mapView = this._engine.getMapView();
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < info.length)) return [3, 6];
                            buffer = new FillBuffer(this._engine.getGl());
                            bHasTexture = false;
                            if (!mapView) return [3, 4];
                            textureURL = info[i].textureUrl;
                            if (!(textureURL !== undefined && textureURL !== '' && textureURL !== null)) return [3, 3];
                            bHasTexture = true;
                            texture = textureMng.getTexture(textureURL, FillLayer.TEXTURE_PARAMS);
                            if (!!texture) return [3, 3];
                            return [4, textureMng.loadTexture(textureURL, FillLayer.TEXTURE_PARAMS)];
                        case 2:
                            texture = _a.sent();
                            _a.label = 3;
                        case 3:
                            if (info[i] != null && info[i] != undefined) {
                                texCoordFactor = mapView.GetFeatureTextureCoordFactor(info[i].featureId);
                            }
                            _a.label = 4;
                        case 4:
                            fillColorString = ParkingMgr.getInstance().GetParkColorStringByFeatureId(info[i].featureId);
                            fillColor = [1, 1, 1, 1];
                            if (fillColorString == null || fillColorString == undefined || fillColorString == '') {
                                fillColor = info[i].fillColor;
                            }
                            else {
                                fillColor = StyleUtils.parseColor(fillColorString);
                            }
                            buffer.update({
                                fillIndices: info[i].fillIndices,
                                outlineIndices: info[i].outlineIndices,
                                vertices: info[i].vertices,
                                texCoord: info[i].texCoord,
                                zoomRange: info[i].zoomRange,
                                floorString: info[i].floorString,
                                texture: texture ? texture.texture : null,
                            });
                            this._geometryRenderList.push({
                                buffer: buffer,
                                outlineColor: info[i].outlineColor,
                                opacity: info[i].opacity,
                                base: info[i].base,
                                fillColor: fillColor,
                                zoomRange: info[i].zoomRange,
                                floorString: info[i].floorString,
                                bHasTexture: bHasTexture,
                                texCoordFactor: texCoordFactor,
                                featureId: info[i].featureId,
                                texture: texture ? texture.texture : null,
                                isF0: info[i].isF0,
                            });
                            _a.label = 5;
                        case 5:
                            i++;
                            return [3, 1];
                        case 6: return [2];
                    }
                });
            });
        };
        FillLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        FillLayer.prototype.queryFeaturesByWorld = function (x, y) {
            return polygonsContain(this._layout, this._features, { x: x, y: y });
        };
        FillLayer.prototype._update = function () {
            if (!this._engine)
                return;
            var mapView = this._engine.getMapView();
            if (mapView == null || mapView == undefined) {
                return;
            }
            var bucketMng = this._engine.getBucketMng();
            var bSync = this.getSync();
            var bOnly2d = this._engine.getMapView().getOnly2d();
            var useTexture = this._engine.getMapView().getTextureEnable();
            var chartletTable = mapView.GetChartletTable();
            var bTextureEnable = mapView.getTextureEnable();
            if (mapView.m_bucketTaskCount == 0) {
                mapView.setCanDraw(false);
                mapView.fire('FloorRenderDataStart', this._floorId);
            }
            mapView.m_bucketTaskCount++;
            bucketMng.update({
                type: 'fill',
                id: this.id,
                layout: this._layout,
                features: this._features,
                offset: this._engine.getOffset(),
                taskId: this._getTaskId(),
                sync: bSync,
                hideCategoryIdArray: [],
                hideColorIdArray: [],
                bOnly2d: bOnly2d,
                bCutFeature: useTexture,
                chartletTable: chartletTable,
                bTextureEnable: bTextureEnable,
            });
        };
        FillLayer.prototype.QuickUpdateFeatureColor = function (featureId, colorString) {
            if (featureId == null || featureId == undefined || colorString == null || colorString == undefined) {
                return;
            }
            var fillColorNumber = StyleUtils.parseColor(colorString);
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                var geo = this._geometryRenderList[i];
                if (geo.featureId == featureId) {
                    geo.fillColor = fillColorNumber;
                }
            }
        };
        FillLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        FillLayer.DEFAULT_LAYOUT = {
            visible: true,
            fillColor: '#666666',
            outlineColor: '#333333',
            enableOutline: true,
            base: 0,
            opacity: 1,
        };
        FillLayer.TEXTURE_PARAMS = { xRepeat: true, yRepeat: true };
        return FillLayer;
    }(AbstractLayer));

    var FillExtrusionBuffer = (function (_super) {
        __extends$1(FillExtrusionBuffer, _super);
        function FillExtrusionBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this.fillIndicesNum = 0;
            _this.outlineIndicesNum = 0;
            _this.sideIndicesNum = 0;
            _this.sideOutlineIndicesNum = 0;
            _this._verticesBuffer = _this._gl.createBuffer();
            _this._sideVerticesBuffer = _this._gl.createBuffer();
            _this._normalsBuffer = _this._gl.createBuffer();
            if (Global.m_bLowDisplay == false) {
                _this._sideNormalsBuffer = _this._gl.createBuffer();
            }
            if (Global.m_bTextureEnable) {
                _this._textureCoord = _this._gl.createBuffer();
                _this._sideTextureCoord = _this._gl.createBuffer();
            }
            _this._fillIndicesBuffer = _this._gl.createBuffer();
            _this._sideIndicesBuffer = _this._gl.createBuffer();
            _this._outlineIndicesBuffer = _this._gl.createBuffer();
            if (_this._verticesBuffer && _this._sideVerticesBuffer
                && _this._fillIndicesBuffer && _this._sideIndicesBuffer
                && _this._outlineIndicesBuffer) {
                _this.m_bInitSuccess = true;
            }
            return _this;
        }
        FillExtrusionBuffer.prototype.clear = function () {
            if (this._verticesBuffer) {
                this._gl.deleteBuffer(this._verticesBuffer);
                this._verticesBuffer = null;
            }
            if (this._sideVerticesBuffer) {
                this._gl.deleteBuffer(this._sideVerticesBuffer);
                this._sideVerticesBuffer = null;
            }
            if (this._textureCoord) {
                this._gl.deleteBuffer(this._textureCoord);
                this._textureCoord = null;
            }
            if (this._sideTextureCoord) {
                this._gl.deleteBuffer(this._sideTextureCoord);
                this._sideTextureCoord = null;
            }
            if (this._normalsBuffer) {
                this._gl.deleteBuffer(this._normalsBuffer);
                this._normalsBuffer = null;
            }
            if (this._sideNormalsBuffer) {
                this._gl.deleteBuffer(this._sideNormalsBuffer);
                this._sideNormalsBuffer = null;
            }
            if (this._fillIndicesBuffer) {
                this._gl.deleteBuffer(this._fillIndicesBuffer);
                this._fillIndicesBuffer = null;
            }
            if (this._sideIndicesBuffer) {
                this._gl.deleteBuffer(this._sideIndicesBuffer);
                this._sideIndicesBuffer = null;
            }
            if (this._outlineIndicesBuffer) {
                this._gl.deleteBuffer(this._outlineIndicesBuffer);
                this._outlineIndicesBuffer = null;
            }
        };
        FillExtrusionBuffer.prototype.update = function (data) {
            var vertices = data.vertices, normals = data.normals, fillIndices = data.fillIndices, outlineIndices = data.outlineIndices, texture = data.texture, texCoordArray = data.texCoordArray, sideVertices = data.sideVertices, sideIndices = data.sideIndices, sideTexture = data.sideTexture, sideNormals = data.sideNormals, sideTexCoordArray = data.sideTexCoordArray;
            if (this.m_bInitSuccess == false) {
                return;
            }
            this._initArrayBuffer(this._verticesBuffer, vertices);
            this._initArrayBuffer(this._sideVerticesBuffer, sideVertices);
            for (var i = 0; i < vertices.length; i++) {
            }
            if (Global.m_bTextureEnable) {
                this._initArrayBuffer(this._textureCoord, texCoordArray);
                this._initArrayBuffer(this._sideTextureCoord, sideTexCoordArray);
            }
            this._initArrayBuffer(this._normalsBuffer, normals);
            if (Global.m_bLowDisplay == false) {
                this._initArrayBuffer(this._sideNormalsBuffer, sideNormals);
            }
            this._texture = texture;
            this._sideTexture = sideTexture;
            this.fillIndicesNum = fillIndices.length;
            this.outlineIndicesNum = outlineIndices.length;
            this.sideIndicesNum = sideIndices.length;
            this.sideOutlineIndicesNum = outlineIndices.length;
            this._initIndexBuffer(this._fillIndicesBuffer, fillIndices);
            this._initIndexBuffer(this._sideIndicesBuffer, sideIndices);
            this._initIndexBuffer(this._outlineIndicesBuffer, outlineIndices);
        };
        FillExtrusionBuffer.prototype.bindSideFaceData = function (a_position, a_normal, a_texCoord) {
            if (this.m_bInitSuccess == false) {
                return;
            }
            this._vertexAttribPointer(a_position, this._sideVerticesBuffer, 3);
            if (Global.m_bLowDisplay) {
                this._vertexAttribPointer(a_normal, this._sideVerticesBuffer, 3);
            }
            else {
                this._vertexAttribPointer(a_normal, this._sideNormalsBuffer, 3);
            }
            if (a_texCoord != -1) {
                if (Global.m_bTextureEnable) {
                    this._vertexAttribPointer(a_texCoord, this._sideTextureCoord, 2);
                }
                else {
                    this._vertexAttribPointer(a_texCoord, this._sideVerticesBuffer, 2);
                }
            }
            if (this._sideTexture) {
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._sideTexture);
            }
        };
        FillExtrusionBuffer.prototype.bindSideIndices = function (indicesType) {
            if (this.m_bInitSuccess == false) {
                return;
            }
            if (indicesType === 'fill') {
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._sideIndicesBuffer);
            }
            else if (indicesType === 'outline') {
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._outlineIndicesBuffer);
            }
        };
        FillExtrusionBuffer.prototype.bindData = function (a_position, a_normal, a_texCoord) {
            if (this.m_bInitSuccess == false) {
                return;
            }
            this._vertexAttribPointer(a_position, this._verticesBuffer, 3);
            this._vertexAttribPointer(a_normal, this._normalsBuffer, 3);
            if (Global.m_bLowDisplay) {
                this._vertexAttribPointer(a_normal, this._normalsBuffer, 3);
            }
            else {
                this._vertexAttribPointer(a_normal, this._normalsBuffer, 3);
            }
            if (a_texCoord != -1) {
                if (Global.m_bTextureEnable) {
                    this._vertexAttribPointer(a_texCoord, this._sideTextureCoord, 2);
                }
                else {
                    this._vertexAttribPointer(a_texCoord, this._verticesBuffer, 2);
                }
            }
            if (this._texture) {
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
            }
        };
        FillExtrusionBuffer.prototype.bindIndices = function (indicesType) {
            if (this.m_bInitSuccess == false) {
                return;
            }
            if (indicesType === 'fill') {
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._fillIndicesBuffer);
            }
            else if (indicesType === 'outline') {
                this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._outlineIndicesBuffer);
            }
        };
        return FillExtrusionBuffer;
    }(AbstractBuffer));

    var FillExtrusionLayer = (function (_super) {
        __extends$1(FillExtrusionLayer, _super);
        function FillExtrusionLayer(layout) {
            var _this = _super.call(this, 'FillExtrusion', __assign$1(__assign$1({}, FillExtrusionLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._geometryRenderList = [];
            _this._collisionList = [];
            return _this;
        }
        FillExtrusionLayer.prototype.clear = function () {
            this._features.length = 0;
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                var geo = this._geometryRenderList[i];
                geo.buffer.clear();
            }
            this._geometryRenderList.length = 0;
        };
        FillExtrusionLayer.prototype.QuickUpdateFeatureColor = function (featureId, colorString) {
            if (featureId == null || featureId == undefined || colorString == null || colorString == undefined) {
                return;
            }
            var fillColorNumber = StyleUtils.parseColor(colorString);
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                var geo = this._geometryRenderList[i];
                if (geo.featureId == featureId) {
                    geo.fillColor = fillColorNumber;
                }
            }
        };
        FillExtrusionLayer.prototype.onAdd = function (engine) {
            _super.prototype.onAdd.call(this, engine);
            var collisionMng = engine.getCollisionMng();
            collisionMng.add(this.getCollisionData());
        };
        FillExtrusionLayer.prototype.getCollisionData = function () {
            return {
                data: this._collisionList,
                floorId: this.getGroupId(),
                id: this.id,
            };
        };
        FillExtrusionLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        FillExtrusionLayer.prototype.clearGeoRenderList = function () {
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                var geo = this._geometryRenderList[i];
                geo.buffer.clear();
            }
            this._geometryRenderList.length = 0;
        };
        FillExtrusionLayer.prototype.OnRenderDataUpdated = function () {
            if (this._engine == null || this._engine == undefined) {
                return;
            }
            var mapView = this._engine.getMapView();
            if (mapView == null || mapView == undefined) {
                return;
            }
            mapView.OnRenderDataUpdated(this.getFloorId());
        };
        FillExtrusionLayer.prototype._updateRenderList = function (data) {
            return __awaiter(this, void 0, void 0, function () {
                var info, texCoordFactor, textureMng, texture, sideTexture, mapView, i, buffer, bHasTexture, textureURL, sideTextureURL, fillColorString, fillColor;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._engine)
                                return [2];
                            this.clearGeoRenderList();
                            this._collisionList.length = 0;
                            info = data.info;
                            texCoordFactor = 1.0;
                            textureMng = this._engine.getTextureMng();
                            texture = textureMng.getTexture('', FillExtrusionLayer.TEXTURE_PARAMS);
                            sideTexture = textureMng.getTexture('', FillExtrusionLayer.TEXTURE_PARAMS);
                            mapView = this._engine.getMapView();
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < info.length)) return [3, 8];
                            buffer = new FillExtrusionBuffer(this._engine.getGl());
                            bHasTexture = false;
                            if (!mapView) return [3, 6];
                            if (mapView.IsExtraByColorId(info[i].colorId) == true) {
                                ExtraMgr.GetInstance().AddExtraInfo(info[i].featureId, 1.0);
                            }
                            textureURL = info[i].textureUrl;
                            if (!(textureURL != undefined && textureURL != '' && textureURL != null)) return [3, 3];
                            bHasTexture = true;
                            texture = textureMng.getTexture(textureURL, FillExtrusionLayer.TEXTURE_PARAMS);
                            if (!!texture) return [3, 3];
                            return [4, textureMng.loadTexture(textureURL, FillExtrusionLayer.TEXTURE_PARAMS)];
                        case 2:
                            texture = _a.sent();
                            _a.label = 3;
                        case 3:
                            sideTextureURL = info[i].sideTextureUrl;
                            if (!(sideTextureURL != undefined && sideTextureURL != "")) return [3, 5];
                            sideTexture = textureMng.getTexture(sideTextureURL, FillExtrusionLayer.TEXTURE_PARAMS);
                            if (!!sideTexture) return [3, 5];
                            return [4, textureMng.loadTexture(sideTextureURL, FillExtrusionLayer.TEXTURE_PARAMS)];
                        case 4:
                            sideTexture = _a.sent();
                            _a.label = 5;
                        case 5:
                            texCoordFactor = mapView.GetFeatureTextureCoordFactor(info[i].featureId);
                            _a.label = 6;
                        case 6:
                            buffer.update({
                                vertices: info[i].vertices,
                                sideVertices: info[i].sideVertices,
                                normals: info[i].normals,
                                sideNormals: info[i].sideNormals,
                                fillIndices: info[i].fillIndices,
                                sideIndices: info[i].sideIndices,
                                outlineIndices: info[i].outlineIndices,
                                texture: texture ? texture.texture : null,
                                zoomRange: info[i].zoomRange,
                                floorString: info[i].floorString,
                                featureId: info[i].featureId,
                                texCoordArray: info[i].texCoordArray,
                                sideTexCoordArray: info[i].sideTexCoordArray,
                                sideTexture: sideTexture ? sideTexture.texture : null,
                                bHasTexture: bHasTexture,
                                texCoordFactor: texCoordFactor,
                            });
                            fillColorString = ParkingMgr.getInstance().GetParkColorStringByFeatureId(info[i].featureId);
                            fillColor = [1, 1, 1, 1];
                            if (fillColorString == null || fillColorString == undefined || fillColorString == '') {
                                fillColor = info[i].fillColor;
                            }
                            else {
                                fillColor = StyleUtils.parseColor(fillColorString);
                            }
                            this._geometryRenderList.push({
                                buffer: buffer,
                                height: info[i].height,
                                base: info[i].base,
                                opacity: info[i].opacity,
                                fillColor: fillColor,
                                outlineColor: info[i].outlineColor,
                                texture: texture ? texture.texture : null,
                                stops: info[i].stops,
                                zoomRange: info[i].zoomRange,
                                floorString: info[i].floorString,
                                featureId: info[i].featureId,
                                texCoordArray: info[i].texCoordArray,
                                sideTexCoordArray: info[i].sideTexCoordArray,
                                sideTexture: sideTexture ? sideTexture.texture : null,
                                bHasTexture: bHasTexture,
                                texCoordFactor: texCoordFactor,
                                isF0: info[i].isF0,
                            });
                            _a.label = 7;
                        case 7:
                            i += 1;
                            return [3, 1];
                        case 8: return [2];
                    }
                });
            });
        };
        FillExtrusionLayer.prototype.queryFeaturesByWorld = function (x, y) {
            return polygonsContain(this._layout, this._features, { x: x, y: y });
        };
        FillExtrusionLayer.prototype.TrimFeature = function () {
            for (var i = 0; i < this._features.length; i++) {
                var feature = this._features[0];
                if (feature.properties) {
                    if (Global.getInstance().IsHideFeature(feature.properties.categoryid) == true) {
                        this._features.splice(i, 1);
                        i--;
                    }
                }
            }
        };
        FillExtrusionLayer.prototype._update = function () {
            if (!this._engine)
                return;
            var mapView = this._engine.getMapView();
            if (mapView == null || mapView == undefined) {
                return;
            }
            var bSync = this.getSync();
            var bOnly2d = mapView.getOnly2d();
            var useTexture = mapView.getTextureEnable();
            var bucketMng = this._engine.getBucketMng();
            var chartletTable = mapView.GetChartletTable();
            var bTextureEnable = mapView.getTextureEnable();
            if (mapView.m_bucketTaskCount == 0) {
                mapView.setCanDraw(false);
                mapView.fire('FloorRenderDataStart', this._floorId);
            }
            mapView.m_bucketTaskCount++;
            bucketMng.update({
                type: 'fillExtrusion',
                layout: this._layout,
                offset: this._engine.getOffset(),
                features: this._features,
                id: this.id,
                taskId: this._getTaskId(),
                sync: bSync,
                hideCategoryIdArray: Global.getInstance().GetHideCategoryIdArray(),
                hideColorIdArray: Global.getInstance().GetHideColorIdArray(),
                bOnly2d: bOnly2d,
                bCutFeature: useTexture,
                chartletTable: chartletTable,
                bTextureEnable: bTextureEnable,
            });
        };
        FillExtrusionLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        FillExtrusionLayer.DEFAULT_LAYOUT = {
            visible: true,
            fillColor: '#666666',
            outlineColor: '#333333',
            enableOutline: true,
            base: 0,
            opacity: 1,
            height: 0,
        };
        FillExtrusionLayer.TEXTURE_PARAMS = { xRepeat: true, yRepeat: true };
        return FillExtrusionLayer;
    }(AbstractLayer));

    var SymbolBuffer = (function (_super) {
        __extends$1(SymbolBuffer, _super);
        function SymbolBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this.m_bCanDeleteTexture = false;
            _this.verticesNum = 0;
            _this._verticesBuffer = _this._gl.createBuffer();
            _this._texCoordBuffer = _this._gl.createBuffer();
            if (_this._verticesBuffer && _this._texCoordBuffer) {
                _this.m_bInitSuccess = true;
            }
            return _this;
        }
        SymbolBuffer.prototype.clear = function () {
            if (this._verticesBuffer) {
                this._gl.deleteBuffer(this._verticesBuffer);
                this._verticesBuffer = null;
            }
            if (this._texCoordBuffer) {
                this._gl.deleteBuffer(this._texCoordBuffer);
                this._texCoordBuffer = null;
            }
            if (this._texture && this.m_bCanDeleteTexture == true && false) {
                this._gl.deleteTexture(this._texture);
                this._texture = null;
            }
        };
        SymbolBuffer.prototype.setGlyphMng = function (glyphMng) {
            this._glyphMng = glyphMng;
        };
        SymbolBuffer.prototype.update = function (data) {
            if (this.m_bInitSuccess == false) {
                return;
            }
            var texture = data.texture, vertices = data.vertices, texCoords = data.texCoords, textOptions = data.textOptions;
            this.verticesNum = vertices.length / 2;
            this._texture = texture;
            this._textOptions = textOptions;
            this._initArrayBuffer(this._verticesBuffer, vertices);
            this._initArrayBuffer(this._texCoordBuffer, texCoords);
        };
        SymbolBuffer.prototype.bind = function (a_position, a_texCoord) {
            if (this.m_bInitSuccess == false) {
                return;
            }
            this._vertexAttribPointer(a_position, this._verticesBuffer, 2);
            this._vertexAttribPointer(a_texCoord, this._texCoordBuffer, 2);
            if (this._texture) {
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
            }
            else if (this._glyphMng && this._textOptions) {
                this._texture = this._glyphMng.getTexture(this._textOptions);
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
                this.m_bCanDeleteTexture = true;
            }
        };
        return SymbolBuffer;
    }(AbstractBuffer));

    var SymbolLayer = (function (_super) {
        __extends$1(SymbolLayer, _super);
        function SymbolLayer(layout) {
            var _this = _super.call(this, 'Symbol', __assign$1(__assign$1({}, SymbolLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._dataItemList = [];
            _this._geometryRenderList = [];
            _this._collisionList = [];
            _this._collisionRenderList = [];
            _this._loadPromiseSet = new Set();
            _this._collisionIndices = [];
            bindAll([
                '_onCollisionChange',
            ], _this);
            return _this;
        }
        SymbolLayer.prototype._onCollisionChange = function (e) {
            var showResult = e.showResult, normalResult = e.normalResult;
            var showArr = showResult[this.id] || [];
            var normalArr = normalResult[this.id] || [];
            this._collisionIndices = showArr.concat(normalArr);
        };
        SymbolLayer.prototype.clear = function () {
            LogMgr$1.log('SymbolLayer.ts clear 1');
            this._features.length = 0;
            this._collisionList.length = 0;
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                var geoArray = this._geometryRenderList[i];
                for (var j = 0; j < geoArray.length; j++) {
                    var geo = geoArray[j];
                    geo.buffer.clear();
                }
            }
            this._geometryRenderList.length = 0;
            for (var i = 0; i < this._collisionRenderList.length; i++) {
                var geoArray = this._collisionRenderList[i];
                for (var j = 0; j < geoArray.length; j++) {
                    var geo = geoArray[j];
                    geo.buffer.clear();
                }
            }
            this._collisionRenderList.length = 0;
        };
        SymbolLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        SymbolLayer.prototype.onAdd = function (engine) {
            _super.prototype.onAdd.call(this, engine);
            var collisionMng = engine.getCollisionMng();
            collisionMng.add(this.getCollisionData());
            collisionMng.on('change', this._onCollisionChange);
        };
        SymbolLayer.prototype.unbind = function () {
            if (this._engine) {
                var collisionMng = this._engine.getCollisionMng();
                collisionMng.remove(this.getCollisionData());
                collisionMng.off('change', this._onCollisionChange);
            }
            _super.prototype.unbind.call(this);
        };
        SymbolLayer.prototype.UpdateTopSymbolFeatures = function (features) {
            if (features == null || features == undefined) {
                return;
            }
            if (this._features == null || this._features == undefined) {
                this._features = new Array();
            }
            for (var i = 0; i < features.length; i++) {
                var feature1 = features[i];
                var bFind = false;
                for (var j = 0; j < this._features.length; j++) {
                    var feature2 = this._features[j];
                    if (feature1.properties == null || feature1.properties == undefined
                        || feature2.properties == null || feature2.properties == undefined) {
                        bFind = true;
                        break;
                    }
                    if (feature1.properties.id == feature2.properties.id) {
                        bFind = true;
                        break;
                    }
                }
                if (bFind == false) {
                    this._features.push(feature1);
                }
                this._update();
            }
        };
        SymbolLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        SymbolLayer.prototype.getCollisionRenderList = function () {
            return this._collisionRenderList;
        };
        SymbolLayer.prototype.getCollisionData = function () {
            return {
                data: this._collisionList,
                floorId: this.getGroupId(),
                id: this.id,
            };
        };
        SymbolLayer.prototype.queryFeaturesByWorld = function (x, y) {
            if (!this._engine)
                return [];
            var screen = this._engine.getCamera().worldToScreenCoordinate(x, y);
            var result = [];
            var collisionSet = new Set(this._collisionIndices);
            var index = 0;
            for (var i = 0; i < this._dataItemList.length; i += 1) {
                var properties = this._dataItemList[i].properties;
                var visible = StyleUtils.getStyle(this._layout, 'visible', properties);
                var collision = StyleUtils.getStyle(this._layout, 'collision', properties);
                if (visible) {
                    if (!collision || collisionSet.has(index)) {
                        this._checkDataItem(this._dataItemList[i], screen) &&
                            result.push({
                                type: this._dataItemList[i].type,
                                geometry: this._dataItemList[i].geometry,
                                properties: this._dataItemList[i].properties,
                                index: i,
                            });
                    }
                    index += 1;
                }
            }
            return result;
        };
        SymbolLayer.prototype._checkDataItem = function (feature, screen) {
            if (!this._engine)
                return false;
            var textBaseSize = this._engine.getGlyphMng().getBaseSize();
            var textSize = feature.textSize, iconSize = feature.iconSize, properties = feature.properties;
            var textOffset = StyleUtils.getStyle(this._layout, 'textOffset', properties);
            var textAnchor = StyleUtils.getStyle(this._layout, 'textAnchor', properties);
            var textScale = StyleUtils.getStyle(this._layout, 'textSize', properties) / textBaseSize;
            var iconAnchor = StyleUtils.getStyle(this._layout, 'iconAnchor', properties);
            var iconOffset = StyleUtils.getStyle(this._layout, 'iconOffset', properties);
            var iconScale = StyleUtils.getStyle(this._layout, 'iconSize', properties);
            return (textSize && this._check(feature, screen, textAnchor, textOffset, textSize, textScale)) ||
                (iconSize && this._check(feature, screen, iconAnchor, iconOffset, iconSize, iconScale));
        };
        SymbolLayer.prototype._check = function (feature, screen, anchor, offset, bounds, scale) {
            if (!this._engine)
                return false;
            var size = [bounds[0] * scale, bounds[1] * scale];
            var geometry = feature.geometry;
            if (geometry.type === 'Point') {
                var point = this._engine.getCamera().worldToScreenCoordinate(geometry.coordinates[0], geometry.coordinates[1]);
                var bounds_1 = createScreenBounds([point.x - offset[0], point.y - offset[1]], size[0], size[1], anchor);
                return SymbolLayer.checkInBounds(screen, bounds_1);
            }
            else if (geometry.type === 'MultiPoint') {
                for (var j = 0; j < geometry.coordinates.length; j += 1) {
                    var point = this._engine.getCamera().worldToScreenCoordinate(geometry.coordinates[j][0], geometry.coordinates[j][1]);
                    var bounds_2 = createScreenBounds([point.x - offset[0], point.y - offset[1]], size[0], size[1], anchor);
                    if (SymbolLayer.checkInBounds(screen, bounds_2))
                        return true;
                }
            }
            return false;
        };
        SymbolLayer.prototype.clearGeoRenderList = function () {
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                var geoArray = this._geometryRenderList[i];
                for (var j = 0; j < geoArray.length; j++) {
                    var geo = geoArray[j];
                    geo.buffer.clear();
                }
            }
            this._geometryRenderList.length = 0;
        };
        SymbolLayer.prototype.clearGeoCollisionRenderList = function () {
            for (var i = 0; i < this._collisionRenderList.length; i++) {
                var geoArray = this._collisionRenderList[i];
                for (var j = 0; j < geoArray.length; j++) {
                    var geo = geoArray[j];
                    geo.buffer.clear();
                }
            }
            this._collisionRenderList.length = 0;
        };
        SymbolLayer.prototype._updateRenderList = function (data) {
            if (!this._engine)
                return;
            this._collisionList.length = 0;
            this.clearGeoRenderList();
            this.clearGeoCollisionRenderList();
            var textureMng = this._engine.getTextureMng();
            var info = data.info;
            for (var i = 0; i < info.length; i += 1) {
                var _a = info[i], isCollision = _a.isCollision, collision = _a.collision;
                var arr = [];
                for (var j = 0; j < info[i].data.length; j += 1) {
                    var geometry = info[i].data[j];
                    var buffer = new SymbolBuffer(this._engine.getGl());
                    var texture = void 0;
                    if (geometry.iconUrl) {
                        var temp = textureMng.getTexture(geometry.iconUrl, SymbolLayer.TEXTURE_PARAMS);
                        if (temp) {
                            texture = temp.texture;
                        }
                    }
                    var height = 0;
                    if (info[i].height != null && info[i].height != undefined) {
                        height = info[i].height;
                    }
                    else {
                        height = MapView$1.GetInstance().GetSymbolHeight(info[i].featureId);
                    }
                    buffer.update({
                        vertices: geometry.vertices,
                        texCoords: geometry.texCoords,
                        texture: texture,
                        textOptions: geometry.textOptions,
                        floorString: info[i].floorString,
                    });
                    buffer.setGlyphMng(this._engine.getGlyphMng());
                    var render = {
                        point: geometry.point,
                        base: geometry.base,
                        opacity: geometry.opacity,
                        buffer: buffer,
                        offset: geometry.offset,
                        featureId: info[i].featureId,
                        height: height,
                        floorString: info[i].floorString,
                    };
                    arr.push(render);
                }
                if (isCollision) {
                    this._collisionList.push(collision);
                    this._collisionRenderList.push(arr);
                }
                else {
                    this._geometryRenderList.push(arr);
                }
            }
        };
        SymbolLayer.prototype._update = function () {
            var _this = this;
            if (!this._engine)
                return;
            var dataItemList = [];
            for (var i = 0; i < this._features.length; i += 1) {
                this._calcPoint(this._features[i], function (res) {
                    dataItemList.push(res);
                });
            }
            this._dataItemList = dataItemList;
            var bucketMng = this._engine.getBucketMng();
            var bOnly2d = this._engine.getMapView().getOnly2d();
            var bTextureEnable = this._engine.getMapView().getTextureEnable();
            var data = {
                type: 'symbol',
                layout: this._layout,
                features: this._dataItemList,
                offset: this._engine.getOffset(),
                baseTextSize: this._engine.getGlyphMng().getBaseSize(),
                id: this.id,
                taskId: this._getTaskId(),
                sync: this.getSync(),
                hideCategoryIdArray: Global.getInstance().GetHideCategoryIdArray(),
                hideColorIdArray: Global.getInstance().GetHideColorIdArray(),
                bOnly2d: bOnly2d,
                bCutFeature: false,
                chartletTable: [],
                bTextureEnable: bTextureEnable,
            };
            if (this._loadPromiseSet.size === 0) {
                bucketMng.update(data);
            }
            else {
                new Promise(function (resolve) {
                    Promise.all(_this._loadPromiseSet).then(resolve).catch(resolve);
                }).then(function () {
                    bucketMng.update(data);
                });
            }
        };
        SymbolLayer.prototype._calcPoint = function (feature, cb) {
            return __awaiter(this, void 0, void 0, function () {
                var glyphMng, textureMng, iconSize, textSize, textArr, iconUrl, tempTexture, promise_1, textFiled, text, textBounds;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._engine)
                                return [2];
                            glyphMng = this._engine.getGlyphMng();
                            textureMng = this._engine.getTextureMng();
                            iconUrl = StyleUtils.getStyle(this._layout, 'iconImage', feature.properties);
                            if (!iconUrl) return [3, 3];
                            tempTexture = textureMng.getTexture(iconUrl, SymbolLayer.TEXTURE_PARAMS);
                            if (!!tempTexture) return [3, 2];
                            promise_1 = textureMng.loadTexture(iconUrl, SymbolLayer.TEXTURE_PARAMS);
                            this._loadPromiseSet.add(promise_1);
                            promise_1.then(function () { return _this._loadPromiseSet.delete(promise_1); });
                            return [4, promise_1];
                        case 1:
                            tempTexture = _a.sent();
                            _a.label = 2;
                        case 2:
                            iconSize = [tempTexture.width, tempTexture.height];
                            _a.label = 3;
                        case 3:
                            textFiled = StyleUtils.getStyle(this._layout, 'textField', feature.properties);
                            if (textFiled && feature.properties &&
                                feature.properties[textFiled] !== undefined &&
                                feature.properties[textFiled] !== null) {
                                text = feature.properties[textFiled].toString();
                                textBounds = glyphMng.getTextBound(text);
                                textSize = [textBounds.width, textBounds.height];
                                textArr = textBounds.textArr;
                            }
                            cb(__assign$1(__assign$1({}, feature), { iconSize: iconSize,
                                textArr: textArr,
                                textSize: textSize, featureid: '' }));
                            return [2];
                    }
                });
            });
        };
        SymbolLayer.checkInBounds = function (point, bounds) {
            var leftBottom = bounds.leftBottom, rightTop = bounds.rightTop;
            return leftBottom[0] <= point.x && point.x <= rightTop[0] &&
                leftBottom[1] <= point.y && point.y <= rightTop[1];
        };
        SymbolLayer.DEFAULT_LAYOUT = {
            visible: true,
            base: 0,
            opacity: 1,
            weight: 0,
            margin: 0,
            iconAnchor: 'center',
            iconSize: 1,
            iconOffset: [0, 0],
            iconZHeight: 0,
            textColor: '#666666',
            textAnchor: 'center',
            textSize: 16,
            textOffset: [0, 0],
            textZHeight: 0,
        };
        SymbolLayer.TEXTURE_PARAMS = { xRepeat: false, yRepeat: false };
        return SymbolLayer;
    }(AbstractLayer));

    var HttpClient = (function () {
        function HttpClient(server) {
            if (server === void 0) { server = ''; }
            this._server = '';
            this.m_preNetworkRequestCallBack = null;
            this.m_postNetworkUnavailableCallBack = null;
            this._server = server;
            var mapView = MapView$1.GetInstance();
            if (mapView) {
                this.m_preNetworkRequestCallBack = mapView.GetPreNetworkRequestCallBack();
                this.m_postNetworkUnavailableCallBack = mapView.GetPostNetworkRequestCallBack();
            }
        }
        HttpClient.prototype._initXhr = function (name, options, method) {
            var xhr = new XMLHttpRequest();
            var url = this._server + name;
            if (options.query) {
                var arr = [];
                for (var key in options.query) {
                    arr.push(key + "=" + options.query[key]);
                }
                url += (/\?/.test(url) ? '&' : '?') + arr.join('&');
            }
            xhr.open(method.toUpperCase(), url, true);
            var data;
            if (options.json) {
                xhr.setRequestHeader('Content-Type', 'application/json;charset=utf-8');
                data = JSON.stringify(options.json);
            }
            if (options.form) {
                xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');
                data = JSON.stringify(options.form);
            }
            if (options.body) {
                data = options.body;
            }
            if (options.headers) {
                for (var key in options.headers) {
                    xhr.setRequestHeader(key, options.headers[key]);
                }
            }
            if (options.timeout) {
                xhr.timeout = options.timeout;
            }
            if (options.responseType) {
                xhr.responseType = options.responseType;
            }
            options.timeout && (xhr.timeout = options.timeout);
            xhr.send(data);
            return xhr;
        };
        HttpClient.prototype.SetPreNetworkRequestCallBack = function (callback) {
            this.m_preNetworkRequestCallBack = callback;
        };
        HttpClient.prototype.SetPostNetworkUnavailableCallBack = function (callback) {
            this.m_postNetworkUnavailableCallBack = callback;
        };
        HttpClient.prototype.get = function (name, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this._xhr = this._initXhr(name, options, 'GET');
                    return [2, this._packagePromise(this._xhr)];
                });
            });
        };
        HttpClient.prototype.delete = function (name, options) {
            if (options === void 0) { options = {}; }
            this._xhr = this._initXhr(name, options, 'DELETE');
            return this._packagePromise(this._xhr);
        };
        HttpClient.prototype.put = function (name, options) {
            if (options === void 0) { options = {}; }
            this._xhr = this._initXhr(name, options, 'PUT');
            return this._packagePromise(this._xhr);
        };
        HttpClient.prototype.post = function (name, options) {
            if (options === void 0) { options = {}; }
            this._xhr = this._initXhr(name, options, 'post');
            return this._packagePromise(this._xhr);
        };
        HttpClient.prototype.cancel = function () {
            this._xhr && this._xhr.abort();
        };
        HttpClient.prototype._packagePromise = function (xhr) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                xhr.onload = function () {
                    var resContentType = xhr.getResponseHeader('Content-Type') || '';
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        if (/application\/json/.test(resContentType) &&
                            typeof xhr.response === 'string') {
                            resolve(JSON.parse(xhr.response));
                        }
                        else {
                            resolve(xhr.response);
                        }
                    }
                    else {
                        reject(xhr.response);
                    }
                    delete _this._xhr;
                };
                xhr.onerror = function (err) {
                    reject(err);
                    delete _this._xhr;
                };
                xhr.ontimeout = function () {
                    reject(new Error('timeout'));
                    delete _this._xhr;
                };
                xhr.onabort = function () {
                    reject(new Error('褰撳墠缃戠粶娉㈠姩锛岃绋嶅悗閲嶈瘯'));
                    delete _this._xhr;
                };
            });
        };
        return HttpClient;
    }());

    var StyleManager = (function () {
        function StyleManager() {
        }
        StyleManager.prototype._loadStyle = function (style) {
            return __awaiter(this, void 0, void 0, function () {
                var res;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(typeof style === 'string')) return [3, 2];
                            return [4, new HttpClient().get(style)];
                        case 1:
                            res = _a.sent();
                            this._style = typeof res === 'string' ? JSON.parse(res) : res;
                            return [3, 3];
                        case 2:
                            this._style = style;
                            _a.label = 3;
                        case 3:
                            this._parseStyle();
                            return [2];
                    }
                });
            });
        };
        StyleManager.prototype.loadStyle = function (style) {
            var _this = this;
            this._loadPromise = this._loadStyle(style);
            this._loadPromise.then(function () { return delete _this._loadPromise; });
            return this._loadPromise;
        };
        StyleManager.prototype.updateStyle = function (style) {
            return __awaiter(this, void 0, void 0, function () {
                var oldStyle;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            oldStyle = this._style;
                            return [4, this._loadStyle(style)];
                        case 1:
                            _a.sent();
                            return [2, StyleManager.checkStyleDiff(oldStyle, this._style)];
                    }
                });
            });
        };
        StyleManager.prototype.getOriginStyle = function () {
            return this._style && __assign$1({}, this._style);
        };
        StyleManager.prototype._parseStyle = function () {
            if (!this._style)
                return;
            this._styleLayout = {
                mapBackgroundColor: this._style.mapBackgroundColor,
                frame: this._style.frame,
                area: __assign$1(__assign$1({}, this._style.area.default), { keys: this._style.area.style.keys, values: this._parseValues(this._style.area.style.values) }),
                facility: __assign$1(__assign$1({}, this._style.facility.default), { keys: this._style.facility.style.keys, values: this._parseValues(this._style.facility.style.values) }),
                areaText: __assign$1(__assign$1({}, this._style.areaText.default), { keys: this._style.areaText.style.keys, values: this._parseValues(this._style.areaText.style.values) }),
            };
            if (this._style.extra) {
                this._styleLayout.extra = __assign$1(__assign$1({}, this._style.extra.default), { keys: this._style.extra.style.keys, values: this._parseValues(this._style.extra.style.values) });
            }
        };
        StyleManager.prototype.filterExtra = function (properties) {
            if (!this._styleLayout || !this._styleLayout.extra || !properties)
                return false;
            var _a = this._styleLayout.extra, keys = _a.keys, values = _a.values;
            if (!keys || !values)
                return false;
            for (var i = 0; i < keys.length; i += 1) {
                if (values[properties[keys[i]]] !== undefined) {
                    return true;
                }
            }
            return false;
        };
        StyleManager.prototype._parseValues = function (values) {
            var result = {};
            for (var i = 0; i < values.length; i += 1) {
                var key = values[i].key;
                for (var j = 0; j < key.length; j += 1) {
                    var otherObj = __assign$1({}, values[i]);
                    delete otherObj.key;
                    result[key[j]] = __assign$1(__assign$1({}, result[key[j]]), otherObj);
                }
            }
            return result;
        };
        StyleManager.prototype.loaded = function () {
            return !this._loadPromise;
        };
        StyleManager.prototype.getLoadPromise = function () {
            return this._loadPromise;
        };
        StyleManager.prototype.getStyle = function (name) {
            if (!this._styleLayout)
                return;
            return this._styleLayout[name];
        };
        StyleManager.checkStyleDiff = function (oldStyle, newStyle) {
            if (!oldStyle) {
                return ['frame', 'area', 'areaText', 'facility', 'extra'];
            }
            var arr = [];
            if (!equalObject(oldStyle.frame, newStyle.frame)) {
                arr.push('frame');
            }
            if (!equalObject(oldStyle.area, newStyle.area)) {
                arr.push('area');
            }
            if (!equalObject(oldStyle.areaText, newStyle.areaText)) {
                arr.push('areaText');
            }
            if (!equalObject(oldStyle.facility, newStyle.facility)) {
                arr.push('facility');
            }
            if (!equalObject(oldStyle.extra, newStyle.extra)) {
                arr.push('extra');
            }
            return arr;
        };
        return StyleManager;
    }());

    var LayerName;
    (function (LayerName) {
        LayerName["frame"] = "frame";
        LayerName["area"] = "area";
        LayerName["facility"] = "facility";
        LayerName["areaText"] = "areaText";
        LayerName["extra"] = "extra";
    })(LayerName || (LayerName = {}));
    var AbstractView = (function (_super) {
        __extends$1(AbstractView, _super);
        function AbstractView(options) {
            var _this = _super.call(this) || this;
            _this._layers = new ArraySet();
            _this._tileLayers = new ArraySet();
            _this._outdoorLayers = new ArraySet();
            _this._styleMng = new StyleManager();
            _this._hasDrawFloorId = new Set();
            _this.m_isLoading = false;
            _this.m_loadingFloorId = '';
            _this.m_topSymbolLayer = null;
            bindAll([
                '_onResize',
                '_onMoveEnd',
            ], _this);
            _this._options = options;
            _this._viewType = _this._options.viewType;
            _this._defaultFloor = _this._options.defaultFloor;
            _this.on('moveEnd', _this._onMoveEnd);
            window.addEventListener('resize', _this._onResize);
            return _this;
        }
        AbstractView.prototype.init = function (container, style) {
            return __awaiter(this, void 0, void 0, function () {
                var bgColor;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._engine = new Engine(container, {
                                zoom: this._options.zoom,
                                rotate: this._options.rotate,
                                pitch: this._viewType === 'multiple' ? 60 : this._options.pitch,
                                lightPos: this._options.lightPos,
                                ambientColor: this._options.ambientColor,
                                ambientMaterial: this._options.ambientMaterial,
                                diffuseColor: this._options.diffuseColor,
                                diffuseMaterial: this._options.diffuseMaterial,
                                localFontFamily: this._options.localFontFamily,
                                fontWeight: this._options.fontWeight,
                                maxTextSize: this._options.maxTextSize,
                                textSplit: this._options.textSplit,
                            });
                            this._engine.getCamera().set({ center: this._options.center });
                            return [4, this._styleMng.loadStyle(style)];
                        case 1:
                            _a.sent();
                            bgColor = this._styleMng.getStyle('mapBackgroundColor');
                            if (bgColor) {
                                container.style.background = bgColor;
                            }
                            return [2];
                    }
                });
            });
        };
        AbstractView.prototype._onResize = function (e) {
            console.log('AbstractView _onResize');
            e.isTrusted && this.resize();
        };
        AbstractView.prototype.setTextField = function (textField) {
            var arr = this._outdoorLayers.valuesConcat(this._layers);
            for (var i = 0; i < arr.length; i += 1) {
                if (arr[i].getName() === LayerName.areaText) {
                    var layout = arr[i].getLayout();
                    layout.textField = textField;
                    arr[i].setLayout(layout);
                }
            }
            var style = this._styleMng.getOriginStyle();
            if (style) {
                style.areaText.default.textField = textField;
                this._styleMng.updateStyle(style);
            }
        };
        AbstractView.prototype.resize = function () {
            this._engine && this._engine.resize();
            this.fire('move');
        };
        AbstractView.prototype._onMoveEnd = function () {
            this._engine && this._engine.updateCollision();
            for (var i = 0; i < this._tileLayers.size(); i += 1) {
                this._tileLayers.get(i).loadTile();
            }
        };
        AbstractView.prototype.getViewType = function () {
            return this._viewType;
        };
        AbstractView.prototype._setupTileLayer = function () {
            if (!this._engine)
                return;
            for (var i = 0; i < this._tileLayers.size(); i += 1) {
                this._engine.addTileLayer(this._tileLayers.get(i));
            }
        };
        AbstractView.prototype._setupOffset = function (floorItem) {
            if (!this._engine)
                return;
            var camera = this._engine.getCamera();
            var _a = floorItem.center.coordinates, x = _a[0], y = _a[1], bounds = floorItem.bounds;
            this._options.enableBounds && camera.setMaxBounds(bounds && {
                topLeft: { x: bounds[0][0], y: bounds[1][1] },
                bottomRight: { x: bounds[1][0], y: bounds[0][1] },
            });
            this._engine.setOffset(-x, -y);
            if (!this._options.center) {
                camera.set({ center: { x: x, y: y } });
            }
        };
        AbstractView.prototype._update = function (floors) {
            var _this = this;
            if (!this._engine)
                return;
            this._engine.clear();
            var layerMap = new Map();
            for (var i = 0; i < floors.length; i += 1) {
                layerMap.set(floors[i].flId, []);
            }
            if (this._viewType === 'single') {
                for (var i = 0; i < this._outdoorLayers.size(); i += 1) {
                    this._processLayer(this._outdoorLayers.get(i), layerMap, true);
                }
            }
            for (var i = 0; i < this._layers.size(); i += 1) {
                if (this._checkIsNeedAdd(this._layers.get(i))) {
                    this._processLayer(this._layers.get(i), layerMap, false);
                }
            }
            layerMap.forEach(function (value) {
                for (var i = 0; i < value.length; i += 1) {
                    _this._engine.addLayer(value[i]);
                }
            });
            this._engine.sortLayer();
            ParkingMgr.getInstance().UpdateParkInfoToMapView();
            this._engine.render();
            this._engine.updateCollision();
        };
        AbstractView.prototype._processLayer = function (layer, layerMap, isOutdoor) {
            var groupId = this.currentFloor;
            if (this._viewType === 'multiple') {
                groupId = isOutdoor ? this._defaultFloor : layer.getFloorId();
                var base = this.getFloorHeight(groupId);
                layer.setMultiLayout({ base: base, opacity: this._getLayerMultiOpacity(layer) });
            }
            layer.setGroupId(groupId);
            var item = layerMap.get(groupId);
            item && item.push(layer);
        };
        AbstractView.prototype.render = function () {
            this._engine && this._engine.render();
        };
        AbstractView.prototype._getLayerMultiOpacity = function (layer, floors) {
            var itemFloor = layer.getFloorId();
            var floorSet = new Set(floors);
            itemFloor = AbstractView.OUT_REG.test(itemFloor) ? this._defaultFloor : itemFloor;
            return (itemFloor === this.currentFloor || (floorSet.has(itemFloor))
                || layer.getIgnoreMultiFade()) ? 1 : this._options.multiFadeOpacity;
        };
        AbstractView.prototype._drawPlanarGraphLayer = function (floorId, planarGraph) {
            if (this._hasDrawFloorId.has(floorId))
                return;
            var frame = planarGraph.frame, area = planarGraph.area; planarGraph.facility; var shop = planarGraph.shop;
            this._drawFrame(frame, floorId);
            var _a = this._drawArea(area.concat(shop), floorId), text = _a.text, extra = _a.extra;
            this._drawAreaText(text, floorId);
            this._drawExtra(extra, floorId);
            if (this._options.isExtra) {
                this._drawExtra(extra, floorId);
            }
            this._hasDrawFloorId.add(floorId);
        };
        AbstractView.prototype._drawFrame = function (features, floorId) {
            if (!this._styleMng)
                return;
            var frameStyle = this._styleMng.getStyle('frame');
            if (!frameStyle)
                return;
            var layer;
            if (frameStyle.height === 0) {
                layer = new FillLayer(frameStyle);
            }
            else {
                layer = new FillExtrusionLayer(frameStyle);
            }
            layer.setFeatures(features).setFloorId(floorId).setName(LayerName.frame);
            if (AbstractView.OUT_REG.test(floorId)) {
                this._outdoorLayers.set(layer);
            }
            else {
                if (this.GetFillExtrusionFloorCount() >= Global.m_maxFloorCachedAllowed) {
                    this.RemoveUnusedFloor(floorId);
                }
                this._layers.set(layer);
            }
        };
        AbstractView.prototype.GetFillExtrusionFloorCount = function () {
            var count = 0;
            for (var i = 0; i < this._layers.size(); i++) {
                if (this._layers.get(i).getType() == 'FillExtrusion') {
                    count++;
                }
            }
            return count;
        };
        AbstractView.prototype.RemoveUnusedFloor = function (newFloorId) {
            this._engine.getMapView();
            for (var i = 0; i < this._layers.size(); i++) {
                var layer = this._layers.get(i);
                if (layer.getType() == 'FillExtrusion') {
                    var oldFloorId = layer.getFloorId();
                    if (oldFloorId != newFloorId) {
                        layer.clear();
                        layer.clearRegister();
                        this._removeLayer(layer);
                        for (var j = 0; j < this._layers.size(); j++) {
                            var layer2 = this._layers.get(j);
                            if (layer2.getFloorId() == oldFloorId
                                && (layer2.getType() == 'FillExtrusion')) {
                                layer2.clear();
                                layer2.clearRegister();
                                this._removeLayer(layer2);
                            }
                        }
                        this._hasDrawFloorId.delete(oldFloorId);
                        break;
                    }
                }
            }
        };
        AbstractView.prototype._drawArea = function (features, floorId) {
            var _this = this;
            if (!this._styleMng)
                return { text: [], extra: [] };
            var areaStyle = this._styleMng.getStyle('area');
            if (!areaStyle)
                return { text: [], extra: [] };
            var fillFeatures = [];
            var fillExtrusionFeatures = [];
            var areaTextFeatures = [];
            var extraFeatures = [];
            for (var i = 0; i < features.length; i += 1) {
                var properties = features[i].properties;
                var height = StyleUtils.getStyle(areaStyle, 'height', properties);
                height === 0 ? fillFeatures.push(features[i]) : fillExtrusionFeatures.push(features[i]);
                var point = properties && (properties.labelpoint || properties.center);
                point && areaTextFeatures.push(createFeaturePoint(point, properties));
                if (this._styleMng.filterExtra(properties)) {
                    extraFeatures.push(features[i]);
                }
            }
            if (fillFeatures.length !== 0) {
                step(fillFeatures, AbstractView.MAX_STEP, function (item) {
                    var layer = new FillLayer(areaStyle);
                    layer.setFeatures(item).setName(LayerName.area).setFloorId(floorId);
                    if (AbstractView.OUT_REG.test(floorId)) {
                        _this._outdoorLayers.set(layer);
                    }
                    else {
                        if (_this.GetFillExtrusionFloorCount() >= Global.m_maxFloorCachedAllowed) {
                            _this.RemoveUnusedFloor(floorId);
                        }
                        _this._layers.set(layer);
                    }
                });
            }
            if (fillExtrusionFeatures.length !== 0) {
                step(fillExtrusionFeatures, AbstractView.MAX_STEP, function (item) {
                    var layer = new FillExtrusionLayer(areaStyle);
                    layer.setFeatures(item).setName(LayerName.area).setFloorId(floorId);
                    if (AbstractView.OUT_REG.test(floorId)) {
                        _this._outdoorLayers.set(layer);
                    }
                    else {
                        if (_this.GetFillExtrusionFloorCount() >= Global.m_maxFloorCachedAllowed) {
                            _this.RemoveUnusedFloor(floorId);
                        }
                        _this._layers.set(layer);
                    }
                });
            }
            return { text: areaTextFeatures, extra: extraFeatures };
        };
        AbstractView.prototype.GetModelTextByFeature = function (feature) {
            return null;
        };
        AbstractView.prototype._drawAreaText = function (features, floorId) {
            if (!this._styleMng || features.length === 0)
                return;
            var areaTextStyle = this._styleMng.getStyle('areaText');
            if (!areaTextStyle)
                return;
            var bFind = false;
            for (var i = 0; i < this._layers.size(); i++) {
                var layer = this._layers.get(i);
                if (layer.getFloorId() == floorId && layer.getType() == 'Symbol' && layer.getName() == LayerName.areaText) {
                    bFind = true;
                    break;
                }
            }
            if (bFind == false) {
                var topSymbolFeatures = [];
                for (var i = 0; i < features.length; i++) {
                    var feature = features[i];
                    var model = this.GetModelTextByFeature(feature);
                    if (model != null) {
                        feature.properties.height = model.height;
                        feature.properties.nameCn = model.nameCn;
                        feature.properties.categoryId = model.categoryId;
                        topSymbolFeatures.push(feature);
                        features.splice(i, 1);
                        i--;
                    }
                }
                var layer = new SymbolLayer(areaTextStyle);
                layer.setFeatures(features).setName(LayerName.areaText).setFloorId(floorId);
                AbstractView.OUT_REG.test(floorId) ?
                    this._outdoorLayers.set(layer) :
                    this._layers.set(layer);
                if (this.m_topSymbolLayer != null && this.m_topSymbolLayer != undefined) {
                    this.m_topSymbolLayer.UpdateTopSymbolFeatures(topSymbolFeatures);
                    this.m_topSymbolLayer.setName(LayerName.areaText);
                    this.m_topSymbolLayer.setFloorId('topSymbolLayer');
                    this.m_topSymbolLayer.setAlwaysShow(true);
                }
            }
        };
        AbstractView.prototype.IsTopSymbolFeature = function (feature) {
            if (feature == null || feature == undefined) {
                return false;
            }
            return false;
        };
        AbstractView.prototype._drawFacility = function (features, floorId) {
            if (!this._styleMng || features.length === 0)
                return;
            var facilityStyle = this._styleMng.getStyle('facility');
            if (!facilityStyle)
                return;
            var layer = new SymbolLayer(facilityStyle);
            layer.setFeatures(features).setName(LayerName.facility).setFloorId(floorId);
            AbstractView.OUT_REG.test(floorId) ?
                this._outdoorLayers.set(layer) :
                this._layers.set(layer);
        };
        AbstractView.prototype._drawExtra = function (features, floorId) {
            if (!this._styleMng || features.length === 0)
                return;
            var extraStyle = this._styleMng.getStyle('extra');
            if (!extraStyle)
                return;
            var layer = new FillExtrusionLayer(extraStyle);
            layer.setFeatures(features).setName(LayerName.extra).setFloorId(floorId);
            layer.setOrder(9);
            AbstractView.OUT_REG.test(floorId) ?
                this._outdoorLayers.set(layer) :
                this._layers.set(layer);
        };
        AbstractView.prototype.jumpTo = function (params) {
            if (params === void 0) { params = {}; }
            if (!this._engine)
                return;
            var camera = this._engine.getCamera();
            var center = params.center, zoom = params.zoom, rotate = params.rotate, pitch = params.pitch, _a = params.offset, offset = _a === void 0 ? [0, 0] : _a;
            var cameraOptions = {};
            if (typeof zoom === 'number' && zoom > 0) {
                cameraOptions.zoom = clamp(zoom, this._options.minZoom, this._options.maxZoom);
            }
            if (typeof rotate === 'number') {
                cameraOptions.rotate = rotate;
            }
            if (typeof pitch === 'number') {
                cameraOptions.pitch = pitch;
            }
            var pointAtOffset = camera.centerPoint.add(new Point(offset[0], offset[1]));
            var locationAtOffset = camera.screenToWorldCoordinate(pointAtOffset.x, pointAtOffset.y);
            var endCenter = center ? new Point(center.x, center.y) : locationAtOffset.clone();
            camera.set(cameraOptions);
            camera.setCenterAtPoint(endCenter, pointAtOffset);
            this._engine.render();
            this._fireEvent(params, 'Start');
            this._fireEvent(params, '');
            this._fireEvent(params, 'End');
        };
        AbstractView.prototype.setCenterByOffset = function (center, offset) {
            if (!this._engine)
                return;
            var camera = this._engine.getCamera();
            var pointAtOffset = camera.centerPoint.add(new Point(offset[0], offset[1]));
            var locationAtOffset = camera.screenToWorldCoordinate(pointAtOffset.x, pointAtOffset.y);
            var endCenter = center ? new Point(center.x, center.y) : locationAtOffset.clone();
            camera.set({ center: center });
            camera.setCenterAtPoint(endCenter, pointAtOffset);
            this._engine.render();
            this._engine.updateCollision(false);
            this.fire('move');
        };
        AbstractView.prototype._fireEvent = function (params, suffix) {
            var zoom = params.zoom, rotate = params.rotate, pitch = params.pitch;
            this.fire("move" + suffix);
            typeof zoom === 'number' && zoom > 0 && this.fire("zoom" + suffix);
            typeof rotate === 'number' && this.fire("rotate" + suffix);
            typeof pitch === 'number' && this.fire("pitch" + suffix);
        };
        AbstractView.prototype.setMaxZoom = function (maxZoom) {
            var minZoom = this._options.minZoom;
            if (maxZoom <= minZoom) {
                console.warn('maxZoom 闇€瑕佸ぇ浜� minZoom ');
                return;
            }
            this._options.maxZoom = maxZoom;
            var zoom = this.getZoom();
            if (typeof zoom === 'number' && zoom > maxZoom) {
                this.jumpTo({ zoom: maxZoom });
            }
        };
        AbstractView.prototype.setMinZoom = function (minZoom) {
            var maxZoom = this._options.maxZoom;
            if (minZoom >= maxZoom) {
                console.warn('minZoom 闇€瑕佸皬浜� maxZoom');
                return;
            }
            this._options.minZoom = minZoom;
            var zoom = this.getZoom();
            if (typeof zoom === 'number' && zoom < minZoom) {
                this.jumpTo({ zoom: minZoom });
            }
        };
        AbstractView.prototype.getMaxZoom = function () {
            return this._options.maxZoom;
        };
        AbstractView.prototype.getMinZoom = function () {
            return this._options.minZoom;
        };
        AbstractView.prototype.getZoom = function () {
            return this._engine && this._engine.getCamera().getZoom();
        };
        AbstractView.prototype.setZoom = function (zoom) {
            this.jumpTo({ zoom: zoom });
        };
        AbstractView.prototype.zoomIn = function () {
            if (!this._engine)
                return;
            var startZoom = this._engine.getCamera().getZoom();
            var endZoom = clamp(startZoom + 1, this._options.minZoom, this._options.maxZoom);
            this.easeTo({ zoom: endZoom, duration: 550 });
        };
        AbstractView.prototype.zoomOut = function () {
            if (!this._engine)
                return;
            var startZoom = this._engine.getCamera().getZoom();
            var endZoom = clamp(startZoom - 1, this._options.minZoom, this._options.maxZoom);
            this.easeTo({ zoom: endZoom, duration: 550 });
        };
        AbstractView.prototype.easeTo = function (params) {
            if (params === void 0) { params = {}; }
            this._animator && this._animator.stop();
            this._animator = this._easeTo(params);
            LogMgr$1.log('AbstractView easeTo 1 ' + params);
        };
        AbstractView.prototype._easeTo = function (params) {
            var _this = this;
            if (params === void 0) { params = {}; }
            if (!this._engine)
                return;
            var camera = this._engine.getCamera();
            var startZoom = camera.getZoom();
            var startRotate = camera.getRotate();
            var startPitch = camera.getPitch();
            var center = params.center, _a = params.zoom, zoom = _a === void 0 ? startZoom : _a, _b = params.rotate, rotate = _b === void 0 ? startRotate : _b, _c = params.pitch, pitch = _c === void 0 ? startPitch : _c, _d = params.offset, offset = _d === void 0 ? [0, 0] : _d, _e = params.duration, duration = _e === void 0 ? 500 : _e, _f = params.easing, easing = _f === void 0 ? 'easeOutCirc' : _f;
            zoom = clamp(zoom, this._options.minZoom, this._options.maxZoom);
            var pointAtOffset = camera.centerPoint.add(new Point(offset[0], offset[1]));
            var locationAtOffset = camera.screenToWorldCoordinate(pointAtOffset.x, pointAtOffset.y);
            var endCenter = center ? new Point(center.x, center.y) : locationAtOffset.clone();
            var from = locationAtOffset.clone();
            var centerDelta = endCenter.clone().subtract(from);
            this._fireEvent(params, 'Start');
            var animator = new Animator().ofNumber(0, 1, duration);
            animateFunction[easing] && animator.easing(easing);
            var endRotate = Camera.normalizeRotate(rotate, startRotate);
            animator.on('update', function (e) {
                if (!_this._engine)
                    return;
                var progress = e.num / 1;
                var cameraOptions = {
                    zoom: startZoom + (zoom - startZoom) * progress,
                    rotate: startRotate + (endRotate - startRotate) * progress,
                    pitch: startPitch + (pitch - startPitch) * progress,
                };
                camera.set(cameraOptions);
                var delta = centerDelta.clone().multiply(progress);
                var newCenter = from.clone().add(delta);
                camera.setCenterAtPoint(newCenter, pointAtOffset);
                _this._engine.render();
                _this._engine.updateCollision(false);
                _this._fireEvent(params, '');
            }).on('complete', function () {
                delete _this._animator;
                _this._fireEvent(params, 'End');
                params.complete && params.complete();
            }).on('stop', function () {
                params.complete && params.complete();
            }).start();
            return animator;
        };
        AbstractView.prototype.fitBounds = function (bounds, padding) {
            if (padding === void 0) { padding = 0; }
            var defaultZoom = 17;
            if (!this._engine)
                return defaultZoom;
            var topLeft = bounds.topLeft, bottomRight = bounds.bottomRight;
            if (!topLeft || !bottomRight)
                return defaultZoom;
            var world1 = new Point(topLeft.x, topLeft.y);
            var world2 = new Point(bottomRight.x, bottomRight.y);
            var camera = this._engine.getCamera();
            var center = {
                x: (world1.x + world2.x) / 2,
                y: (world1.y + world2.y) / 2
            };
            var p0world = world1.clone().divide(camera.getOnePixelToWorld());
            var p1world = world2.clone().divide(camera.getOnePixelToWorld());
            var upperRight = new Point(Math.max(p0world.x, p1world.x), Math.max(p0world.y, p1world.y));
            var lowerLeft = new Point(Math.min(p0world.x, p1world.x), Math.min(p0world.y, p1world.y));
            var size = upperRight.clone().subtract(lowerLeft);
            var cameraWidth = camera.getWidth();
            var cameraHeight = camera.getHeight();
            LogMgr$1.log('fitBounds cameraWidth:' + cameraWidth
                + ' cameraHeight:' + cameraHeight);
            var minWidth = Math.min(cameraWidth, cameraHeight);
            var scaleX = (minWidth - (padding * 2)) / size.x;
            var scaleY = (minWidth - (padding * 2)) / size.y;
            var zoom;
            if (scaleX < 0 || scaleY < 0) {
                zoom = camera.getZoom();
            }
            var _a = this._options, minZoom = _a.minZoom, maxZoom = _a.maxZoom;
            var startScale = Math.pow(2, camera.getZoom());
            zoom = clamp(Math.log2(startScale * Math.min(scaleX, scaleY)), minZoom, maxZoom);
            this.easeTo({ center: center, zoom: zoom, rotate: 0 });
            return zoom;
        };
        AbstractView.prototype.stop = function () {
            this._animator && this._animator.stop();
        };
        AbstractView.prototype.getCenter = function () {
            return this._engine && this._engine.getCamera().getCenter();
        };
        AbstractView.prototype.setCenter = function (center) {
            this.jumpTo({ center: center });
        };
        AbstractView.prototype.getRotate = function () {
            return this._engine && this._engine.getCamera().getRotate();
        };
        AbstractView.prototype.setRotate = function (rotate) {
            this.jumpTo({ rotate: rotate });
        };
        AbstractView.prototype.getPitch = function () {
            return this._engine && this._engine.getCamera().getPitch();
        };
        AbstractView.prototype.setPitch = function (pitch) {
            this.jumpTo({ pitch: pitch });
        };
        AbstractView.prototype.addLayers = function (layers) {
            for (var i = 0; i < layers.length; i += 1) {
                if (!this._layers.has(layers[i])) {
                    this._addLayer(layers[i]);
                    if (this._checkIsNeedAdd(layers[i])) {
                        this._engine && this._engine.addLayer(layers[i]);
                    }
                }
            }
            if (!this._engine)
                return;
            this._engine.sortLayer();
        };
        AbstractView.prototype.addLayer = function (layer) {
            if (this._layers.has(layer))
                return;
            this._addLayer(layer);
            if (this._checkIsNeedAdd(layer) && this._engine) {
                this._engine.addLayer(layer);
                this._engine.sortLayer();
            }
        };
        AbstractView.prototype._addLayer = function (layer) {
            this._layers.set(layer);
            var floorId = layer.getFloorId();
            if (floorId && this._viewType === 'multiple') {
                var base = this.getFloorHeight(floorId);
                layer.setMultiLayout({ base: base, opacity: this._getLayerMultiOpacity(layer) });
            }
        };
        AbstractView.prototype.removeLayers = function (layers) {
            for (var i = 0; i < layers.length; i += 1) {
                this._removeLayer(layers[i]);
            }
            this._engine && this._engine.updateCollision();
        };
        AbstractView.prototype.removeLayer = function (layer) {
            var isNeedUpdateCollision = layer.getType() === 'Symbol' &&
                layer.getCollisionRenderList().length > 0;
            this._removeLayer(layer);
            if (this._engine) {
                this._engine.render();
                isNeedUpdateCollision && this._engine.updateCollision();
            }
        };
        AbstractView.prototype._removeLayer = function (layer) {
            this._hasDrawFloorId.delete(layer.getFloorId());
            this._layers.delete(layer);
            this._engine && this._engine.removeLayer(layer);
        };
        AbstractView.prototype.hasLayer = function (layer) {
            return this._layers.has(layer);
        };
        AbstractView.prototype.updateLayer = function (layer) {
            var floorId = layer.getFloorId();
            if (!this._engine || !floorId)
                return;
            var isContain = this._engine.contains(layer);
            if (this._viewType === 'multiple') {
                var base = this.getFloorHeight(floorId);
                layer.setMultiLayout({ base: base, opacity: this._getLayerMultiOpacity(layer) });
            }
            var isNeedUpdate = false;
            if (this._checkIsNeedAdd(layer)) {
                if (!isContain) {
                    this._engine.addLayer(layer);
                    this._engine.sortLayer();
                    isNeedUpdate = true;
                }
            }
            else {
                if (isContain) {
                    this._engine.removeLayer(layer, false);
                    isNeedUpdate = true;
                }
            }
            if (isNeedUpdate) {
                this._engine.render();
                layer.getType() === 'Symbol' &&
                    layer.getCollisionRenderList().length > 0 &&
                    this._engine.updateCollision();
            }
        };
        AbstractView.prototype.addTileLayer = function (layer) {
            this._tileLayers.set(layer);
            this._engine && this._engine.addTileLayer(layer);
        };
        AbstractView.prototype.removeTileLayer = function (layer) {
            this._tileLayers.delete(layer);
            this._engine && this._engine.removeTileLayer(layer);
        };
        AbstractView.prototype._updatePlanarGraphOpacity = function (floors) {
            var layers = this._layers.valuesConcat(this._outdoorLayers);
            for (var i = 0; i < layers.length; i += 1) {
                layers[i].setMultiLayout({ opacity: this._getLayerMultiOpacity(layers[i], floors) });
            }
        };
        AbstractView.prototype._checkIsNeedAdd = function (layer) {
            if (!this.currentFloor)
                return false;
            return layer.getFloorId() === this.currentFloor || this._viewType === 'multiple'
                || layer.getAlwaysShow();
        };
        AbstractView.prototype.screenToWorldCoordinate = function (screenX, screenY) {
            if (!this._engine)
                return new Point(0, 0);
            var rect = this._engine.getRect();
            var camera = this._engine.getCamera();
            return camera.screenToWorldCoordinate(screenX - rect.left, screenY - rect.top);
        };
        AbstractView.prototype.worldToScreenCoordinate = function (worldX, worldY) {
            if (!this._engine)
                return new Point(0, 0);
            var camera = this._engine.getCamera();
            return camera.worldToScreenCoordinate(worldX, worldY);
        };
        AbstractView.prototype.getEngine = function () {
            return this._engine;
        };
        AbstractView.prototype.getCamera = function () {
            return this._engine && this._engine.getCamera();
        };
        AbstractView.isSelf = function (layerName) {
            return Boolean(LayerName[layerName]);
        };
        AbstractView.MAX_STEP = 800;
        AbstractView.OUT_REG = /F00$/;
        return AbstractView;
    }(NCore$1));

    var AbstractGesture = (function () {
        function AbstractGesture(mapView) {
            this._state = 'pending';
            this._isCanMove = false;
            this._inertias = [];
            this._mapView = mapView;
        }
        AbstractGesture.prototype._startFrameUpdate = function () {
            !this._timer && this._frameUpdate();
        };
        AbstractGesture.prototype._stopFrameUpdate = function (e) {
            if (this._timer) {
                cancelAnimationFrame(this._timer);
                this._state = 'pending';
            }
            this._isCanMove = false;
        };
        Object.defineProperty(AbstractGesture.prototype, "animator", {
            get: function () {
                return this._mapView.gestureManager.getAnimator();
            },
            set: function (animator) {
                this._mapView.gestureManager.setAnimator(animator);
            },
            enumerable: false,
            configurable: true
        });
        AbstractGesture.prototype._initInertial = function () {
            var now = Date.now();
            var index = 0;
            for (var i = this._inertias.length - 1; i >= 0; i -= 1) {
                if (now - this._inertias[i][0] > 160) {
                    index = i;
                    break;
                }
            }
            this._inertias = this._inertias.slice(index + 1);
        };
        return AbstractGesture;
    }());

    var PAN_LINEARITY = 0.3;
    var PAN_MAX_SPEED = 1400;
    var PAN_DECELERATION = 2500;
    var ROTATE_LINEARITY = 0.25;
    var ROTATE_MAX_SPEED = 180;
    var ROTATE_DECELERATION = 720;
    var ZOOM_LINEARITY = 0.15;
    var ZOOM_MAX_SPEED = 2.5;
    var ZOOM_DECELERATION = 12;
    function getPanInertia(flingOffset, flingDuration) {
        if (flingOffset.getLength() === 0 || flingDuration === 0)
            return;
        var velocity = flingOffset.multiply(PAN_LINEARITY / flingDuration);
        var length = velocity.getLength();
        var speed = length;
        if (speed > PAN_MAX_SPEED) {
            speed = PAN_MAX_SPEED;
            velocity.multiply(speed / length);
        }
        var duration = speed / (PAN_DECELERATION * PAN_LINEARITY);
        var offset = velocity.multiply(duration / 2);
        return { duration: duration, offset: offset };
    }
    function getRotateInertia(flingDiff, flingDuration) {
        if (flingDiff === 0 || flingDuration === 0)
            return;
        var sign = flingDiff < 0 ? -1 : 1;
        var speed = Math.abs(flingDiff * (ROTATE_LINEARITY / flingDuration));
        if (speed > ROTATE_MAX_SPEED) {
            speed = ROTATE_MAX_SPEED;
        }
        var duration = speed / (ROTATE_DECELERATION * ROTATE_LINEARITY);
        var offset = sign * speed * (duration / 2);
        return { duration: duration, offset: offset };
    }
    function getZoomInertia(flingDiff, flingDuration) {
        if (flingDiff === 0 || flingDuration === 0)
            return;
        var speed = flingDiff * ZOOM_LINEARITY / flingDuration;
        if (Math.abs(speed) > ZOOM_MAX_SPEED) {
            speed = (speed > 0 ? 1 : -1) * ZOOM_MAX_SPEED;
        }
        var duration = Math.abs(speed / (ZOOM_DECELERATION * ZOOM_LINEARITY));
        var offset = speed * duration / 2;
        return { duration: duration, offset: offset };
    }

    var DragPan = (function (_super) {
        __extends$1(DragPan, _super);
        function DragPan(mapView) {
            var _this = _super.call(this, mapView) || this;
            bindAll([
                '_frameUpdate',
            ], _this);
            return _this;
        }
        DragPan.prototype.enable = function () {
            this._state = 'enable';
        };
        DragPan.prototype.disable = function () {
            this._state = 'disable';
        };
        DragPan.prototype.onMousedown = function (e) {
            if (e.which !== 1 || this._state === 'disable')
                return;
            this._start(e);
        };
        DragPan.prototype.onMousemove = function (e) {
            if (e.which !== 1 || this._state === 'disable' || !this._isCanMove)
                return;
            this._onMove({ x: e.clientX, y: e.clientY }, e);
        };
        DragPan.prototype.onMouseup = function (e) {
            if (e.which !== 1)
                return;
            this._stopFrameUpdate(e);
        };
        DragPan.prototype.onMouseleave = function (e) {
            if (e.which !== 1)
                return;
            this._stopFrameUpdate(e);
        };
        DragPan.prototype.onTouchstart = function (e) {
            if (e.touches.length > 1 || this._state === 'disable')
                return;
            var touch = e.touches[0];
            this._start(touch);
        };
        DragPan.prototype._start = function (e) {
            this._state = 'pending';
            this._isCanMove = true;
            this._lastPos = new Point(e.clientX, e.clientY);
            this._inertias = [[Date.now(), this._lastPos]];
            if (this.animator) {
                this.animator.stop();
                this.animator = undefined;
            }
        };
        DragPan.prototype.onTouchmove = function (e) {
            if (e.touches.length > 1 || !this._isCanMove)
                return;
            var touch = e.touches[0];
            this._onMove({ x: touch.clientX, y: touch.clientY }, e);
        };
        DragPan.prototype.onTouchend = function (e) {
            this._stopFrameUpdate(e);
        };
        DragPan.prototype._onMove = function (point, e) {
            var engine = this._mapView.getEngine();
            if (!this._lastPos || !engine)
                return;
            if (this._state === 'pending') {
                this._state = 'active';
                this._startFrameUpdate();
                this._mapView.fire('moveStart', e);
                this._mapView.fire('dragStart', e);
                this._mapView.fire('gestureStart', e);
            }
            this._curPos = new Point(point.x, point.y);
            this._inertias.push([Date.now(), this._curPos]);
        };
        DragPan.prototype._frameUpdate = function () {
            var engine = this._mapView.getEngine();
            if (engine && this._lastPos && this._curPos) {
                var camera = engine.getCamera();
                if (this._mapView.getViewType() === 'multiple') {
                    var delta = this._curPos.clone().subtract(this._lastPos);
                    if (Math.abs(delta.x) > Math.abs(delta.y)) {
                        camera.set({ rotate: camera.getRotate() + delta.x * 0.8 });
                    }
                    else {
                        camera.setZ(camera.getZ() + delta.y * camera.getOnePixelToWorld());
                    }
                    if (this._mapView && this._mapView.m_navi) {
                        var markerMgr = this._mapView.m_navi.getMarkerMgr();
                        markerMgr.forceUpdate();
                    }
                }
                else {
                    var world = camera.screenToWorldCoordinate(this._lastPos.x, this._lastPos.y);
                    camera.setCenterAtPoint(world, this._curPos);
                }
                this._lastPos = this._curPos;
                engine.render();
                engine.updateCollision(false);
            }
            this._mapView.fire('move');
            this._mapView.fire('drag');
            this._mapView.fire('gesture');
            this._timer = requestAnimationFrame(this._frameUpdate);
        };
        DragPan.prototype._stopFrameUpdate = function (e) {
            _super.prototype._stopFrameUpdate.call(this, e);
            if (this._timer) {
                delete this._timer;
                this._inertialEnd(e);
            }
            delete this._lastPos;
            delete this._curPos;
        };
        DragPan.prototype._inertialEnd = function (e) {
            this._initInertial();
            if (this._inertias.length < 2 || this._mapView.getViewType() === 'multiple') {
                this._fireEnd(e);
                return;
            }
            var end = this._inertias[this._inertias.length - 1];
            var start = this._inertias[0];
            var flingOffset = end[1].clone().subtract(start[1]);
            var flingDuration = (end[0] - start[0]) / 1000;
            var panInertia = getPanInertia(flingOffset, flingDuration);
            if (!panInertia) {
                this._fireEnd(e);
                return;
            }
            var offset = panInertia.offset, duration = panInertia.duration;
            this._moveInertia(offset, duration * 1000, e);
            this._inertias = [];
        };
        DragPan.prototype._moveInertia = function (offset, duration, event) {
            var _this = this;
            var engine = this._mapView.getEngine();
            if (!engine)
                return;
            var camera = engine.getCamera();
            var pointAtOffset = camera.centerPoint.add(offset);
            var locationAtOffset = camera.screenToWorldCoordinate(pointAtOffset.x, pointAtOffset.y);
            var end = camera.getCenter();
            var from = locationAtOffset.clone();
            var centerDelta = end.clone().subtract(from);
            var animator = new Animator().ofNumber(0, 1, duration);
            this.animator = animator;
            animator.easing('easeOutCirc');
            animator.on('update', function (e) {
                var delta = centerDelta.clone().multiply(e.num);
                var newCenter = from.clone().add(delta);
                camera.setCenterAtPoint(newCenter, pointAtOffset);
                engine.render();
                engine.updateCollision(false);
                _this._mapView.fire('move', event);
            }).on('complete', function () {
                _this._fireEnd(event);
                _this.animator = undefined;
            }).on('stop', function () {
                _this._fireEnd(event);
            }).start();
        };
        DragPan.prototype._fireEnd = function (e) {
            this._mapView.fire('moveEnd', e);
            this._mapView.fire('dragEnd', e);
            this._mapView.fire('gestureEnd');
        };
        return DragPan;
    }(AbstractGesture));

    var DragRotate = (function (_super) {
        __extends$1(DragRotate, _super);
        function DragRotate(mapView) {
            var _this = _super.call(this, mapView) || this;
            _this._rotateEnable = true;
            _this._pitchEnable = true;
            bindAll([
                '_frameUpdate',
            ], _this);
            return _this;
        }
        DragRotate.prototype.enableRotate = function () {
            this._rotateEnable = true;
        };
        DragRotate.prototype.disableRotate = function () {
            this._rotateEnable = false;
        };
        DragRotate.prototype.enablePitch = function () {
            this._pitchEnable = true;
        };
        DragRotate.prototype.disablePitch = function () {
            this._pitchEnable = false;
        };
        DragRotate.prototype._isEnable = function () {
            return this._rotateEnable || this._pitchEnable;
        };
        DragRotate.prototype.onMousedown = function (e) {
            if (e.which !== 3 || !this._isEnable())
                return;
            this._isCanMove = true;
            this._lastPos = new Point(e.clientX, e.clientY);
            this._inertias = [[Date.now(), this._mapView.getRotate()]];
            if (this.animator) {
                this.animator.stop();
                this.animator = undefined;
            }
        };
        DragRotate.prototype.onMousemove = function (e) {
            if (e.which !== 3 || !this._isEnable() || !this._isCanMove)
                return;
            this._onMove(e);
        };
        DragRotate.prototype.onMouseup = function (e) {
            if (e.which !== 3)
                return;
            this._stopFrameUpdate(e);
        };
        DragRotate.prototype.onMouseleave = function (e) {
            if (e.which !== 3)
                return;
            this._stopFrameUpdate(e);
        };
        DragRotate.prototype._onMove = function (e) {
            if (this._state === 'pending') {
                this._state = 'active';
                this._startFrameUpdate();
                this._mapView.fire('moveStart', e);
                this._rotateEnable && this._mapView.fire('rotateStart', e);
                this._pitchEnable && this._mapView.fire('pitchStart', e);
                this._mapView.fire('gestureStart');
            }
            this._curPos = new Point(e.clientX, e.clientY);
        };
        DragRotate.prototype._frameUpdate = function () {
            var engine = this._mapView.getEngine();
            if (engine && this._lastPos && this._curPos) {
                var camera = engine.getCamera();
                var angle = this._curPos.x - this._lastPos.x;
                var rotate = camera.getRotate();
                rotate += angle / 3;
                var pitch = camera.getPitch();
                var deltaY = this._curPos.y - this._lastPos.y;
                pitch -= deltaY / 3;
                var params = {};
                if (this._pitchEnable) {
                    params.pitch = pitch;
                }
                if (this._rotateEnable && this._mapView.getViewType() === 'single') {
                    params.rotate = rotate;
                    var last = this._inertias[this._inertias.length - 1];
                    this._inertias.push([Date.now(), Camera.normalizeRotate(rotate, last[1])]);
                }
                camera.set(params);
                this._lastPos = this._curPos;
                engine.render();
                engine.updateCollision(false);
            }
            this._mapView.fire('move');
            this._rotateEnable && this._mapView.fire('rotate');
            this._pitchEnable && this._mapView.fire('pitch');
            this._mapView.fire('gesture');
            this._timer = requestAnimationFrame(this._frameUpdate);
        };
        DragRotate.prototype._stopFrameUpdate = function (e) {
            _super.prototype._stopFrameUpdate.call(this, e);
            if (this._timer) {
                delete this._timer;
                this._inertialEnd(e);
            }
            delete this._lastPos;
            delete this._curPos;
        };
        DragRotate.prototype._inertialEnd = function (e) {
            this._initInertial();
            if (this._inertias.length < 2 || this._mapView.getViewType() === 'multiple') {
                this._fireEnd(e);
                return;
            }
            var start = this._inertias[0];
            var end = this._inertias[this._inertias.length - 1];
            var flingDuration = (end[0] - start[0]) / 1000;
            var rotateInertia = getRotateInertia(end[1] - start[1], flingDuration);
            if (!rotateInertia || Math.abs(rotateInertia.offset) < 2) {
                this._fireEnd(e);
                return;
            }
            var offset = rotateInertia.offset, duration = rotateInertia.duration;
            this._rotateInertia(offset, duration * 1000, e);
            this._inertias = [];
        };
        DragRotate.prototype._rotateInertia = function (offset, duration, event) {
            var _this = this;
            var engine = this._mapView.getEngine();
            if (!engine)
                return;
            var camera = engine.getCamera();
            var startRotate = camera.getRotate();
            var animator = new Animator().ofNumber(0, 1, duration);
            this.animator = animator;
            animator.easing('easeOutCirc');
            animator.on('update', function (e) {
                var curRotate = offset * e.num + startRotate;
                camera.set({ rotate: curRotate });
                engine.render();
                engine.updateCollision(false);
                _this._mapView.fire('move', event);
                _this._mapView.fire('rotate', event);
            }).on('complete', function () {
                _this._fireEnd(event);
                _this.animator = undefined;
            }).on('stop', function () {
                _this._fireEnd(event);
            }).start();
        };
        DragRotate.prototype._fireEnd = function (e) {
            this._mapView.fire('moveEnd', e);
            this._rotateEnable && this._mapView.fire('rotateEnd', e);
            this._pitchEnable && this._mapView.fire('pitchEnd', e);
            this._mapView.fire('gestureEnd', e);
        };
        return DragRotate;
    }(AbstractGesture));

    var TouchZoomRotate = (function (_super) {
        __extends$1(TouchZoomRotate, _super);
        function TouchZoomRotate(mapView) {
            var _this = _super.call(this, mapView) || this;
            _this._zoomEnable = true;
            _this._rotateEnable = true;
            _this._pitchEnable = true;
            _this._isPitch = false;
            _this._firstMoveTime = 0;
            _this._isChecked = false;
            bindAll([
                '_frameUpdate',
            ], _this);
            return _this;
        }
        TouchZoomRotate.prototype.enableZoom = function () {
            this._zoomEnable = true;
        };
        TouchZoomRotate.prototype.disableZoom = function () {
            this._zoomEnable = false;
        };
        TouchZoomRotate.prototype.enableRotate = function () {
            this._rotateEnable = true;
        };
        TouchZoomRotate.prototype.disableRotate = function () {
            this._rotateEnable = false;
        };
        TouchZoomRotate.prototype.enablePitch = function () {
            this._pitchEnable = true;
        };
        TouchZoomRotate.prototype.disablePitch = function () {
            this._pitchEnable = false;
        };
        TouchZoomRotate.prototype.onTouchstart = function (e) {
            if (e.touches.length < 2 || !this._isEnable())
                return;
            this._isCanMove = true;
            var _a = e.touches[0], x1 = _a.clientX, y1 = _a.clientY;
            var _b = e.touches[e.touches.length - 1], x2 = _b.clientX, y2 = _b.clientY;
            var x = (x1 + x2) / 2;
            var y = (y1 + y2) / 2;
            this._startAround = this._mapView.screenToWorldCoordinate(x, y);
            this._startTouches = this._lastTouches = [[x1, y1], [x2, y2]];
            if (this.animator) {
                this.animator.stop();
                this.animator = undefined;
            }
        };
        TouchZoomRotate.prototype.onTouchmove = function (e) {
            if (e.touches.length < 2 || !this._isEnable() || !this._isCanMove)
                return;
            var _a = e.touches[0], x1 = _a.clientX, y1 = _a.clientY;
            var _b = e.touches[e.touches.length - 1], x2 = _b.clientX, y2 = _b.clientY;
            this._curTouches = [[x1, y1], [x2, y2]];
            this._eventData = this._getEventData(this._lastTouches, this._curTouches);
            this._lastTouches = this._curTouches;
            this._pushInertias();
            if (this._state === 'pending') {
                this._state = 'active';
                this._inertias = [];
                this._firstMoveTime = e.timeStamp;
            }
            if (!this._isChecked && e.timeStamp - this._firstMoveTime > 64) {
                this._isChecked = true;
                var _c = this._getEventData(this._startTouches, this._curTouches), zoomScale = _c.zoomScale, rotateDelta = _c.rotateDelta, pitchDelta = _c.pitchDelta;
                this._isPitch = (this._pitchEnable && Math.abs(1 - zoomScale) < 0.5 &&
                    Math.abs(rotateDelta) < 10 && Math.abs(pitchDelta) > 5);
                this._mapView.fire('moveStart');
                if (this._isPitch) {
                    this._pitchEnable && this._mapView.fire('pitchStart');
                }
                else {
                    this._zoomEnable && this._mapView.fire('zoomStart');
                    this._rotateEnable && this._mapView.fire('rotateStart');
                }
                this._mapView.fire('gestureStart');
                this._startFrameUpdate();
            }
        };
        TouchZoomRotate.prototype._pushInertias = function () {
            if (!this._eventData)
                return;
            var _a = this._eventData, rotateDelta = _a.rotateDelta, zoomScale = _a.zoomScale, center = _a.center;
            var camera = this._mapView.getCamera();
            var zoom = camera.getZoom();
            zoom = Math.log2(Math.pow(2, zoom) * zoomScale);
            zoom = clamp(zoom, this._mapView.getMinZoom(), this._mapView.getMaxZoom());
            var rotate = camera.getRotate() - rotateDelta;
            var last = this._inertias[this._inertias.length - 1] || camera.getRotate();
            this._inertias.push([Date.now(), zoom, Camera.normalizeRotate(rotate, last[2]), center]);
        };
        TouchZoomRotate.prototype.onTouchend = function (e) {
            this._stopFrameUpdate(e);
            this._state = 'pending';
            this._isChecked = false;
        };
        TouchZoomRotate.prototype._isEnable = function () {
            return this._zoomEnable || this._pitchEnable || this._rotateEnable;
        };
        TouchZoomRotate.prototype._frameUpdate = function () {
            var engine = this._mapView.getEngine();
            if (engine && this._startAround && this._eventData) {
                var _a = this._eventData, center = _a.center, rotateDelta = _a.rotateDelta, zoomScale = _a.zoomScale, pitchDelta = _a.pitchDelta;
                var camera = engine.getCamera();
                var params = {};
                if (this._isPitch) {
                    params.pitch = camera.getPitch() - pitchDelta / 2;
                }
                else {
                    var zoom = camera.getZoom();
                    if (this._zoomEnable) {
                        zoom = Math.log2(Math.pow(2, zoom) * zoomScale);
                        zoom = clamp(zoom, this._mapView.getMinZoom(), this._mapView.getMaxZoom());
                        params.zoom = zoom;
                    }
                    var rotate = camera.getRotate();
                    if (this._rotateEnable && Math.abs(rotateDelta) > 0.1 && this._mapView.getViewType() === 'single') {
                        rotate = camera.getRotate() - rotateDelta;
                        params.rotate = rotate;
                    }
                    if (this._zoomEnable || this._rotateEnable) {
                        var last = this._inertias[this._inertias.length - 1] || camera.getRotate();
                        this._inertias.push([Date.now(), zoom, Camera.normalizeRotate(rotate, last[2]), center]);
                    }
                }
                camera.set(params);
                if (this._mapView.getViewType() === 'single' && !this._isPitch) {
                    camera.setCenterAtPoint(this._startAround, center);
                }
                engine.render();
                engine.updateCollision(false);
                this._lastTouches = this._curTouches;
            }
            this._timer = requestAnimationFrame(this._frameUpdate);
            this._mapView.fire('move');
            if (this._isPitch) {
                this._pitchEnable && this._mapView.fire('pitch');
            }
            else {
                this._zoomEnable && this._mapView.fire('zoom');
                this._rotateEnable && this._mapView.fire('rotate');
            }
            this._mapView.fire('gesture');
        };
        TouchZoomRotate.prototype._getEventData = function (start, end) {
            var lastVector = new Vector2(start[0], start[1]);
            var curVector = new Vector2(end[0], end[1]);
            var _a = end[0], x1 = _a[0], y1 = _a[1], _b = end[1], x2 = _b[0], y2 = _b[1];
            var engine = this._mapView.getEngine();
            var rect = engine.getRect();
            var center = new Point((x1 + x2) / 2 - rect.left, (y1 + y2) / 2 - rect.top);
            var rotateDelta = curVector.angleTo(lastVector);
            var zoomScale = curVector.getLength() / lastVector.getLength();
            var deltaY1 = y1 - start[0][1];
            var deltaY2 = y2 - start[1][1];
            var pitchDelta = 0;
            if (deltaY1 * deltaY2 >= 0 && Math.abs(deltaY1 - deltaY2) < 30) {
                pitchDelta = (deltaY1 + deltaY2) / 2;
            }
            return { center: center, rotateDelta: rotateDelta, zoomScale: zoomScale, pitchDelta: pitchDelta };
        };
        TouchZoomRotate.prototype._stopFrameUpdate = function (e) {
            _super.prototype._stopFrameUpdate.call(this, e);
            if (this._timer) {
                delete this._timer;
                this._isPitch ? this._fireEnd(e) : this._inertialEnd(e);
            }
            this._isPitch = false;
            delete this._lastTouches;
            delete this._curTouches;
            delete this._startAround;
        };
        TouchZoomRotate.prototype._inertialEnd = function (e) {
            this._initInertial();
            if (this._inertias.length < 2 || this._mapView.getViewType() === 'multiple') {
                this._fireEnd(e);
                return;
            }
            var start = this._inertias[0];
            var end = this._inertias[this._inertias.length - 1];
            var flingDuration = (end[0] - start[0]) / 1000;
            var zoomInertia = this._zoomEnable && getZoomInertia(end[1] - start[1], flingDuration);
            var rotateInertia = this._rotateEnable && getRotateInertia(end[2] - start[2], flingDuration);
            if (!zoomInertia && !rotateInertia) {
                this._fireEnd(e);
                return;
            }
            var zoomOffset = 0, rotateOffset = 0, duration = 0;
            if (zoomInertia && rotateInertia) {
                duration = Math.max(zoomInertia.duration, rotateInertia.duration);
                zoomOffset = zoomInertia.offset;
                rotateOffset = rotateInertia.offset;
            }
            else if (zoomInertia) {
                duration = zoomInertia.duration;
                zoomOffset = zoomInertia.offset;
            }
            else if (rotateInertia) {
                duration = rotateInertia.duration;
                rotateOffset = rotateInertia.offset;
            }
            this._zoomInertia(zoomOffset, rotateOffset, duration * 1000, end[3], e);
            this._inertias = [];
        };
        TouchZoomRotate.prototype._zoomInertia = function (zoomOffset, rotateOffset, duration, center, event) {
            var _this = this;
            var engine = this._mapView.getEngine();
            var around = this._startAround;
            if (!engine || !around)
                return;
            var camera = engine.getCamera();
            var startZoom = camera.getZoom();
            var startRotate = camera.getRotate();
            var endZoom = clamp(startZoom + zoomOffset, this._mapView.getMinZoom(), this._mapView.getMaxZoom());
            var animator = new Animator().ofNumber(0, 1, duration);
            this.animator = animator;
            animator.easing('easeOutCirc');
            animator.on('update', function (e) {
                var itemZoom = startZoom + (endZoom - startZoom) * e.num;
                var itemRotate = startRotate + rotateOffset * e.num;
                camera.set({ zoom: itemZoom, rotate: itemRotate });
                _this._mapView.getViewType() === 'single' && camera.setCenterAtPoint(around, center);
                engine.render();
                engine.updateCollision(false);
                _this._mapView.fire('move', event);
                _this._mapView.fire('rotate', event);
            }).on('complete', function () {
                _this._fireEnd(event);
                _this.animator = undefined;
            }).on('stop', function () {
                _this._fireEnd(event);
            }).start();
        };
        TouchZoomRotate.prototype._fireEnd = function (e) {
            this._mapView.fire('moveEnd', e);
            if (this._isPitch) {
                this._pitchEnable && this._mapView.fire('pitchEnd', e);
            }
            else {
                this._zoomEnable && this._mapView.fire('zoomEnd', e);
                this._rotateEnable && this._mapView.fire('rotateEnd', e);
            }
            this._mapView.fire('gestureEnd', e);
        };
        TouchZoomRotate.LINEARITY = 0.15;
        TouchZoomRotate.MAX_SPEED = 2.5;
        TouchZoomRotate.DECELERATION = 12;
        return TouchZoomRotate;
    }(AbstractGesture));

    var ScrollZoom = (function () {
        function ScrollZoom(mapView) {
            this._stopTimer = null;
            this._targetZoom = 0;
            this._isEnable = true;
            this._mapView = mapView;
            this._dom = this._mapView.getCanvasContainer();
            bindAll([
                '_frameUpdate',
                '_stopFrameUpdate',
            ], this);
        }
        ScrollZoom.prototype.enable = function () {
            this._isEnable = true;
        };
        ScrollZoom.prototype.disable = function () {
            this._isEnable = false;
        };
        ScrollZoom.prototype.onWheel = function (e) {
            if (!this._isEnable || e.deltaY === 0)
                return;
            var engine = this._mapView.getEngine();
            if (!engine)
                return;
            var camera = engine.getCamera();
            if (this._stopTimer) {
                clearTimeout(this._stopTimer);
                delete this._stopTimer;
            }
            var rect = engine.getRect();
            var x = e.clientX - rect.left;
            var y = e.clientY - rect.top;
            this._around = camera.screenToWorldCoordinate(x, y);
            this._aroundPoint = new Point(x, y);
            var minZoom = this._mapView.getMinZoom();
            var maxZoom = this._mapView.getMaxZoom();
            var zoom = camera.getZoom() + Math.log10(Math.abs(e.deltaY)) / 10 * (e.deltaY > 0 ? -1 : 1);
            this._targetZoom = clamp(zoom, minZoom, maxZoom);
            this._startFrameUpdate();
            this._stopTimer = setTimeout(this._stopFrameUpdate, 300, 3);
        };
        ScrollZoom.prototype._onScroll = function () {
            var camera = this._mapView.getCamera();
            if (!camera)
                return;
            var zoom = camera.getZoom();
            zoom += (this._targetZoom - zoom) / 2;
            camera.set({ zoom: zoom });
            if (this._mapView.getViewType() === 'single' && this._around && this._aroundPoint) {
                camera.setCenterAtPoint(this._around, this._aroundPoint);
            }
        };
        ScrollZoom.prototype._startFrameUpdate = function () {
            if (!this._timer) {
                this._mapView.fire('moveStart');
                this._mapView.fire('zoomStart');
                this._mapView.fire('gestureStart');
                this._frameUpdate();
            }
        };
        ScrollZoom.prototype._frameUpdate = function () {
            var engine = this._mapView.getEngine();
            this._onScroll();
            if (engine) {
                engine.render();
                engine.updateCollision(false);
            }
            this._mapView.fire('move');
            this._mapView.fire('zoom');
            this._mapView.fire('gesture');
            this._timer = requestAnimationFrame(this._frameUpdate);
        };
        ScrollZoom.prototype._stopFrameUpdate = function (e) {
            if (this._timer) {
                cancelAnimationFrame(this._timer);
                delete this._timer;
                this._mapView.fire('moveEnd', e);
                this._mapView.fire('zoomEnd', e);
                this._mapView.fire('gestureEnd', e);
            }
        };
        return ScrollZoom;
    }());

    var MapEvent = (function () {
        function MapEvent(event, target) {
            this._isCancel = false;
            this._originEvent = event;
            this._target = target;
            var e = event instanceof MouseEvent ? event : event.touches[0];
            this._screen = new Point(e.clientX, e.clientY);
        }
        MapEvent.prototype.getScreen = function () {
            return this._screen;
        };
        MapEvent.prototype.getWorld = function () {
            if (!this._world) {
                this._world = this._target.screenToWorldCoordinate(this._screen.x, this._screen.y);
            }
            return this._world;
        };
        MapEvent.prototype.cancel = function () {
            this._isCancel = true;
        };
        MapEvent.prototype.getOriginEvent = function () {
            return this._originEvent;
        };
        MapEvent.prototype.isCancel = function () {
            return this._isCancel;
        };
        Object.defineProperty(MapEvent.prototype, "world", {
            get: function () {
                return this.getWorld();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MapEvent.prototype, "point", {
            get: function () {
                return this._screen;
            },
            enumerable: false,
            configurable: true
        });
        return MapEvent;
    }());

    var GestureManager = (function () {
        function GestureManager(mapView) {
            this._touchNum = 0;
            this._lastTouchTime = Date.now();
            this._mapView = mapView;
            this._dragPan = new DragPan(mapView);
            this._touchZoomRotate = new TouchZoomRotate(mapView);
            this._scrollZoom = new ScrollZoom(mapView);
            this._dragRotate = new DragRotate(mapView);
            bindAll([
                '_frameUpdate',
                '_onClick',
                '_onMousedown',
                '_onMousemove',
                '_onMouseup',
                '_onDbClick',
                '_onTouchstart',
                '_onTouchmove',
                '_onTouchend',
                '_onContextmenu',
                '_onMouseleave',
                '_onWheel',
            ], this);
            this._dom = this._mapView.getCanvasContainer();
            this._dom.addEventListener('click', this._onClick);
            this._dom.addEventListener('mousedown', this._onMousedown);
            this._dom.addEventListener('mousemove', this._onMousemove);
            this._dom.addEventListener('mouseup', this._onMouseup);
            this._dom.addEventListener('mouseleave', this._onMouseleave);
            this._dom.addEventListener('dblclick', this._onDbClick);
            this._dom.addEventListener('touchstart', this._onTouchstart);
            this._dom.addEventListener('touchmove', this._onTouchmove);
            this._dom.addEventListener('touchend', this._onTouchend);
            this._dom.addEventListener('contextmenu', this._onContextmenu);
            this._dom.addEventListener('wheel', this._onWheel);
        }
        GestureManager.prototype._onWheel = function (e) {
            GestureManager.stopOriginEvent(e);
            this._scrollZoom.onWheel(e);
        };
        GestureManager.prototype._onContextmenu = function (e) {
            GestureManager.stopOriginEvent(e);
        };
        GestureManager.prototype._onClick = function (e) {
            GestureManager.stopOriginEvent(e);
            this._fireClick(e);
        };
        GestureManager.prototype._fireClick = function (e) {
            var pos = e instanceof MouseEvent ? new Point(e.clientX, e.clientY) :
                new Point(e.touches[0].clientX, e.touches[0].clientY);
            if (this._startPos && pos.distanceTo(this._startPos) < 1) {
                var engine = this._mapView.getEngine();
                var event = new MapEvent(e, this._mapView);
                engine && engine.fire('click', event);
                !event.isCancel() && this._mapView.fire('click', event);
            }
        };
        GestureManager.prototype._fireDbClick = function (e) {
            var point = e instanceof MouseEvent ? new Point(e.clientX, e.clientY) :
                new Point(e.touches[0].clientX, e.touches[0].clientY);
            this._animateDbClickZoom(point, 1);
            this._mapView.fire('dbClick', new MapEvent(e, this._mapView));
        };
        GestureManager.prototype._onDbClick = function (e) {
            GestureManager.stopOriginEvent(e);
            this._fireDbClick(e);
        };
        GestureManager.prototype.getAnimator = function () {
            return this._animator;
        };
        GestureManager.prototype.setAnimator = function (animator) {
            this._animator = animator;
        };
        GestureManager.prototype._animateDbClickZoom = function (point, zoomDelta) {
            var _this = this;
            this._animator && this._animator.stop();
            var engine = this._mapView.getEngine();
            if (!engine)
                return;
            var camera = engine.getCamera();
            var rect = engine.getRect();
            var x = point.x - rect.left;
            var y = point.y - rect.top;
            var around = camera.screenToWorldCoordinate(x, y);
            var startZoom = camera.getZoom();
            var endZoom = clamp(startZoom + zoomDelta, this._mapView.getMinZoom(), this._mapView.getMaxZoom());
            this._animator = new Animator().ofNumber(startZoom, endZoom, 500);
            this._animator.easing('easeOutCirc');
            this._fireEvent({ zoom: zoomDelta }, 'Start');
            this._mapView.fire('gestureStart');
            this._animator.on('update', function (e) {
                _this._fireEvent({ zoom: e.num }, '');
                _this._mapView.fire('gesture');
                camera.set({ zoom: e.num });
                camera.setCenterAtPoint(around, { x: x, y: y });
                engine.render();
                engine.updateCollision(false);
            }).on('complete', function () {
                _this._fireEvent({ zoom: zoomDelta }, 'End');
                _this._mapView.fire('gestureEnd');
                delete _this._animator;
            }).start();
        };
        GestureManager.prototype._fireEvent = function (params, suffix) {
            var rotate = params.rotate, pitch = params.pitch, zoom = params.zoom;
            this._mapView.fire("move" + suffix);
            typeof rotate === 'number' && this._mapView.fire("rotate" + suffix);
            typeof pitch === 'number' && this._mapView.fire("pitch" + suffix);
            typeof zoom === 'number' && this._mapView.fire("zoom" + suffix);
        };
        GestureManager.prototype._onMousedown = function (e) {
            GestureManager.stopOriginEvent(e);
            this._startPos = new Point(e.clientX, e.clientY);
            this._dragPan.onMousedown(e);
            this._dragRotate.onMousedown(e);
            var engine = this._mapView.getEngine();
            var event = new MapEvent(e, this._mapView);
            engine && engine.fire('mousedown', event);
            !event.isCancel() && this._mapView.fire('mousedown', event);
        };
        GestureManager.prototype._onMousemove = function (e) {
            GestureManager.stopOriginEvent(e);
            this._dragPan.onMousemove(e);
            this._dragRotate.onMousemove(e);
            var engine = this._mapView.getEngine();
            var event = new MapEvent(e, this._mapView);
            engine && engine.fire('mousemove', event);
            !event.isCancel() && this._mapView.fire('mousemove', event);
        };
        GestureManager.prototype._onMouseup = function (e) {
            GestureManager.stopOriginEvent(e);
            this._dragPan.onMouseup(e);
            this._dragRotate.onMouseup(e);
            var engine = this._mapView.getEngine();
            var event = new MapEvent(e, this._mapView);
            engine && engine.fire('mouseup', event);
            !event.isCancel() && this._mapView.fire('mouseup', event);
        };
        GestureManager.prototype._onMouseleave = function (e) {
            this._dragPan.onMouseleave(e);
            this._dragRotate.onMouseleave(e);
            var engine = this._mapView.getEngine();
            var event = new MapEvent(e, this._mapView);
            engine && engine.fire('mouseleave', event);
            !event.isCancel() && this._mapView.fire('mouseleave', event);
        };
        GestureManager.prototype._onTouchstart = function (e) {
            GestureManager.stopOriginEvent(e);
            this._touchEvent = e;
            var touch = e.touches[0];
            this._touchNum = e.touches.length;
            this._startPos = new Point(touch.clientX, touch.clientY);
            delete this._lastPos;
            this._dragPan.onTouchstart(e);
            this._touchZoomRotate.onTouchstart(e);
            var engine = this._mapView.getEngine();
            var event = new MapEvent(e, this._mapView);
            engine && engine.fire('touchstart', event);
            !event.isCancel() && this._mapView.fire('touchstart', event);
        };
        GestureManager.prototype._onTouchmove = function (e) {
            GestureManager.stopOriginEvent(e);
            this._touchEvent = e;
            var touch = e.touches[0];
            this._dragPan.onTouchmove(e);
            this._touchZoomRotate.onTouchmove(e);
            this._touchNum = e.touches.length;
            this._lastPos = new Point(touch.clientX, touch.clientY);
            var engine = this._mapView.getEngine();
            var event = new MapEvent(e, this._mapView);
            engine && engine.fire('touchmove', event);
            !event.isCancel() && this._mapView.fire('touchmove', event);
        };
        GestureManager.prototype._onTouchend = function (e) {
            GestureManager.stopOriginEvent(e);
            if (!this._touchEvent)
                return;
            var now = Date.now();
            if (this._startPos && this._touchNum === 1 &&
                (!this._lastPos || this._lastPos.distanceTo(this._startPos) < 3)) {
                this._fireClick(this._touchEvent);
                if (now - this._lastTouchTime < 300) {
                    this._fireDbClick(this._touchEvent);
                }
            }
            this._lastTouchTime = now;
            this._touchNum = 0;
            this._dragPan.onTouchend(e);
            this._touchZoomRotate.onTouchend(e);
            var engine = this._mapView.getEngine();
            var event = new MapEvent(this._touchEvent, this._mapView);
            engine && engine.fire('touchend', event);
            !event.isCancel() && this._mapView.fire('touchend', event);
            delete this._touchEvent;
        };
        GestureManager.prototype.destroy = function () {
            this._dom.removeEventListener('click', this._onClick);
            this._dom.removeEventListener('mousedown', this._onMousedown);
            this._dom.removeEventListener('mousemove', this._onMousemove);
            this._dom.removeEventListener('mouseup', this._onMouseup);
            this._dom.removeEventListener('mouseleave', this._onMouseleave);
            this._dom.removeEventListener('dblclick', this._onDbClick);
            this._dom.removeEventListener('touchstart', this._onTouchstart);
            this._dom.removeEventListener('touchmove', this._onTouchmove);
            this._dom.removeEventListener('touchend', this._onTouchend);
            this._dom.removeEventListener('contextmenu', this._onContextmenu);
            this._dom.removeEventListener('wheel', this._onWheel);
        };
        GestureManager.prototype.disableDrag = function () {
            this._dragPan.disable();
        };
        GestureManager.prototype.enableDrag = function () {
            this._dragPan.enable();
        };
        GestureManager.prototype.disableZoom = function () {
            this._scrollZoom.disable();
            this._touchZoomRotate.disableZoom();
        };
        GestureManager.prototype.enableZoom = function () {
            this._scrollZoom.enable();
            this._touchZoomRotate.enableZoom();
        };
        GestureManager.prototype.disableRotate = function () {
            this._dragRotate.disableRotate();
            this._touchZoomRotate.disableRotate();
        };
        GestureManager.prototype.enableRotate = function () {
            this._dragRotate.enableRotate();
            this._touchZoomRotate.enableRotate();
        };
        GestureManager.prototype.disablePitch = function () {
            this._dragRotate.disablePitch();
            this._touchZoomRotate.disablePitch();
        };
        GestureManager.prototype.enablePitch = function () {
            this._dragRotate.enablePitch();
            this._touchZoomRotate.enablePitch();
        };
        GestureManager.stopOriginEvent = function (e) {
            e.stopPropagation();
            e.preventDefault();
        };
        return GestureManager;
    }());

    var DBManager = (function () {
        function DBManager(dataBaseName, options) {
            var _this = this;
            var rq = window.indexedDB.open(dataBaseName);
            var tableNames = options.tableNames;
            this._openPromise = new Promise(function (resolve) {
                rq.addEventListener('success', function () {
                    _this._db = rq.result;
                    resolve('success');
                });
                rq.addEventListener('upgradeneeded', function () {
                    var db = rq.result;
                    for (var i = 0; i < tableNames.length; i += 1) {
                        var _a = tableNames[i], name = _a.name, keyPath = _a.keyPath;
                        if (!db.objectStoreNames.contains(name)) {
                            db.createObjectStore(name, { keyPath: keyPath });
                        }
                    }
                });
            });
        }
        DBManager.prototype.insert = function (tableName, data) {
            return __awaiter(this, void 0, void 0, function () {
                var tr, store, rq;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this._openPromise];
                        case 1:
                            _a.sent();
                            tr = this._db.transaction(tableName, 'readwrite');
                            store = tr.objectStore(tableName);
                            rq = store.add(data);
                            return [2, new Promise(function (resolve, reject) {
                                    rq.addEventListener('success', resolve);
                                    rq.addEventListener('error', reject);
                                })];
                    }
                });
            });
        };
        DBManager.prototype.update = function (tableName, data) {
            return __awaiter(this, void 0, void 0, function () {
                var tr, store, rq;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this._openPromise];
                        case 1:
                            _a.sent();
                            tr = this._db.transaction(tableName, 'readwrite');
                            store = tr.objectStore(tableName);
                            rq = store.put(data);
                            return [2, new Promise(function (resolve, reject) {
                                    rq.addEventListener('success', resolve);
                                    rq.addEventListener('error', reject);
                                })];
                    }
                });
            });
        };
        DBManager.prototype.select = function (tableName, key) {
            return __awaiter(this, void 0, void 0, function () {
                var tr, store, rq;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this._openPromise];
                        case 1:
                            _a.sent();
                            tr = this._db.transaction(tableName, 'readwrite');
                            store = tr.objectStore(tableName);
                            rq = store.get(key);
                            return [2, new Promise(function (resolve, reject) {
                                    rq.addEventListener('success', function () { return resolve(rq.result); });
                                    rq.addEventListener('error', function (err) { return reject(err); });
                                })];
                    }
                });
            });
        };
        return DBManager;
    }());

    var Security = (function () {
        function Security(options) {
            this._options = options;
        }
        Security.prototype.decrypt = function (bytes) {
            var length = bytes.length;
            var key = this._getDynamicKey(length);
            var len = key.length;
            var result = [];
            for (var i = 0; i < length; i += 1) {
                result.push(bytes[i] ^ key[i % len]);
            }
            var resultStr = Security.byteToString(result);
            return resultStr;
        };
        Security.prototype._getDynamicKey = function (length) {
            var key = this._options.key;
            var len = length % key.length;
            var arr = [];
            for (var i = len; i < key.length; i += 1) {
                var c = key.charAt(i);
                arr.push(c);
            }
            for (var i = 0; i < len; i += 1) {
                var c = key.charAt(i);
                arr.push(c);
            }
            return Security.stringToByte(arr.join(''));
        };
        Security.stringToByte = function (str) {
            var bytes = [];
            for (var i = 0; i < str.length; i += 1) {
                var c = str.charCodeAt(i);
                bytes.push(c);
            }
            return bytes;
        };
        Security.byteToString = function (bytes) {
            var pos = 0;
            var str = '';
            while (pos < bytes.length) {
                var byte1 = bytes[pos++];
                if (byte1 === 0)
                    break;
                if ((byte1 & 0x80) === 0) {
                    str += String.fromCharCode(byte1);
                }
                else if ((byte1 & 0xe0) === 0xc0) {
                    var byte2 = bytes[pos++] & 0x3f;
                    str += String.fromCharCode(((byte1 & 0x1f) << 6) | byte2);
                }
                else if ((byte1 & 0xf0) === 0xe0) {
                    var byte2 = bytes[pos++] & 0x3f;
                    var byte3 = bytes[pos++] & 0x3f;
                    str += String.fromCharCode(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);
                }
                else if ((byte1 & 0xf8) === 0xf0) {
                    var byte2 = bytes[pos++] & 0x3f;
                    var byte3 = bytes[pos++] & 0x3f;
                    var byte4 = bytes[pos++] & 0x3f;
                    var code = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
                    if (code > 0xffff) {
                        code -= 0x10000;
                        str += String.fromCharCode((code >>> 10) & 0x3ff | 0xd800);
                        code = 0xdc00 | code & 0x3ff;
                    }
                    str += String.fromCharCode(code);
                }
            }
            return str;
        };
        return Security;
    }());

    var DataSource$1 = (function () {
        function DataSource(options) {
            var appKey = options.appKey, server = options.server;
            this._options = options;
            this._security = new Security({ key: DataSource.SECURITY_KEY });
            this._appKey = appKey;
            this._server = server;
            this._isAPI_SDK = /new-sdknagrand\.ipalmap\.com\:18090/.test(this._server);
            if (window.indexedDB && this._options.useCache) {
                var name = this._isAPI_SDK ? 'palmap-map-json-new' : 'palmap-map-json';
                this._dbMng = new DBManager(name, {
                    tableNames: [
                        { name: 'floor', keyPath: 'bdId' },
                        { name: 'geojson', keyPath: 'floorId' },
                    ],
                });
            }
        }
        DataSource.prototype._decrypt = function (input) {
            if (!this._isAPI_SDK) {
                return input;
            }
            var int8 = new Int8Array(input);
            return JSON.parse(this._security.decrypt(int8));
        };
        DataSource.prototype.requestFloors = function (buildingId, options) {
            return __awaiter(this, void 0, Promise, function () {
                var key, res, data;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._dbMng) return [3, 2];
                            key = DataSource.generateKey(buildingId, options);
                            return [4, this._dbMng.select('floor', key)];
                        case 1:
                            res = _a.sent();
                            if (res) {
                                requestAnimationFrame(function () { return _this._requestFloors(buildingId, options, true); });
                                return [2, this._decrypt(res.data)];
                            }
                            _a.label = 2;
                        case 2: return [4, this._requestFloors(buildingId, options)];
                        case 3:
                            data = _a.sent();
                            return [2, this._decrypt(data)];
                    }
                });
            });
        };
        DataSource.prototype._requestFloors = function (buildingId, options, isUpdate) {
            if (isUpdate === void 0) { isUpdate = false; }
            return __awaiter(this, void 0, void 0, function () {
                var url, result, _a, key;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            url = this._server + "/floor/bybuilding/" + buildingId;
                            if (!this._isAPI_SDK) return [3, 2];
                            return [4, new HttpClient().get(url, __assign$1(__assign$1({}, (this._appKey ? { headers: { appKey: this._appKey } } : {})), { query: __assign$1({ f0enable: 1, coordinateType: 2 }, options), responseType: 'arraybuffer' }))];
                        case 1:
                            _a = _b.sent();
                            return [3, 4];
                        case 2: return [4, new HttpClient().get(url, {
                                query: __assign$1({ f0enable: 1, coordinateType: 2 }, options),
                            })];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            result = _a;
                            if (this._dbMng) {
                                key = DataSource.generateKey(buildingId, options);
                                isUpdate ?
                                    this._dbMng.update('floor', { bdId: key, data: result }) :
                                    this._dbMng.insert('floor', { bdId: key, data: result });
                            }
                            return [2, result];
                    }
                });
            });
        };
        DataSource.prototype.requestPlanarGraph = function (floorId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var key, res, data;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._dbMng) return [3, 2];
                            key = DataSource.generateKey(floorId, options);
                            return [4, this._dbMng.select('geojson', key)];
                        case 1:
                            res = _a.sent();
                            if (res) {
                                requestAnimationFrame(function () { return _this._requestPlanarGraph(floorId, options, true); });
                                return [2, DataSource.parsePlanarGraph(this._decrypt(res.data))];
                            }
                            _a.label = 2;
                        case 2: return [4, this._requestPlanarGraph(floorId, options)];
                        case 3:
                            data = _a.sent();
                            return [2, DataSource.parsePlanarGraph(this._decrypt(data))];
                    }
                });
            });
        };
        DataSource.prototype._requestPlanarGraph = function (floorId, options, isUpdate) {
            if (isUpdate === void 0) { isUpdate = false; }
            return __awaiter(this, void 0, void 0, function () {
                var url, key, result, _a, key_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            url = this._server + "/geojson/" + floorId;
                            key = encodeURIComponent('Palmap+2017');
                            if (!this._isAPI_SDK) return [3, 2];
                            return [4, new HttpClient().get(url, __assign$1(__assign$1({}, (this._appKey ? { headers: { appKey: this._appKey } } : {})), { query: __assign$1({ coordinateType: 2 }, options), responseType: 'arraybuffer' }))];
                        case 1:
                            _a = _b.sent();
                            return [3, 4];
                        case 2: return [4, new HttpClient().get(url, {
                                query: __assign$1({ key: key, coordinateType: 2 }, options),
                            })];
                        case 3:
                            _a = _b.sent();
                            _b.label = 4;
                        case 4:
                            result = _a;
                            if (this._dbMng) {
                                key_1 = DataSource.generateKey(floorId, options);
                                isUpdate ?
                                    this._dbMng.update('geojson', { floorId: key_1, data: result }) :
                                    this._dbMng.insert('geojson', { floorId: key_1, data: result });
                            }
                            return [2, result];
                    }
                });
            });
        };
        DataSource.generateKey = function (id, options) {
            if (options.version) {
                return id + "_" + options.version;
            }
            return id;
        };
        DataSource.parsePlanarGraph = function (planarGraph) {
            var area = planarGraph.area, frame = planarGraph.frame, facility = planarGraph.facility, shop = planarGraph.shop;
            return {
                area: area.features || [],
                shop: (shop && shop.features) || [],
                frame: frame.features || [],
                facility: facility.features || [],
            };
        };
        DataSource.getTextByArea = function (features) {
            var result = [];
            for (var i = 0; i < features.length; i += 1) {
                var properties = features[i].properties;
                properties && (properties.labelpoint || properties.center) &&
                    result.push(createFeaturePoint(properties.labelpoint || properties.center, properties));
            }
            return result;
        };
        DataSource.SECURITY_KEY = 'MDbGUVkWecymbrveAkwXwRVhAYRUDParAPuSftqdmaeNmNcansDOyeVpnMSOSwTC';
        return DataSource;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends (d, b) {
        extendStatics(d, b);
        function __ () { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function () {
        __assign = Object.assign || function __assign (t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function isString (str) {
        return typeof str === 'string';
    }
    function isFunction (fun) {
        return typeof fun === 'function';
    }
    var NCore = (function () {
        function NCore () {
            this.listeners = {};
            this.onetimeListeners = {};
        }
        NCore.prototype.on = function (type, listener) {
            if (!isString(type) || !isFunction(listener)) {
                console.warn('on: expect on(type: string, listener: Function)');
                return this;
            }
            if (this.listeners[type]) {
                this.listeners[type].push(listener);
            }
            else {
                this.listeners[type] = [listener];
            }
            return this;
        };
        NCore.prototype.once = function (type, listener) {
            if (!isString(type) || !isFunction(listener)) {
                console.warn('once: expect on(type: string, listener: Function)');
                return this;
            }
            if (this.onetimeListeners[type]) {
                this.onetimeListeners[type].push(listener);
            }
            else {
                this.onetimeListeners[type] = [listener];
            }
            return this;
        };
        NCore.prototype.off = function (type, listener) {
            if (!isString(type) || !isFunction(listener)) {
                console.warn('off: expect on(type: string, listener: Function)');
                return this;
            }
            var arr = this.listeners[type];
            for (var i = arr.length - 1; i >= 0; i -= 1) {
                if (arr[i] === listener) {
                    arr.splice(i, 1);
                }
            }
            var onetimeArr = this.onetimeListeners[type];
            for (var i = onetimeArr.length - 1; i >= 0; i -= 1) {
                if (onetimeArr[i] === listener) {
                    onetimeArr.splice(i, 1);
                }
            }
            return this;
        };
        NCore.prototype.fire = function (type, eventData) {
            var arr = this.listeners[type] || [];
            for (var i = 0; i < arr.length; i += 1) {
                arr[i](eventData);
            }
            var onetimeArr = this.onetimeListeners[type] || [];
            for (var i = 0; i < onetimeArr.length; i += 1) {
                onetimeArr[i](eventData);
            }
            this.onetimeListeners[type] = [];
            return this;
        };
        NCore.prototype.clearListeners = function () {
            this.listeners = {};
            this.onetimeListeners = {};
        };
        return NCore;
    }());

    var SocketManager = (function (_super) {
        __extends(SocketManager, _super);
        function SocketManager (url) {
            var _this = _super.call(this) || this;
            _this.Open = false;
            _this.onSocketOpen = _this.onSocketOpen.bind(_this);
            _this.onSocketClose = _this.onSocketClose.bind(_this);
            _this.onMessage = _this.onMessage.bind(_this);
            _this.onError = _this.onError.bind(_this);
            _this.url = url;
            _this.socket = new WebSocket(_this.url);
            reconnect(_this);
            _this.initSocket();
            _this.heartbeatTimer = setInterval(function () {
                _this.send('heartbeat');
            }, 30 * 1000);
            return _this;
        }
        SocketManager.prototype.initSocket = function () {
            this.socket.addEventListener('open', this.onSocketOpen);
            this.socket.addEventListener('message', this.onMessage);
            this.socket.addEventListener('error', this.onError);
            this.socket.addEventListener('close', this.onSocketClose);
        };
        SocketManager.prototype.onSocketOpen = function () {
            this.Open = true;
        };
        SocketManager.prototype.onSocketClose = function () {
            this.Open = false;
        };
        SocketManager.prototype.send = function (msg) {
            if (!this.Open)
                return;
            this.socket.send(msg);
        };
        SocketManager.prototype.onMessage = function (e) {
            this.fire('message', e.data);
        };
        SocketManager.prototype.onError = function (err) {
            this.Open = false;
            this.socket.close();
            this.socket = new WebSocket(this.url);
            reconnect(this);
            this.initSocket();
            this.fire('error', err);
        };
        SocketManager.prototype.destroy = function () {
            clearInterval(this.heartbeatTimer);
            this.newTimer && clearInterval(this.newTimer);
            this.socket.close();
        };
        return SocketManager;
    }(NCore));
    function reconnect (SocketManager) {
        SocketManager.newTimer = setTimeout(function () {
            if (!!SocketManager.socket) {
                SocketManager.socket.close();
                SocketManager.socket = new WebSocket(SocketManager.url);
                clearTimeout(SocketManager.newTimer);
                // LogMgr.log('socket 閲嶅惎浜�');
                reconnect(SocketManager);
                SocketManager.initSocket();
            }
        }, 10 * 1000);
    }

    function isIPhone () {
        var reg = /iphone/ig;
        return reg.test(navigator.userAgent);
    }
    function checkDeviceType () {
        var userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.indexOf('android') > -1)
            return 'Android';
        else if (userAgent.indexOf('iphone') > -1)
            return 'iOS';
        return 'other';
    }

    var BleManager = (function () {
        function BleManager (options) {
            this.searchBeaconsCbs = [];
            this.getSignatureCbs = [];
            this.errorCbs = [];
            this.completeCbs = [];
            this.startBeaconsStatus = '';
            this.options = options;
            if (!this.checkBleType(options.bleType))
                return;
            this.init();
        }
        BleManager.prototype.init = function () {
            var _this = this;
            var _a = this.options, bleType = _a.bleType, socket = _a.socket, openId = _a.openId;
            if (bleType === 'wx') {
                if (openId) {
                    this.socketMng = new SocketManager(socket + '/' + openId);
                    this.socketMng.on('message', function (data) {
                        if (typeof data === 'string') {
                            if (/^([\[{])/.test(data)) {
                                data = JSON.parse(data);
                                _this.exec(_this.searchBeaconsCbs, data);
                            }
                            else {
                                data = [];
                            }
                        }
                        _this.exec(_this.searchBeaconsCbs, data);
                    });
                }
            }
            else if (bleType === 'native') {
                LogMgr.log('native');
                this.nativeConfig();
            }
        };
        BleManager.prototype.checkBleType = function (bleType) {
            if (bleType === 'wx') {
                if (!window.wx) {
                    console.error('BleManager: 寰俊 SDK is required');
                    return false;
                }
                var _a = this.options, signatureUrl = _a.signatureUrl, appId = _a.appId;
                if (!signatureUrl || !appId) {
                    console.error('BleManager: bleType is wx require signatureUrl and appId');
                    return false;
                }
            }
            else if (bleType === 'native') {
                var uuid = this.options.uuid;
                if (!uuid) {
                    console.error('BleManager: bleType is native require uuid');
                }
            }
            return true;
        };
        BleManager.prototype.nativeConfig = function () {
            var _this = this;
            this.stop();
            var uuid = this.options.uuid;
            window.onSearchBeacon = function (event) {
                if (typeof event === "string") {
                    if (/^([\[])/.test(event)) {
                        event = JSON.parse(event);
                    }
                    else {
                        console.error("BleManager: Beacon format is incorrect.");
                        return;
                    }
                }
                _this.exec(_this.searchBeaconsCbs, BleManager.processBeacons(event));
            };
            var params = JSON.stringify({ uuid: uuid });
            if (isIPhone()) {
                var webkit = window.webkit;
                webkit && webkit.messageHandlers.nativeBLEStart.postMessage(params);
                LogMgr.log('iphone');
            }
            else {
                var javaInterface = window.javaInterface;
                javaInterface && javaInterface.nativeBLEStart(params);
                LogMgr.log('瀹夊崜');
            }
        };
        BleManager.prototype.exec = function (cbs, data) {
            for (var _i = 0, cbs_1 = cbs; _i < cbs_1.length; _i++) {
                var key = cbs_1[_i];
                key(data);
            }
        };
        BleManager.prototype.stop = function () {
            var bleType = this.options.bleType;
            if (bleType === 'native') {
                var userAgent = navigator.userAgent;
                if (userAgent.toLowerCase().indexOf('iphone') !== -1) {
                    var webkit = window.webkit;
                    webkit && webkit.messageHandlers.nativeBLEStop.postMessage(JSON.stringify({}));
                }
                else {
                    var javaInterface = window.javaInterface;
                    javaInterface && javaInterface.nativeBLEStop();
                }
            }
            else if (bleType === 'wx') {
                this.socketMng.destroy();
            }
        };
        BleManager.prototype.registerError = function (callback) {
            if (typeof callback === "function") {
                this.errorCbs.push(callback);
            }
        };
        BleManager.prototype.unregisterError = function (cb) {
            var index = this.errorCbs.indexOf(cb);
            index !== -1 && this.errorCbs.splice(index, 1);
        };
        BleManager.prototype.registerStartComplete = function (cb) {
            if (typeof cb === 'function') {
                this.completeCbs.push(cb);
            }
        };
        BleManager.prototype.unregisterStartComplete = function (cb) {
            var index = this.completeCbs.indexOf(cb);
            index !== -1 && this.completeCbs.splice(index, 1);
        };
        BleManager.prototype.registerSearchBeacon = function (cb) {
            if (typeof cb === 'function') {
                this.searchBeaconsCbs.push(cb);
            }
        };
        BleManager.prototype.unregisterSearchBeacon = function (cb) {
            var index = this.searchBeaconsCbs.indexOf(cb);
            index !== -1 && this.searchBeaconsCbs.splice(index, 1);
        };
        BleManager.prototype.registerGetSignature = function (cb) {
            if (typeof cb === 'function') {
                this.getSignatureCbs.push(cb);
            }
        };
        BleManager.prototype.getStartBeaconStatus = function () {
            return this.startBeaconsStatus;
        };
        BleManager.processBeacons = function (beacons) {
            if (beacons === void 0) { beacons = []; }
            var arr = [];
            for (var i = 0; i < beacons.length; i += 1) {
                if (Number(beacons[i].rssi) !== 0) {
                    arr.push(beacons[i]);
                }
            }
            return arr;
        };
        return BleManager;
    }());

    function parseUrl (url) {
        var parStr = url.split("?")[1];
        var res = {};
        if (!parStr) {
            return res;
        }
        var parArr = parStr.split("&");
        for (var i = 0; i < parArr.length; i += 1) {
            var arr = parArr[i].split("=");
            res[arr[0]] = arr[1];
        }
        return res;
    }
    function checkLocation (location) {
        return location && Number(location.x) !== 0 && Number(location.y) !== 0;
    }
    function convertPoint (point) {
        if (Array.isArray(point) && point.length === 2) {
            return { x: point[0], y: point[1] };
        }
        else if (!Array.isArray(point) && point.x && point.y) {
            return point;
        }
        return { x: 0, y: 0 };
    }
    function getDistance (point1, point2) {
        var p1 = convertPoint(point1), p2 = convertPoint(point2), stepX = p2.x - p1.x, stepY = p2.y - p1.y;
        return Math.sqrt(Math.pow(stepX, 2) + Math.pow(stepY, 2));
    }

    function createWorker (file) {
        var WebWorker = (function () {
            function WebWorker () {
                var _this = this;
                this._listener = {};
                this.onmessage = null;
                this.onerror = null;
                this._url = URL.createObjectURL(new Blob([file]));
                this._worker = new Worker(this._url);
                URL.revokeObjectURL(this._url);
                this._worker.onmessage = function (e) {
                    typeof _this.onmessage === 'function' && _this.onmessage(e);
                    var arr = _this._listener.message || [];
                    for (var i = 0; i < arr.length; i += 1) {
                        arr[i](e);
                    }
                };
                this._worker.onerror = function (e) {
                    typeof _this.onerror === 'function' && _this.onerror(e);
                    var arr = _this._listener.error || [];
                    for (var i = 0; i < arr.length; i += 1) {
                        arr[i](e);
                    }
                };
            }
            WebWorker.prototype.postMessage = function (e) {
                this._worker.postMessage(e);
            };
            WebWorker.prototype.addEventListener = function (type, fun) {
                if (this._listener[type]) {
                    this._listener[type].push(fun);
                }
                else {
                    this._listener[type] = [fun];
                }
            };
            WebWorker.prototype.removeEventListener = function (type, fun) {
                var arr = this._listener[type] || [];
                var index = arr.indexOf(fun);
                index !== -1 && arr.splice(index, 1);
            };
            WebWorker.prototype.terminate = function () {
                this._worker.terminate();
            };
            return WebWorker;
        }());
        return WebWorker;
    }

    var AverageWorker = createWorker("!function(){\"use strict\";var e=function(t,r){return(e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(t[o]=r[o])})(t,r)};function k(t,r){function o(){this.constructor=t}e(t,r),t.prototype=null===r?Object.create(r):(o.prototype=r.prototype,new o)}var c=function(){return(c=Object.assign||function(t){for(var r,o=1,e=arguments.length;o<e;o++)for(var n in r=arguments[o])Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n]);return t}).apply(this,arguments)};function t(t,s,a,u){return new(a=a||Promise)(function(o,r){function e(t){try{i(u.next(t))}catch(t){r(t)}}function n(t){try{i(u.throw(t))}catch(t){r(t)}}function i(t){var r;t.done?o(t.value):((r=t.value)instanceof a?r:new a(function(t){t(r)})).then(e,n)}i((u=u.apply(t,s||[])).next())})}function h(o,e){var n,i,s,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]},t={next:r(0),throw:r(1),return:r(2)};return\"function\"==typeof Symbol&&(t[Symbol.iterator]=function(){return this}),t;function r(r){return function(t){return function(r){if(n)throw new TypeError(\"Generator is already executing.\");for(;a;)try{if(n=1,i&&(s=2&r[0]?i.return:r[0]?i.throw||((s=i.return)&&s.call(i),0):i.next)&&!(s=s.call(i,r[1])).done)return s;switch(i=0,s&&(r=[2&r[0],s.value]),r[0]){case 0:case 1:s=r;break;case 4:return a.label++,{value:r[1],done:!1};case 5:a.label++,i=r[1],r=[0];continue;case 7:r=a.ops.pop(),a.trys.pop();continue;default:if(!(s=0<(s=a.trys).length&&s[s.length-1])&&(6===r[0]||2===r[0])){a=0;continue}if(3===r[0]&&(!s||r[1]>s[0]&&r[1]<s[3])){a.label=r[1];break}if(6===r[0]&&a.label<s[1]){a.label=s[1],s=r;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(r);break}s[2]&&a.ops.pop(),a.trys.pop();continue}r=e.call(o,a)}catch(t){r=[6,t],i=0}finally{n=s=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,t])}}}var r=Object.prototype.toString;function o(t){return r.call(t).endsWith(\"Array]\")}var n,i=(n=o)&&\"object\"==typeof n&&\"default\"in n?n.default:n;function s(t){if(!i(t))throw new TypeError(\"input must be an array\");if(0===t.length)throw new TypeError(\"input must not be empty\");for(var r=t[0],o=1;o<t.length;o++)t[o]>r&&(r=t[o]);return r}var a,u=(a=o)&&\"object\"==typeof a&&\"default\"in a?a.default:a;function f(t){if(!u(t))throw new TypeError(\"input must be an array\");if(0===t.length)throw new TypeError(\"input must not be empty\");for(var r=t[0],o=1;o<t.length;o++)t[o]<r&&(r=t[o]);return r}function l(t){return t&&\"object\"==typeof t&&\"default\"in t?t.default:t}var p=l(o),m=l(s),g=l(f);var w,L=function(t,r){if(void 0===r&&(r={}),!p(t))throw new TypeError(\"input must be an array\");if(0===t.length)throw new TypeError(\"input must not be empty\");var o;if(void 0!==r.output){if(!p(r.output))throw new TypeError(\"output option must be an array if specified\");o=r.output}else o=new Array(t.length);var e=g(t),n=m(t);if(e===n)throw new RangeError(\"minimum and maximum input values are equal. Cannot rescale a constant array\");var i=r.min,s=void 0===i?r.autoMinMax?e:0:i,a=r.max,u=void 0===a?r.autoMinMax?n:1:a;if(u<=s)throw new RangeError(\"min option must be smaller than max option\");for(var h=(u-s)/(n-e),f=0;f<t.length;f++)o[f]=(t[f]-e)*h+s;return o},G=(k(v,w=lt()),v.prototype.set=function(t,r,o){return this.data[t][r]=o,this},v.prototype.get=function(t,r){return this.data[t][r]},Object.defineProperty(v,Symbol.species,{get:function(){return mt},enumerable:!1,configurable:!0}),v);function v(t){var r=w.call(this)||this;return r.data=t,r.rows=t.length,r.columns=t[0].length,r}var N=(y.prototype.isSingular=function(){for(var t=this.LU,r=t.columns,o=0;o<r;o++)if(0===t[o][o])return!0;return!1},y.prototype.solve=function(t){t=mt.checkMatrix(t);var r=this.LU;if(r.rows!==t.rows)throw new Error(\"Invalid matrix dimensions\");if(this.isSingular())throw new Error(\"LU matrix is singular\");for(var o,e,n=t.columns,i=t.subMatrixRow(this.pivotVector,0,n-1),s=r.columns,a=0;a<s;a++)for(o=a+1;o<s;o++)for(e=0;e<n;e++)i[o][e]-=i[a][e]*r[o][a];for(a=s-1;0<=a;a--){for(e=0;e<n;e++)i[a][e]/=r[a][a];for(o=0;o<a;o++)for(e=0;e<n;e++)i[o][e]-=i[a][e]*r[o][a]}return i},Object.defineProperty(y.prototype,\"determinant\",{get:function(){var t=this.LU;if(!t.isSquare())throw new Error(\"Matrix must be square\");for(var r=this.pivotSign,o=t.columns,e=0;e<o;e++)r*=t[e][e];return r},enumerable:!1,configurable:!0}),Object.defineProperty(y.prototype,\"lowerTriangularMatrix\",{get:function(){for(var t=this.LU,r=t.rows,o=t.columns,e=new mt(r,o),n=0;n<r;n++)for(var i=0;i<o;i++)e[n][i]=i<n?t[n][i]:n===i?1:0;return e},enumerable:!1,configurable:!0}),Object.defineProperty(y.prototype,\"upperTriangularMatrix\",{get:function(){for(var t=this.LU,r=t.rows,o=t.columns,e=new mt(r,o),n=0;n<r;n++)for(var i=0;i<o;i++)e[n][i]=n<=i?t[n][i]:0;return e},enumerable:!1,configurable:!0}),Object.defineProperty(y.prototype,\"pivotPermutationVector\",{get:function(){return this.pivotVector.slice()},enumerable:!1,configurable:!0}),y);function y(t){for(var r,o,e,n,i,s,a,u,h=(t=G.checkMatrix(t)).clone(),f=h.rows,c=h.columns,l=new Array(f),p=1,m=0;m<f;m++)l[m]=m;for(a=new Array(f),r=0;r<c;r++){for(m=0;m<f;m++)a[m]=h.get(m,r);for(m=0;m<f;m++){for(u=Math.min(m,r),o=n=0;o<u;o++)n+=h.get(m,o)*a[o];a[m]-=n,h.set(m,r,a[m])}for(m=(e=r)+1;m<f;m++)Math.abs(a[m])>Math.abs(a[e])&&(e=m);if(e!==r){for(o=0;o<c;o++)i=h.get(e,o),h.set(e,o,h.get(r,o)),h.set(r,o,i);s=l[e],l[e]=l[r],l[r]=s,p=-p}if(r<f&&0!==h.get(r,r))for(m=r+1;m<f;m++)h.set(m,r,h.get(m,r)/h.get(r,r))}this.LU=h,this.pivotVector=l,this.pivotSign=p}function K(t,r){var o=0;return Math.abs(t)>Math.abs(r)?(o=r/t,Math.abs(t)*Math.sqrt(1+o*o)):0!==r?(o=t/r,Math.abs(r)*Math.sqrt(1+o*o)):0}function Z(t,r,o){for(var e=new Array(t),n=0;n<t;n++){e[n]=new Array(r);for(var i=0;i<r;i++)e[n][i]=o}return e}var q=(d.prototype.solve=function(t){for(var r=t,o=this.threshold,e=this.s.length,n=mt.zeros(e,e),i=0;i<e;i++)Math.abs(this.s[i])<=o?n[i][i]=0:n[i][i]=1/this.s[i];for(var s=this.U,a=this.rightSingularVectors,u=a.mmul(n),h=a.rows,f=s.length,c=mt.zeros(h,f),i=0;i<h;i++)for(var l=0;l<f;l++){for(var p=0,m=0;m<e;m++)p+=u[i][m]*s[l][m];c[i][l]=p}return c.mmul(r)},d.prototype.solveForDiagonal=function(t){return this.solve(mt.diag(t))},d.prototype.inverse=function(){for(var t=this.V,r=this.threshold,o=t.length,e=t[0].length,n=new mt(o,this.s.length),i=0;i<o;i++)for(var s=0;s<e;s++)Math.abs(this.s[s])>r?n[i][s]=t[i][s]/this.s[s]:n[i][s]=0;for(var a=this.U,u=a.length,h=a[0].length,f=new mt(o,u),i=0;i<o;i++)for(s=0;s<u;s++){for(var c=0,l=0;l<h;l++)c+=n[i][l]*a[s][l];f[i][s]=c}return f},Object.defineProperty(d.prototype,\"condition\",{get:function(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]},enumerable:!1,configurable:!0}),Object.defineProperty(d.prototype,\"norm2\",{get:function(){return this.s[0]},enumerable:!1,configurable:!0}),Object.defineProperty(d.prototype,\"rank\",{get:function(){for(var t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,r=0,o=this.s,e=0,n=o.length;e<n;e++)o[e]>t&&r++;return r},enumerable:!1,configurable:!0}),Object.defineProperty(d.prototype,\"diagonal\",{get:function(){return this.s},enumerable:!1,configurable:!0}),Object.defineProperty(d.prototype,\"threshold\",{get:function(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]},enumerable:!1,configurable:!0}),Object.defineProperty(d.prototype,\"leftSingularVectors\",{get:function(){return mt.isMatrix(this.U)||(this.U=new mt(this.U)),this.U},enumerable:!1,configurable:!0}),Object.defineProperty(d.prototype,\"rightSingularVectors\",{get:function(){return mt.isMatrix(this.V)||(this.V=new mt(this.V)),this.V},enumerable:!1,configurable:!0}),Object.defineProperty(d.prototype,\"diagonalMatrix\",{get:function(){return mt.diag(this.s)},enumerable:!1,configurable:!0}),d);function d(t,r){void 0===r&&(r={});var o,e,n=(t=G.checkMatrix(t)).rows,i=t.columns,s=r.computeLeftSingularVectors,a=void 0===s||s,u=r.computeRightSingularVectors,h=void 0===u||u,f=r.autoTranspose,c=void 0!==f&&f,l=Boolean(a),p=Boolean(h),m=!1;n<i?c?(n=(o=t.transpose()).rows,i=o.columns,m=!0,e=l,l=p,p=e):(o=t.clone(),console.warn(\"Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose\")):o=t.clone();for(var g=Math.min(n,i),w=Math.min(n+1,i),v=new Array(w),y=Z(n,g,0),d=Z(i,i,0),b=new Array(i),M=new Array(n),x=new Array(w),R=0;R<w;R++)x[R]=R;for(var S=Math.min(n-1,i),j=Math.max(0,Math.min(i-2,n)),E=Math.max(S,j),A=0;A<E;A++){if(A<S){v[A]=0;for(R=A;R<n;R++)v[A]=K(v[A],o[R][A]);if(0!==v[A]){o[A][A]<0&&(v[A]=-v[A]);for(R=A;R<n;R++)o[R][A]/=v[A];o[A][A]+=1}v[A]=-v[A]}for(var P=A+1;P<i;P++){if(A<S&&0!==v[A]){for(var C=0,R=A;R<n;R++)C+=o[R][A]*o[R][P];C=-C/o[A][A];for(R=A;R<n;R++)o[R][P]+=C*o[R][A]}b[P]=o[A][P]}if(l&&A<S)for(R=A;R<n;R++)y[R][A]=o[R][A];if(A<j){b[A]=0;for(R=A+1;R<i;R++)b[A]=K(b[A],b[R]);if(0!==b[A]){b[A+1]<0&&(b[A]=0-b[A]);for(R=A+1;R<i;R++)b[R]/=b[A];b[A+1]+=1}if(b[A]=-b[A],A+1<n&&0!==b[A]){for(R=A+1;R<n;R++)M[R]=0;for(R=A+1;R<n;R++)for(P=A+1;P<i;P++)M[R]+=b[P]*o[R][P];for(P=A+1;P<i;P++)for(C=-b[P]/b[A+1],R=A+1;R<n;R++)o[R][P]+=C*M[R]}if(p)for(R=A+1;R<i;R++)d[R][A]=b[R]}}var V=Math.min(i,n+1);if(S<i&&(v[S]=o[S][S]),n<V&&(v[V-1]=0),j+1<V&&(b[j]=o[j][V-1]),b[V-1]=0,l){for(P=S;P<g;P++){for(R=0;R<n;R++)y[R][P]=0;y[P][P]=1}for(A=S-1;0<=A;A--)if(0!==v[A]){for(P=A+1;P<g;P++){for(C=0,R=A;R<n;R++)C+=y[R][A]*y[R][P];C=-C/y[A][A];for(R=A;R<n;R++)y[R][P]+=C*y[R][A]}for(R=A;R<n;R++)y[R][A]=-y[R][A];y[A][A]=1+y[A][A];for(R=0;R<A-1;R++)y[R][A]=0}else{for(R=0;R<n;R++)y[R][A]=0;y[A][A]=1}}if(p)for(A=i-1;0<=A;A--){if(A<j&&0!==b[A])for(P=A+1;P<i;P++){for(C=0,R=A+1;R<i;R++)C+=d[R][A]*d[R][P];C=-C/d[A+1][A];for(R=A+1;R<i;R++)d[R][P]+=C*d[R][A]}for(R=0;R<i;R++)d[R][A]=0;d[A][A]=1}for(var I,O=V-1,k=Number.EPSILON;0<V;){var A=void 0,L=void 0;for(A=V-2;-1<=A&&-1!==A;A--){var N=Number.MIN_VALUE+k*Math.abs(v[A]+Math.abs(v[A+1]));if(Math.abs(b[A])<=N||Number.isNaN(b[A])){b[A]=0;break}}if(A===V-2)L=4;else{for(var q=void 0,q=V-1;A<=q&&q!==A;q--){C=(q!==V?Math.abs(b[q]):0)+(q!==A+1?Math.abs(b[q-1]):0);if(Math.abs(v[q])<=k*C){v[q]=0;break}}q===A?L=3:q===V-1?L=1:(L=2,A=q)}switch(A++,L){case 1:var T=b[V-2];b[V-2]=0;for(P=V-2;A<=P;P--){var C=K(v[P],T),B=v[P]/C,D=T/C;if(v[P]=C,P!==A&&(T=-D*b[P-1],b[P-1]=B*b[P-1]),p)for(R=0;R<i;R++)C=B*d[R][P]+D*d[R][V-1],d[R][V-1]=-D*d[R][P]+B*d[R][V-1],d[R][P]=C}break;case 2:T=b[A-1];b[A-1]=0;for(P=A;P<V;P++){C=K(v[P],T),B=v[P]/C,D=T/C;if(v[P]=C,T=-D*b[P],b[P]=B*b[P],l)for(R=0;R<n;R++)C=B*y[R][P]+D*y[R][A-1],y[R][A-1]=-D*y[R][P]+B*y[R][A-1],y[R][P]=C}break;case 3:var U=Math.max(Math.abs(v[V-1]),Math.abs(v[V-2]),Math.abs(b[V-2]),Math.abs(v[A]),Math.abs(b[A])),z=v[V-1]/U,W=v[V-2]/U,_=b[V-2]/U,Q=v[A]/U,F=b[A]/U,H=((W+z)*(W-z)+_*_)/2,X=z*_*(z*_),J=0;0==H&&0==X||(J=X/(H+(J=H<0?0-Math.sqrt(H*H+X):Math.sqrt(H*H+X))));for(var T=(Q+z)*(Q-z)+J,Y=Q*F,P=A;P<V-1;P++){0===(C=K(T,Y))&&(C=Number.MIN_VALUE);B=T/C,D=Y/C;if(P!==A&&(b[P-1]=C),T=B*v[P]+D*b[P],b[P]=B*b[P]-D*v[P],Y=D*v[P+1],v[P+1]=B*v[P+1],p)for(R=0;R<i;R++)C=B*d[R][P]+D*d[R][P+1],d[R][P+1]=-D*d[R][P]+B*d[R][P+1],d[R][P]=C;if(0===(C=K(T,Y))&&(C=Number.MIN_VALUE),B=T/C,D=Y/C,v[P]=C,T=B*b[P]+D*v[P+1],v[P+1]=-D*b[P]+B*v[P+1],Y=D*b[P+1],b[P+1]=B*b[P+1],l&&P<n-1)for(R=0;R<n;R++)C=B*y[R][P]+D*y[R][P+1],y[R][P+1]=-D*y[R][P]+B*y[R][P+1],y[R][P]=C}b[V-2]=T;break;case 4:if(v[A]<=0&&(v[A]=v[A]<0?-v[A]:0,p))for(R=0;R<=O;R++)d[R][A]=-d[R][A];for(;A<O&&!(v[A]>=v[A+1]);){C=v[A];if(v[A]=v[A+1],v[A+1]=C,p&&A<i-1)for(R=0;R<i;R++)C=d[R][A+1],d[R][A+1]=d[R][A],d[R][A]=C;if(l&&A<n-1)for(R=0;R<n;R++)C=y[R][A+1],y[R][A+1]=y[R][A],y[R][A]=C;A++}V--}}m&&(I=d,d=y,y=I),this.m=n,this.n=i,this.s=v,this.U=y,this.V=d}function T(t,r,o){var e=o?t.rows:t.rows-1;if(r<0||e<r)throw new RangeError(\"Row index out of range\")}function B(t,r,o){var e=o?t.columns:t.columns-1;if(r<0||e<r)throw new RangeError(\"Column index out of range\")}function D(t,r){if(r.to1DArray&&(r=r.to1DArray()),r.length!==t.columns)throw new RangeError(\"vector size must be the same as the number of columns\");return r}function U(t,r){if(r.to1DArray&&(r=r.to1DArray()),r.length!==t.rows)throw new RangeError(\"vector size must be the same as the number of rows\");return r}function z(t,r,o){return{row:b(t,r),column:M(t,o)}}function b(r,t){if(\"object\"!=typeof t)throw new TypeError(\"unexpected type for row indices\");if(t.some(function(t){return t<0||t>=r.rows}))throw new RangeError(\"row indices are out of range\");return Array.isArray(t)||(t=Array.from(t)),t}function M(r,t){if(\"object\"!=typeof t)throw new TypeError(\"unexpected type for column indices\");if(t.some(function(t){return t<0||t>=r.columns}))throw new RangeError(\"column indices are out of range\");return Array.isArray(t)||(t=Array.from(t)),t}function W(t,r,o,e,n){if(5!==arguments.length)throw new RangeError(\"expected 4 arguments\");if(x(\"startRow\",r),x(\"endRow\",o),x(\"startColumn\",e),x(\"endColumn\",n),o<r||n<e||r<0||r>=t.rows||o<0||o>=t.rows||e<0||e>=t.columns||n<0||n>=t.columns)throw new RangeError(\"Submatrix indices are out of range\")}function x(t,r){if(\"number\"!=typeof r)throw new TypeError(t+\" must be a number\")}var R,S=(k(j,R=lt()),Object.defineProperty(j,Symbol.species,{get:function(){return mt},enumerable:!1,configurable:!0}),j);function j(t,r,o){var e=R.call(this)||this;return e.matrix=t,e.rows=r,e.columns=o,e}var E,_=(k(A,E=S),A.prototype.set=function(t,r,o){return this.matrix.set(r,t,o),this},A.prototype.get=function(t,r){return this.matrix.get(r,t)},A);function A(t){return E.call(this,t,t.columns,t.rows)||this}var P,Q=(k(C,P=S),C.prototype.set=function(t,r,o){return this.matrix.set(this.row,r,o),this},C.prototype.get=function(t,r){return this.matrix.get(this.row,r)},C);function C(t,r){var o=P.call(this,t,1,t.columns)||this;return o.row=r,o}var V,F=(k(I,V=S),I.prototype.set=function(t,r,o){return this.matrix.set(this.startRow+t,this.startColumn+r,o),this},I.prototype.get=function(t,r){return this.matrix.get(this.startRow+t,this.startColumn+r)},I);function I(t,r,o,e,n){var i=this;return W(t,r,o,e,n),(i=V.call(this,t,o-r+1,n-e+1)||this).startRow=r,i.startColumn=e,i}var O,H=(k(X,O=S),X.prototype.set=function(t,r,o){return this.matrix.set(this.rowIndices[t],this.columnIndices[r],o),this},X.prototype.get=function(t,r){return this.matrix.get(this.rowIndices[t],this.columnIndices[r])},X);function X(t,r,o){var e=this,n=z(t,r,o);return(e=O.call(this,t,n.row.length,n.column.length)||this).rowIndices=n.row,e.columnIndices=n.column,e}var J,Y=(k($,J=S),$.prototype.set=function(t,r,o){return this.matrix.set(this.rowIndices[t],r,o),this},$.prototype.get=function(t,r){return this.matrix.get(this.rowIndices[t],r)},$);function $(t,r){var o=this;return r=b(t,r),(o=J.call(this,t,r.length,t.columns)||this).rowIndices=r,o}var tt,rt=(k(ot,tt=S),ot.prototype.set=function(t,r,o){return this.matrix.set(t,this.columnIndices[r],o),this},ot.prototype.get=function(t,r){return this.matrix.get(t,this.columnIndices[r])},ot);function ot(t,r){var o=this;return r=M(t,r),(o=tt.call(this,t,t.rows,r.length)||this).columnIndices=r,o}var et,nt=(k(it,et=S),it.prototype.set=function(t,r,o){return this.matrix.set(t,this.column,o),this},it.prototype.get=function(t){return this.matrix.get(t,this.column)},it);function it(t,r){var o=et.call(this,t,t.rows,1)||this;return o.column=r,o}var st,at=(k(ut,st=S),ut.prototype.set=function(t,r,o){return this.matrix.set(this.rows-t-1,r,o),this},ut.prototype.get=function(t,r){return this.matrix.get(this.rows-t-1,r)},ut);function ut(t){return st.call(this,t,t.rows,t.columns)||this}var ht,ft=(k(ct,ht=S),ct.prototype.set=function(t,r,o){return this.matrix.set(t,this.columns-r-1,o),this},ct.prototype.get=function(t,r){return this.matrix.get(t,this.columns-r-1)},ct);function ct(t){return ht.call(this,t,t.rows,t.columns)||this}function lt(t){void 0===t&&(t=Object);var e,r=(k(P,e=t),Object.defineProperty(P,Symbol.species,{get:function(){return this},enumerable:!1,configurable:!0}),P.from1DArray=function(t,r,o){if(t*r!==o.length)throw new RangeError(\"Data length does not match given dimensions\");for(var e=new this(t,r),n=0;n<t;n++)for(var i=0;i<r;i++)e.set(n,i,o[n*r+i]);return e},P.rowVector=function(t){for(var r=new this(1,t.length),o=0;o<t.length;o++)r.set(0,o,t[o]);return r},P.columnVector=function(t){for(var r=new this(t.length,1),o=0;o<t.length;o++)r.set(o,0,t[o]);return r},P.empty=function(t,r){return new this(t,r)},P.zeros=function(t,r){return this.empty(t,r).fill(0)},P.ones=function(t,r){return this.empty(t,r).fill(1)},P.rand=function(t,r,o){void 0===o&&(o=Math.random);for(var e=this.empty(t,r),n=0;n<t;n++)for(var i=0;i<r;i++)e.set(n,i,o());return e},P.randInt=function(t,r,o,e){void 0===o&&(o=1e3),void 0===e&&(e=Math.random);for(var n=this.empty(t,r),i=0;i<t;i++)for(var s=0;s<r;s++){var a=Math.floor(e()*o);n.set(i,s,a)}return n},P.eye=function(t,r,o){void 0===r&&(r=t),void 0===o&&(o=1);for(var e=Math.min(t,r),n=this.zeros(t,r),i=0;i<e;i++)n.set(i,i,o);return n},P.diag=function(t,r,o){var e=t.length;void 0===r&&(r=e),void 0===o&&(o=r);for(var n=Math.min(e,r,o),i=this.zeros(r,o),s=0;s<n;s++)i.set(s,s,t[s]);return i},P.min=function(t,r){t=this.checkMatrix(t),r=this.checkMatrix(r);for(var o=t.rows,e=t.columns,n=new this(o,e),i=0;i<o;i++)for(var s=0;s<e;s++)n.set(i,s,Math.min(t.get(i,s),r.get(i,s)));return n},P.max=function(t,r){t=this.checkMatrix(t),r=this.checkMatrix(r);for(var o=t.rows,e=t.columns,n=new this(o,e),i=0;i<o;i++)for(var s=0;s<e;s++)n.set(i,s,Math.max(t.get(i,s),r.get(i,s)));return n},P.checkMatrix=function(t){return P.isMatrix(t)?t:new this(t)},P.isMatrix=function(t){return null!=t&&\"Matrix\"===t.klass},Object.defineProperty(P.prototype,\"size\",{get:function(){return this.rows*this.columns},enumerable:!1,configurable:!0}),P.prototype.apply=function(t){if(\"function\"!=typeof t)throw new TypeError(\"callback must be a function\");for(var r=this.rows,o=this.columns,e=0;e<r;e++)for(var n=0;n<o;n++)t.call(this,e,n);return this},P.prototype.to1DArray=function(){for(var t=new Array(this.size),r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)t[r*this.columns+o]=this.get(r,o);return t},P.prototype.to2DArray=function(){for(var t=new Array(this.rows),r=0;r<this.rows;r++){t[r]=new Array(this.columns);for(var o=0;o<this.columns;o++)t[r][o]=this.get(r,o)}return t},P.prototype.isRowVector=function(){return 1===this.rows},P.prototype.isColumnVector=function(){return 1===this.columns},P.prototype.isVector=function(){return 1===this.rows||1===this.columns},P.prototype.isSquare=function(){return this.rows===this.columns},P.prototype.isSymmetric=function(){if(this.isSquare()){for(var t=0;t<this.rows;t++)for(var r=0;r<=t;r++)if(this.get(t,r)!==this.get(r,t))return!1;return!0}return!1},P.prototype.set=function(t,r,o){throw new Error(\"set method is unimplemented\")},P.prototype.get=function(t,r){throw new Error(\"get method is unimplemented\")},P.prototype.repeat=function(t,r){t=t||1,r=r||1;for(var o=new this.constructor[Symbol.species](this.rows*t,this.columns*r),e=0;e<t;e++)for(var n=0;n<r;n++)o.setSubMatrix(this,this.rows*e,this.columns*n);return o},P.prototype.fill=function(t){for(var r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.set(r,o,t);return this},P.prototype.neg=function(){return this.mulS(-1)},P.prototype.getRow=function(t){T(this,t);for(var r=new Array(this.columns),o=0;o<this.columns;o++)r[o]=this.get(t,o);return r},P.prototype.getRowVector=function(t){return this.constructor.rowVector(this.getRow(t))},P.prototype.setRow=function(t,r){T(this,t),r=D(this,r);for(var o=0;o<this.columns;o++)this.set(t,o,r[o]);return this},P.prototype.swapRows=function(t,r){T(this,t),T(this,r);for(var o=0;o<this.columns;o++){var e=this.get(t,o);this.set(t,o,this.get(r,o)),this.set(r,o,e)}return this},P.prototype.getColumn=function(t){B(this,t);for(var r=new Array(this.rows),o=0;o<this.rows;o++)r[o]=this.get(o,t);return r},P.prototype.getColumnVector=function(t){return this.constructor.columnVector(this.getColumn(t))},P.prototype.setColumn=function(t,r){B(this,t),r=U(this,r);for(var o=0;o<this.rows;o++)this.set(o,t,r[o]);return this},P.prototype.swapColumns=function(t,r){B(this,t),B(this,r);for(var o=0;o<this.rows;o++){var e=this.get(o,t);this.set(o,t,this.get(o,r)),this.set(o,r,e)}return this},P.prototype.addRowVector=function(t){t=D(this,t);for(var r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.set(r,o,this.get(r,o)+t[o]);return this},P.prototype.subRowVector=function(t){t=D(this,t);for(var r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.set(r,o,this.get(r,o)-t[o]);return this},P.prototype.mulRowVector=function(t){t=D(this,t);for(var r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.set(r,o,this.get(r,o)*t[o]);return this},P.prototype.divRowVector=function(t){t=D(this,t);for(var r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.set(r,o,this.get(r,o)/t[o]);return this},P.prototype.addColumnVector=function(t){t=U(this,t);for(var r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.set(r,o,this.get(r,o)+t[r]);return this},P.prototype.subColumnVector=function(t){t=U(this,t);for(var r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.set(r,o,this.get(r,o)-t[r]);return this},P.prototype.mulColumnVector=function(t){t=U(this,t);for(var r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.set(r,o,this.get(r,o)*t[r]);return this},P.prototype.divColumnVector=function(t){t=U(this,t);for(var r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.set(r,o,this.get(r,o)/t[r]);return this},P.prototype.mulRow=function(t,r){T(this,t);for(var o=0;o<this.columns;o++)this.set(t,o,this.get(t,o)*r);return this},P.prototype.mulColumn=function(t,r){B(this,t);for(var o=0;o<this.rows;o++)this.set(o,t,this.get(o,t)*r);return this},P.prototype.max=function(){for(var t=this.get(0,0),r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.get(r,o)>t&&(t=this.get(r,o));return t},P.prototype.maxIndex=function(){for(var t=this.get(0,0),r=[0,0],o=0;o<this.rows;o++)for(var e=0;e<this.columns;e++)this.get(o,e)>t&&(t=this.get(o,e),r[0]=o,r[1]=e);return r},P.prototype.min=function(){for(var t=this.get(0,0),r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)this.get(r,o)<t&&(t=this.get(r,o));return t},P.prototype.minIndex=function(){for(var t=this.get(0,0),r=[0,0],o=0;o<this.rows;o++)for(var e=0;e<this.columns;e++)this.get(o,e)<t&&(t=this.get(o,e),r[0]=o,r[1]=e);return r},P.prototype.maxRow=function(t){T(this,t);for(var r=this.get(t,0),o=1;o<this.columns;o++)this.get(t,o)>r&&(r=this.get(t,o));return r},P.prototype.maxRowIndex=function(t){T(this,t);for(var r=this.get(t,0),o=[t,0],e=1;e<this.columns;e++)this.get(t,e)>r&&(r=this.get(t,e),o[1]=e);return o},P.prototype.minRow=function(t){T(this,t);for(var r=this.get(t,0),o=1;o<this.columns;o++)this.get(t,o)<r&&(r=this.get(t,o));return r},P.prototype.minRowIndex=function(t){T(this,t);for(var r=this.get(t,0),o=[t,0],e=1;e<this.columns;e++)this.get(t,e)<r&&(r=this.get(t,e),o[1]=e);return o},P.prototype.maxColumn=function(t){B(this,t);for(var r=this.get(0,t),o=1;o<this.rows;o++)this.get(o,t)>r&&(r=this.get(o,t));return r},P.prototype.maxColumnIndex=function(t){B(this,t);for(var r=this.get(0,t),o=[0,t],e=1;e<this.rows;e++)this.get(e,t)>r&&(r=this.get(e,t),o[0]=e);return o},P.prototype.minColumn=function(t){B(this,t);for(var r=this.get(0,t),o=1;o<this.rows;o++)this.get(o,t)<r&&(r=this.get(o,t));return r},P.prototype.minColumnIndex=function(t){B(this,t);for(var r=this.get(0,t),o=[0,t],e=1;e<this.rows;e++)this.get(e,t)<r&&(r=this.get(e,t),o[0]=e);return o},P.prototype.diag=function(){for(var t=Math.min(this.rows,this.columns),r=new Array(t),o=0;o<t;o++)r[o]=this.get(o,o);return r},P.prototype.sum=function(t){switch(t){case\"row\":return function(t){for(var r=mt.zeros(t.rows,1),o=0;o<t.rows;++o)for(var e=0;e<t.columns;++e)r.set(o,0,r.get(o,0)+t.get(o,e));return r}(this);case\"column\":return function(t){for(var r=mt.zeros(1,t.columns),o=0;o<t.rows;++o)for(var e=0;e<t.columns;++e)r.set(0,e,r.get(0,e)+t.get(o,e));return r}(this);default:return function(t){for(var r=0,o=0;o<t.rows;o++)for(var e=0;e<t.columns;e++)r+=t.get(o,e);return r}(this)}},P.prototype.mean=function(){return this.sum()/this.size},P.prototype.prod=function(){for(var t=1,r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)t*=this.get(r,o);return t},P.prototype.norm=function(t){void 0===t&&(t=\"frobenius\");var r=0;if(\"max\"===t)return this.max();if(\"frobenius\"!==t)throw new RangeError(\"unknown norm type: \"+t);for(var o=0;o<this.rows;o++)for(var e=0;e<this.columns;e++)r+=this.get(o,e)*this.get(o,e);return Math.sqrt(r)},P.prototype.cumulativeSum=function(){for(var t=0,r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)t+=this.get(r,o),this.set(r,o,t);return this},P.prototype.dot=function(t){P.isMatrix(t)&&(t=t.to1DArray());var r=this.to1DArray();if(r.length!==t.length)throw new RangeError(\"vectors do not have the same size\");for(var o=0,e=0;e<r.length;e++)o+=r[e]*t[e];return o},P.prototype.mmul=function(t){t=this.constructor.checkMatrix(t),this.columns!==t.rows&&console.warn(\"Number of columns of left matrix are not equal to number of rows of right matrix.\");for(var r=this.rows,o=this.columns,e=t.columns,n=new this.constructor[Symbol.species](r,e),i=new Array(o),s=0;s<e;s++){for(var a=0;a<o;a++)i[a]=t.get(a,s);for(var u=0;u<r;u++){for(var h=0,a=0;a<o;a++)h+=this.get(u,a)*i[a];n.set(u,s,h)}}return n},P.prototype.strassen2x2=function(t){var r=new this.constructor[Symbol.species](2,2),o=this.get(0,0),e=t.get(0,0),n=this.get(0,1),i=t.get(0,1),s=this.get(1,0),a=t.get(1,0),u=this.get(1,1),h=t.get(1,1),f=(o+u)*(e+h),c=(s+u)*e,l=o*(i-h),p=u*(a-e),m=(o+n)*h,g=f+p-m+(n-u)*(a+h),w=l+m,v=c+p,y=f-c+l+(s-o)*(e+i);return r.set(0,0,g),r.set(0,1,w),r.set(1,0,v),r.set(1,1,y),r},P.prototype.strassen3x3=function(t){var r=new this.constructor[Symbol.species](3,3),o=this.get(0,0),e=this.get(0,1),n=this.get(0,2),i=this.get(1,0),s=this.get(1,1),a=this.get(1,2),u=this.get(2,0),h=this.get(2,1),f=this.get(2,2),c=t.get(0,0),l=t.get(0,1),p=t.get(0,2),m=t.get(1,0),g=t.get(1,1),w=t.get(1,2),v=t.get(2,0),y=t.get(2,1),d=t.get(2,2),b=(o-i)*(-l+g),M=(-o+i+s)*(c-l+g),x=(i+s)*(-c+l),R=o*c,S=(-o+u+h)*(c-p+w),j=(-o+u)*(p-w),E=(u+h)*(-c+p),A=(-n+h+f)*(g+v-y),P=(n-f)*(g-y),C=n*v,V=(h+f)*(-v+y),I=(-n+s+a)*(w+v-d),O=(n-a)*(w-d),k=(s+a)*(-v+d),L=R+C+e*m,N=(o+e+n-i-s-h-f)*g+M+x+R+A+C+V,q=R+S+E+(o+e+n-s-a-u-h)*w+C+I+k,T=b+s*(-c+l+m-g-w-v+d)+M+R+C+I+O,B=b+M+x+R+a*y,D=C+I+O+k+i*p,U=R+S+j+h*(-c+p+m-g-w-v+y)+A+P+C,z=A+P+C+V+u*l,W=R+S+j+E+f*d;return r.set(0,0,L),r.set(0,1,N),r.set(0,2,q),r.set(1,0,T),r.set(1,1,B),r.set(1,2,D),r.set(2,0,U),r.set(2,1,z),r.set(2,2,W),r},P.prototype.mmulStrassen=function(t){var r=this.clone(),o=r.rows,e=r.columns,n=t.rows,i=t.columns;function A(t,r,o){var e=t.rows,n=t.columns;return e===r&&n===o?t:P.zeros(r,o).setSubMatrix(t,0,0)}e!==n&&console.warn(\"Multiplying \"+o+\" x \"+e+\" and \"+n+\" x \"+i+\" matrix: dimensions do not match.\");var s=Math.max(o,n),a=Math.max(e,i);return function t(r,o,e,n){if(e<=512||n<=512)return r.mmul(o);e%2==1&&n%2==1?(r=A(r,e+1,n+1),o=A(o,e+1,n+1)):e%2==1?(r=A(r,e+1,n),o=A(o,e+1,n)):n%2==1&&(r=A(r,e,n+1),o=A(o,e,n+1));var i=parseInt(r.rows/2,10),s=parseInt(r.columns/2,10),a=r.subMatrix(0,i-1,0,s-1),u=o.subMatrix(0,i-1,0,s-1),h=r.subMatrix(0,i-1,s,r.columns-1),f=o.subMatrix(0,i-1,s,o.columns-1),c=r.subMatrix(i,r.rows-1,0,s-1),l=o.subMatrix(i,o.rows-1,0,s-1),p=r.subMatrix(i,r.rows-1,s,r.columns-1),m=o.subMatrix(i,o.rows-1,s,o.columns-1),g=t(P.add(a,p),P.add(u,m),i,s),w=t(P.add(c,p),u,i,s),v=t(a,P.sub(f,m),i,s),y=t(p,P.sub(l,u),i,s),d=t(P.add(a,h),m,i,s),b=t(P.sub(c,a),P.add(u,f),i,s),M=t(P.sub(h,p),P.add(l,m),i,s),x=P.add(g,y);x.sub(d),x.add(M);var R=P.add(v,d),S=P.add(w,y),j=P.sub(g,w);j.add(v),j.add(b);var E=P.zeros(2*x.rows,2*x.columns);return(E=(E=(E=(E=E.setSubMatrix(x,0,0)).setSubMatrix(R,x.rows,0)).setSubMatrix(S,0,x.columns)).setSubMatrix(j,x.rows,x.columns)).subMatrix(0,e-1,0,n-1)}(A(r,s,a),t=A(t,s,a),s,a)},P.prototype.scaleRows=function(t,r){if((r=void 0===r?1:r)<=(t=void 0===t?0:t))throw new RangeError(\"min should be strictly smaller than max\");for(var o=this.constructor.empty(this.rows,this.columns),e=0;e<this.rows;e++){var n=L(this.getRow(e),{min:t,max:r});o.setRow(e,n)}return o},P.prototype.scaleColumns=function(t,r){if((r=void 0===r?1:r)<=(t=void 0===t?0:t))throw new RangeError(\"min should be strictly smaller than max\");for(var o=this.constructor.empty(this.rows,this.columns),e=0;e<this.columns;e++){var n=L(this.getColumn(e),{min:t,max:r});o.setColumn(e,n)}return o},P.prototype.kroneckerProduct=function(t){t=this.constructor.checkMatrix(t);for(var r=this.rows,o=this.columns,e=t.rows,n=t.columns,i=new this.constructor[Symbol.species](r*e,o*n),s=0;s<r;s++)for(var a=0;a<o;a++)for(var u=0;u<e;u++)for(var h=0;h<n;h++)i[e*s+u][n*a+h]=this.get(s,a)*t.get(u,h);return i},P.prototype.transpose=function(){for(var t=new this.constructor[Symbol.species](this.columns,this.rows),r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)t.set(o,r,this.get(r,o));return t},P.prototype.sortRows=function(t){void 0===t&&(t=o);for(var r=0;r<this.rows;r++)this.setRow(r,this.getRow(r).sort(t));return this},P.prototype.sortColumns=function(t){void 0===t&&(t=o);for(var r=0;r<this.columns;r++)this.setColumn(r,this.getColumn(r).sort(t));return this},P.prototype.subMatrix=function(t,r,o,e){W(this,t,r,o,e);for(var n=new this.constructor[Symbol.species](r-t+1,e-o+1),i=t;i<=r;i++)for(var s=o;s<=e;s++)n[i-t][s-o]=this.get(i,s);return n},P.prototype.subMatrixRow=function(t,r,o){if(void 0===r&&(r=0),void 0===o&&(o=this.columns-1),o<r||r<0||r>=this.columns||o<0||o>=this.columns)throw new RangeError(\"Argument out of range\");for(var e=new this.constructor[Symbol.species](t.length,o-r+1),n=0;n<t.length;n++)for(var i=r;i<=o;i++){if(t[n]<0||t[n]>=this.rows)throw new RangeError(\"Row index out of range: \"+t[n]);e.set(n,i-r,this.get(t[n],i))}return e},P.prototype.subMatrixColumn=function(t,r,o){if(void 0===r&&(r=0),void 0===o&&(o=this.rows-1),o<r||r<0||r>=this.rows||o<0||o>=this.rows)throw new RangeError(\"Argument out of range\");for(var e=new this.constructor[Symbol.species](o-r+1,t.length),n=0;n<t.length;n++)for(var i=r;i<=o;i++){if(t[n]<0||t[n]>=this.columns)throw new RangeError(\"Column index out of range: \"+t[n]);e.set(i-r,n,this.get(i,t[n]))}return e},P.prototype.setSubMatrix=function(t,r,o){t=this.constructor.checkMatrix(t),W(this,r,r+t.rows-1,o,o+t.columns-1);for(var e=0;e<t.rows;e++)for(var n=0;n<t.columns;n++)this[r+e][o+n]=t.get(e,n);return this},P.prototype.setSubMatrix2=function(t,r,o,e,n){t=this.constructor.checkMatrix(t),W(this,r,r+o-1,e,e+n-1);for(var i=0;i<o;i+=1)for(var s=0;s<n;s+=1)this[r+i][e+s]=t.get(i,s);return this},P.prototype.selection=function(t,r){for(var o=z(this,t,r),e=new this.constructor[Symbol.species](t.length,r.length),n=0;n<o.row.length;n++)for(var i=o.row[n],s=0;s<o.column.length;s++){var a=o.column[s];e[n][s]=this.get(i,a)}return e},P.prototype.trace=function(){for(var t=Math.min(this.rows,this.columns),r=0,o=0;o<t;o++)r+=this.get(o,o);return r},P.prototype.transposeView=function(){return new _(this)},P.prototype.rowView=function(t){return T(this,t),new Q(this,t)},P.prototype.columnView=function(t){return B(this,t),new nt(this,t)},P.prototype.flipRowView=function(){return new at(this)},P.prototype.flipColumnView=function(){return new ft(this)},P.prototype.subMatrixView=function(t,r,o,e){return new F(this,t,r,o,e)},P.prototype.selectionView=function(t,r){return new H(this,t,r)},P.prototype.rowSelectionView=function(t){return new Y(this,t)},P.prototype.columnSelectionView=function(t){return new rt(this,t)},P.prototype.det=function(){if(this.isSquare()){if(2===this.columns)return e=this.get(0,0),n=this.get(0,1),i=this.get(1,0),e*this.get(1,1)-n*i;if(3!==this.columns)return new N(this).determinant;var t=this.selectionView([1,2],[1,2]),r=this.selectionView([1,2],[0,2]),o=this.selectionView([1,2],[0,1]),e=this.get(0,0),n=this.get(0,1),i=this.get(0,2);return e*t.det()-n*r.det()+i*o.det()}throw Error(\"Determinant can only be calculated for a square matrix.\")},P.prototype.pseudoInverse=function(t){void 0===t&&(t=Number.EPSILON);for(var r=new q(this,{autoTranspose:!0}),o=r.leftSingularVectors,e=r.rightSingularVectors,n=r.diagonal,i=0;i<n.length;i++)Math.abs(n[i])>t?n[i]=1/n[i]:n[i]=0;return n=this.constructor[Symbol.species].diag(n),e.mmul(n.mmul(o.transposeView()))},P.prototype.clone=function(){for(var t=new this.constructor[Symbol.species](this.rows,this.columns),r=0;r<this.rows;r++)for(var o=0;o<this.columns;o++)t.set(r,o,this.get(r,o));return t},P);function P(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var o=e.apply(this,t)||this;return Object.setPrototypeOf(o,Object.create(P.prototype)),o}function o(t,r){return t-r}r.prototype.klass=\"Matrix\",r.random=r.rand,r.diagonal=r.diag,r.prototype.diagonal=r.prototype.diag,r.identity=r.eye,r.prototype.negate=r.prototype.neg,r.prototype.tensorProduct=r.prototype.kroneckerProduct,r.prototype.determinant=r.prototype.det;for(var n=\"\\n(function %name%(matrix, %args%) {\\n    var newMatrix = new this[Symbol.species](matrix);\\n    return newMatrix.%name%(%args%);\\n})\\n\",i=eval,s=0,a=[[\"+\",\"add\"],[\"-\",\"sub\",\"subtract\"],[\"/\",\"div\",\"divide\"],[\"%\",\"mod\",\"modulus\"],[\"&\",\"and\"],[\"|\",\"or\"],[\"^\",\"xor\"],[\"<<\",\"leftShift\"],[\">>\",\"signPropagatingRightShift\"],[\">>>\",\"rightShift\",\"zeroFillRightShift\"]];s<a.length;s++)for(var u=a[s],h=i(O(\"\\n(function %name%(value) {\\n    if (typeof value === 'number') return this.%name%S(value);\\n    return this.%name%M(value);\\n})\\n\",{name:u[1],op:u[0]})),f=i(O(\"\\n(function %name%S(value) {\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, this.get(i, j) %op% value);\\n        }\\n    }\\n    return this;\\n})\\n\",{name:u[1]+\"S\",op:u[0]})),c=i(O(\"\\n(function %name%M(matrix) {\\n    matrix = this.constructor.checkMatrix(matrix);\\n    if (this.rows !== matrix.rows ||\\n        this.columns !== matrix.columns) {\\n        throw new RangeError('Matrices dimensions must be equal');\\n    }\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));\\n        }\\n    }\\n    return this;\\n})\\n\",{name:u[1]+\"M\",op:u[0]})),l=i(O(\"\\n(function %name%(matrix, value) {\\n    var newMatrix = new this[Symbol.species](matrix);\\n    return newMatrix.%name%(value);\\n})\\n\",{name:u[1]})),p=1;p<u.length;p++)r.prototype[u[p]]=h,r.prototype[u[p]+\"S\"]=f,r.prototype[u[p]+\"M\"]=c,r[u[p]]=l;var m=[[\"~\",\"not\"]];[\"abs\",\"acos\",\"acosh\",\"asin\",\"asinh\",\"atan\",\"atanh\",\"cbrt\",\"ceil\",\"clz32\",\"cos\",\"cosh\",\"exp\",\"expm1\",\"floor\",\"fround\",\"log\",\"log1p\",\"log10\",\"log2\",\"round\",\"sign\",\"sin\",\"sinh\",\"sqrt\",\"tan\",\"tanh\",\"trunc\"].forEach(function(t){m.push([\"Math.\"+t,t])});for(var g=0,w=m;g<w.length;g++){var v=w[g],y=i(O(\"\\n(function %name%() {\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, %method%(this.get(i, j)));\\n        }\\n    }\\n    return this;\\n})\\n\",{name:v[1],method:v[0]})),d=i(O(\"\\n(function %name%(matrix) {\\n    var newMatrix = new this[Symbol.species](matrix);\\n    return newMatrix.%name%();\\n})\\n\",{name:v[1]}));for(p=1;p<v.length;p++)r.prototype[v[p]]=y,r[v[p]]=d}for(var b=0,M=[[\"Math.pow\",1,\"pow\"]];b<M.length;b++){var x=M[b],R=\"arg0\";for(p=1;p<x[1];p++)R+=\", arg\"+p;if(1!==x[1]){var S=i(O(\"\\n(function %name%(%args%) {\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, %method%(this.get(i, j), %args%));\\n        }\\n    }\\n    return this;\\n})\\n\",{name:x[2],method:x[0],args:R})),j=i(O(n,{name:x[2],args:R}));for(p=2;p<x.length;p++)r.prototype[x[p]]=S,r[x[p]]=j}else{var E={name:x[2],args:R,method:x[0]},A=i(O(\"\\n(function %name%(value) {\\n    if (typeof value === 'number') return this.%name%S(value);\\n    return this.%name%M(value);\\n})\\n\",E)),C=i(O(\"\\n(function %name%S(value) {\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, %method%(this.get(i, j), value));\\n        }\\n    }\\n    return this;\\n})\\n\",E)),V=i(O(\"\\n(function %name%M(matrix) {\\n    matrix = this.constructor.checkMatrix(matrix);\\n    if (this.rows !== matrix.rows ||\\n        this.columns !== matrix.columns) {\\n        throw new RangeError('Matrices dimensions must be equal');\\n    }\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));\\n        }\\n    }\\n    return this;\\n})\\n\",E)),I=i(O(\"\\n(function %name%(matrix, %args%) {\\n    var newMatrix = new this[Symbol.species](matrix);\\n    return newMatrix.%name%(%args%);\\n})\\n\",E));for(p=2;p<x.length;p++)r.prototype[x[p]]=A,r.prototype[x[p]+\"M\"]=V,r.prototype[x[p]+\"S\"]=C,r[x[p]]=I}}function O(t,r){for(var o in r)t=t.replace(new RegExp(\"%\"+o+\"%\",\"g\"),r[o]);return t}return r}var pt,mt=(k(gt,pt=lt(Array)),gt.prototype.set=function(t,r,o){return this[t][r]=o,this},gt.prototype.get=function(t,r){return this[t][r]},gt.prototype.mul=function(t){if(\"number\"==typeof t)for(var r=0;r<this.rows;r+=1)for(var o=0;o<this.columns;o+=1)this[r][o]=this.get(r,o)*t;else{for(var e=function(t,r){for(var o=[],e=0;e<t.length;e++){o[e]=[];for(var n=0;n<r[0].length;n++){for(var i=0,s=0;s<t[0].length;s++)i+=t[e][s]*r[s][n];o[e][n]=i}}return o}(this,t),r=0;r<e.length;r+=1)for(o=0;o<e[r].length;o+=1)this[r][o]=e[r][o];this.rows=e.length,this.columns=e[0].length}return this},gt.prototype.removeRow=function(t){if(T(this,t),1===this.rows)throw new RangeError(\"A matrix cannot have less than one row\");return this.splice(t,1),--this.rows,this},gt.prototype.addRow=function(t,r){return void 0===r&&(r=t,t=this.rows),T(this,t,!0),r=D(this,r),this.splice(t,0,r),this.rows+=1,this},gt.prototype.removeColumn=function(t){if(B(this,t),1===this.columns)throw new RangeError(\"A matrix cannot have less than one column\");for(var r=0;r<this.rows;r++)this[r].splice(t,1);return--this.columns,this},gt.prototype.addColumn=function(t,r){void 0===r&&(r=t,t=this.columns),B(this,t,!0),r=U(this,r);for(var o=0;o<this.rows;o++)this[o].splice(t,0,r[o]);return this.columns+=1,this},gt);function gt(t,r){var o,e=this;if(1===arguments.length&&\"number\"==typeof t)return new Array(t);if(gt.isMatrix(t))return t.clone();if(Number.isInteger(t)&&0<t){if(e=pt.call(this,t)||this,!(Number.isInteger(r)&&0<r))throw new TypeError(\"nColumns must be a positive integer\");for(o=0;o<t;o++)e[o]=new Array(r)}else{if(!Array.isArray(t))throw new TypeError(\"First argument must be a positive number or an array\");var n=t;if(t=n.length,\"number\"!=typeof(r=n[0].length)||0===r)throw new TypeError(\"Data must be a 2D array with at least one element\");for(e=pt.call(this,t)||this,o=0;o<t;o++){if(n[o].length!==r)throw new RangeError(\"Inconsistent array dimensions\");e[o]=[].concat(n[o])}}return e.rows=t,e.columns=r,Object.setPrototypeOf(e,gt.prototype),e}mt.prototype.multiply=mt.prototype.mul;var wt;k(vt,wt=lt()),vt.prototype.set=function(t,r,o){var e=this._calculateIndex(t,r);return this.data[e]=o,this},vt.prototype.get=function(t,r){var o=this._calculateIndex(t,r);return this.data[o]},vt.prototype._calculateIndex=function(t,r){return t*this.columns+r},Object.defineProperty(vt,Symbol.species,{get:function(){return mt},enumerable:!1,configurable:!0});function vt(t,r){void 0===r&&(r={});var o=this,e=r.rows,n=void 0===e?1:e;if(t.length%n!=0)throw new Error(\"the data length is not divisible by the number of rows\");return(o=wt.call(this)||this).rows=n,o.columns=t.length/n,o.data=t,o}yt.prototype.solve=function(t){t=mt.checkMatrix(t);var r=this.QR,o=r.rows;if(t.rows!==o)throw new Error(\"Matrix row dimensions must agree\");if(!this.isFullRank())throw new Error(\"Matrix is rank deficient\");for(var e,n,i,s=t.columns,a=t.clone(),u=r.columns,h=0;h<u;h++)for(n=0;n<s;n++){for(i=0,e=h;e<o;e++)i+=r[e][h]*a[e][n];for(i=-i/r[h][h],e=h;e<o;e++)a[e][n]+=i*r[e][h]}for(h=u-1;0<=h;h--){for(n=0;n<s;n++)a[h][n]/=this.Rdiag[h];for(e=0;e<h;e++)for(n=0;n<s;n++)a[e][n]-=a[h][n]*r[e][h]}return a.subMatrix(0,u-1,0,s-1)},yt.prototype.isFullRank=function(){for(var t=this.QR.columns,r=0;r<t;r++)if(0===this.Rdiag[r])return!1;return!0},Object.defineProperty(yt.prototype,\"upperTriangularMatrix\",{get:function(){for(var t,r=this.QR,o=r.columns,e=new mt(o,o),n=0;n<o;n++)for(t=0;t<o;t++)e[n][t]=n<t?r[n][t]:n===t?this.Rdiag[n]:0;return e},enumerable:!1,configurable:!0}),Object.defineProperty(yt.prototype,\"orthogonalMatrix\",{get:function(){for(var t,r,o,e=this.QR,n=e.rows,i=e.columns,s=new mt(n,i),a=i-1;0<=a;a--){for(t=0;t<n;t++)s[t][a]=0;for(s[a][a]=1,r=a;r<i;r++)if(0!==e[a][a]){for(o=0,t=a;t<n;t++)o+=e[t][a]*s[t][r];for(o=-o/e[a][a],t=a;t<n;t++)s[t][r]+=o*e[t][a]}}return s},enumerable:!1,configurable:!0});function yt(t){for(var r,o,e=(t=G.checkMatrix(t)).clone(),n=t.rows,i=t.columns,s=new Array(i),a=0;a<i;a++){for(var u=0,h=a;h<n;h++)u=K(u,e.get(h,a));if(0!==u){for(e.get(a,a)<0&&(u=-u),h=a;h<n;h++)e.set(h,a,e.get(h,a)/u);for(e.set(a,a,e.get(a,a)+1),r=a+1;r<i;r++){for(o=0,h=a;h<n;h++)o+=e.get(h,a)*e.get(h,r);for(o=-o/e.get(a,a),h=a;h<n;h++)e.set(h,r,e.get(h,r)+o*e.get(h,a))}}s[a]=-u}this.QR=e,this.Rdiag=s}Object.defineProperty(dt.prototype,\"realEigenvalues\",{get:function(){return this.d},enumerable:!1,configurable:!0}),Object.defineProperty(dt.prototype,\"imaginaryEigenvalues\",{get:function(){return this.e},enumerable:!1,configurable:!0}),Object.defineProperty(dt.prototype,\"eigenvectorMatrix\",{get:function(){return mt.isMatrix(this.V)||(this.V=new mt(this.V)),this.V},enumerable:!1,configurable:!0}),Object.defineProperty(dt.prototype,\"diagonalMatrix\",{get:function(){for(var t,r=this.n,o=this.e,e=this.d,n=new mt(r,r),i=0;i<r;i++){for(t=0;t<r;t++)n[i][t]=0;n[i][i]=e[i],0<o[i]?n[i][i+1]=o[i]:o[i]<0&&(n[i][i-1]=o[i])}return n},enumerable:!1,configurable:!0});function dt(t,r){void 0===r&&(r={});var o=r.assumeSymmetric,e=void 0!==o&&o;if(!(t=G.checkMatrix(t)).isSquare())throw new Error(\"Matrix is not a square matrix\");var n,i=t.columns,s=Z(i,i,0),a=new Array(i),u=new Array(i),h=t;if(!!e||t.isSymmetric()){for(n=0;n<i;n++)for(l=0;l<i;l++)s[n][l]=h.get(n,l);!function(t,r,o,e){var n,i,s,a,u,h,f,c;for(u=0;u<t;u++)o[u]=e[t-1][u];for(a=t-1;0<a;a--){for(h=s=c=0;h<a;h++)c+=Math.abs(o[h]);if(0===c)for(r[a]=o[a-1],u=0;u<a;u++)o[u]=e[a-1][u],e[a][u]=0,e[u][a]=0;else{for(h=0;h<a;h++)o[h]/=c,s+=o[h]*o[h];for(n=o[a-1],i=Math.sqrt(s),0<n&&(i=-i),r[a]=c*i,s-=n*i,o[a-1]=n-i,u=0;u<a;u++)r[u]=0;for(u=0;u<a;u++){for(n=o[u],e[u][a]=n,i=r[u]+e[u][u]*n,h=u+1;h<=a-1;h++)i+=e[h][u]*o[h],r[h]+=e[h][u]*n;r[u]=i}for(u=n=0;u<a;u++)r[u]/=s,n+=r[u]*o[u];for(f=n/(s+s),u=0;u<a;u++)r[u]-=f*o[u];for(u=0;u<a;u++){for(n=o[u],i=r[u],h=u;h<=a-1;h++)e[h][u]-=n*r[h]+i*o[h];o[u]=e[a-1][u],e[a][u]=0}}o[a]=s}for(a=0;a<t-1;a++){if(e[t-1][a]=e[a][a],e[a][a]=1,0!==(s=o[a+1])){for(h=0;h<=a;h++)o[h]=e[h][a+1]/s;for(u=0;u<=a;u++){for(h=i=0;h<=a;h++)i+=e[h][a+1]*e[h][u];for(h=0;h<=a;h++)e[h][u]-=i*o[h]}}for(h=0;h<=a;h++)e[h][a+1]=0}for(u=0;u<t;u++)o[u]=e[t-1][u],e[t-1][u]=0;e[t-1][t-1]=1,r[0]=0}(i,u,a,s),function(t,r,o,e){var n,i,s,a,u,h,f,c,l,p,m,g,w,v,y,d;for(s=1;s<t;s++)r[s-1]=r[s];var b=r[t-1]=0,M=0,x=Number.EPSILON;for(h=0;h<t;h++){for(M=Math.max(M,Math.abs(o[h])+Math.abs(r[h])),f=h;f<t&&!(Math.abs(r[f])<=x*M);)f++;if(h<f)do{for(n=o[h],c=(o[h+1]-n)/(2*r[h]),l=K(c,1),c<0&&(l=-l),o[h]=r[h]/(c+l),o[h+1]=r[h]*(c+l),p=o[h+1],i=n-o[h],s=h+2;s<t;s++)o[s]-=i;for(b+=i,c=o[f],w=g=m=1,v=r[h+1],d=y=0,s=f-1;h<=s;s--)for(w=g,d=y,n=(g=m)*r[s],i=m*c,l=K(c,r[s]),r[s+1]=y*l,y=r[s]/l,c=(m=c/l)*o[s]-y*n,o[s+1]=i+y*(m*n+y*o[s]),u=0;u<t;u++)i=e[u][s+1],e[u][s+1]=y*e[u][s]+m*i,e[u][s]=m*e[u][s]-y*i;c=-y*d*w*v*r[h]/p,r[h]=y*c,o[h]=m*c}while(Math.abs(r[h])>x*M);o[h]=o[h]+b,r[h]=0}for(s=0;s<t-1;s++){for(c=o[u=s],a=s+1;a<t;a++)o[a]<c&&(c=o[u=a]);if(u!==s)for(o[u]=o[s],o[s]=c,a=0;a<t;a++)c=e[a][s],e[a][s]=e[a][u],e[a][u]=c}}(i,u,a,s)}else{for(var f=Z(i,i,0),c=new Array(i),l=0;l<i;l++)for(n=0;n<i;n++)f[n][l]=h.get(n,l);!function(t,r,o,e){var n,i,s,a,u,h,f,c=t-1;for(h=1;h<=c-1;h++){for(f=0,a=h;a<=c;a++)f+=Math.abs(r[a][h-1]);if(0!==f){for(s=0,a=c;h<=a;a--)o[a]=r[a][h-1]/f,s+=o[a]*o[a];for(i=Math.sqrt(s),0<o[h]&&(i=-i),s-=o[h]*i,o[h]=o[h]-i,u=h;u<t;u++){for(n=0,a=c;h<=a;a--)n+=o[a]*r[a][u];for(n/=s,a=h;a<=c;a++)r[a][u]-=n*o[a]}for(a=0;a<=c;a++){for(n=0,u=c;h<=u;u--)n+=o[u]*r[a][u];for(n/=s,u=h;u<=c;u++)r[a][u]-=n*o[u]}o[h]=f*o[h],r[h][h-1]=f*i}}for(a=0;a<t;a++)for(u=0;u<t;u++)e[a][u]=a===u?1:0;for(h=c-1;1<=h;h--)if(0!==r[h][h-1]){for(a=h+1;a<=c;a++)o[a]=r[a][h-1];for(u=h;u<=c;u++){for(i=0,a=h;a<=c;a++)i+=o[a]*e[a][u];for(i=i/o[h]/r[h][h-1],a=h;a<=c;a++)e[a][u]+=i*o[a]}}}(i,f,c,s),function(t,r,o,e,n){var i,s,a,u,h,f,c,l,p,m,g,w,v,y,d,b=t-1,M=t-1,x=Number.EPSILON,R=0,S=0,j=0,E=0,A=0,P=0,C=0,V=0;for(i=0;i<t;i++)for((i<0||M<i)&&(o[i]=n[i][i],r[i]=0),s=Math.max(i-1,0);s<t;s++)S+=Math.abs(n[i][s]);for(;0<=b;){for(u=b;0<u&&(0===(P=Math.abs(n[u-1][u-1])+Math.abs(n[u][u]))&&(P=S),!(Math.abs(n[u][u-1])<x*P));)u--;if(u===b)n[b][b]=n[b][b]+R,o[b]=n[b][b],r[b]=0,b--,V=0;else if(u===b-1){if(c=n[b][b-1]*n[b-1][b],j=(n[b-1][b-1]-n[b][b])/2,E=j*j+c,C=Math.sqrt(Math.abs(E)),n[b][b]=n[b][b]+R,n[b-1][b-1]=n[b-1][b-1]+R,l=n[b][b],0<=E){for(C=0<=j?j+C:j-C,o[b-1]=l+C,o[b]=o[b-1],0!==C&&(o[b]=l-c/C),r[b-1]=0,r[b]=0,l=n[b][b-1],P=Math.abs(l)+Math.abs(C),j=l/P,E=C/P,A=Math.sqrt(j*j+E*E),j/=A,E/=A,s=b-1;s<t;s++)C=n[b-1][s],n[b-1][s]=E*C+j*n[b][s],n[b][s]=E*n[b][s]-j*C;for(i=0;i<=b;i++)C=n[i][b-1],n[i][b-1]=E*C+j*n[i][b],n[i][b]=E*n[i][b]-j*C;for(i=0;i<=M;i++)C=e[i][b-1],e[i][b-1]=E*C+j*e[i][b],e[i][b]=E*e[i][b]-j*C}else o[b-1]=l+j,o[b]=l+j,r[b-1]=C,r[b]=-C;b-=2,V=0}else{if(l=n[b][b],c=p=0,u<b&&(p=n[b-1][b-1],c=n[b][b-1]*n[b-1][b]),10===V){for(R+=l,i=0;i<=b;i++)n[i][i]-=l;P=Math.abs(n[b][b-1])+Math.abs(n[b-1][b-2]),l=p=.75*P,c=-.4375*P*P}if(30===V&&0<(P=(P=(p-l)/2)*P+c)){for(P=Math.sqrt(P),p<l&&(P=-P),P=l-c/((p-l)/2+P),i=0;i<=b;i++)n[i][i]-=P;R+=P,l=p=c=.964}for(V+=1,h=b-2;u<=h&&(C=n[h][h],j=((A=l-C)*(P=p-C)-c)/n[h+1][h]+n[h][h+1],E=n[h+1][h+1]-C-A-P,A=n[h+2][h+1],P=Math.abs(j)+Math.abs(E)+Math.abs(A),j/=P,E/=P,A/=P,h!==u)&&!(Math.abs(n[h][h-1])*(Math.abs(E)+Math.abs(A))<x*(Math.abs(j)*(Math.abs(n[h-1][h-1])+Math.abs(C)+Math.abs(n[h+1][h+1]))));)h--;for(i=h+2;i<=b;i++)n[i][i-2]=0,h+2<i&&(n[i][i-3]=0);for(a=h;a<=b-1&&(y=a!==b-1,a!==h&&(j=n[a][a-1],E=n[a+1][a-1],A=y?n[a+2][a-1]:0,0!==(l=Math.abs(j)+Math.abs(E)+Math.abs(A))&&(j/=l,E/=l,A/=l)),0!==l);a++)if(P=Math.sqrt(j*j+E*E+A*A),j<0&&(P=-P),0!==P){for(a!==h?n[a][a-1]=-P*l:u!==h&&(n[a][a-1]=-n[a][a-1]),l=(j+=P)/P,p=E/P,C=A/P,E/=j,A/=j,s=a;s<t;s++)j=n[a][s]+E*n[a+1][s],y&&(j+=A*n[a+2][s],n[a+2][s]=n[a+2][s]-j*C),n[a][s]=n[a][s]-j*l,n[a+1][s]=n[a+1][s]-j*p;for(i=0;i<=Math.min(b,a+3);i++)j=l*n[i][a]+p*n[i][a+1],y&&(j+=C*n[i][a+2],n[i][a+2]=n[i][a+2]-j*A),n[i][a]=n[i][a]-j,n[i][a+1]=n[i][a+1]-j*E;for(i=0;i<=M;i++)j=l*e[i][a]+p*e[i][a+1],y&&(j+=C*e[i][a+2],e[i][a+2]=e[i][a+2]-j*A),e[i][a]=e[i][a]-j,e[i][a+1]=e[i][a+1]-j*E}}}if(0===S)return;for(b=t-1;0<=b;b--)if(j=o[b],0===(E=r[b]))for(n[u=b][b]=1,i=b-1;0<=i;i--){for(c=n[i][i]-j,A=0,s=u;s<=b;s++)A+=n[i][s]*n[s][b];if(r[i]<0)C=c,P=A;else if(0===r[u=i]?n[i][b]=0!==c?-A/c:-A/(x*S):(l=n[i][i+1],p=n[i+1][i],E=(o[i]-j)*(o[i]-j)+r[i]*r[i],f=(l*P-C*A)/E,n[i][b]=f,n[i+1][b]=Math.abs(l)>Math.abs(C)?(-A-c*f)/l:(-P-p*f)/C),f=Math.abs(n[i][b]),1<x*f*f)for(s=i;s<=b;s++)n[s][b]=n[s][b]/f}else if(E<0)for(u=b-1,Math.abs(n[b][b-1])>Math.abs(n[b-1][b])?(n[b-1][b-1]=E/n[b][b-1],n[b-1][b]=-(n[b][b]-j)/n[b][b-1]):(d=bt(0,-n[b-1][b],n[b-1][b-1]-j,E),n[b-1][b-1]=d[0],n[b-1][b]=d[1]),n[b][b-1]=0,n[b][b]=1,i=b-2;0<=i;i--){for(g=m=0,s=u;s<=b;s++)m+=n[i][s]*n[s][b-1],g+=n[i][s]*n[s][b];if(c=n[i][i]-j,r[i]<0)C=c,A=m,P=g;else if(0===r[u=i]?(d=bt(-m,-g,c,E),n[i][b-1]=d[0],n[i][b]=d[1]):(l=n[i][i+1],p=n[i+1][i],w=(o[i]-j)*(o[i]-j)+r[i]*r[i]-E*E,v=2*(o[i]-j)*E,0===w&&0==v&&(w=x*S*(Math.abs(c)+Math.abs(E)+Math.abs(l)+Math.abs(p)+Math.abs(C))),d=bt(l*A-C*m+E*g,l*P-C*g-E*m,w,v),n[i][b-1]=d[0],n[i][b]=d[1],Math.abs(l)>Math.abs(C)+Math.abs(E)?(n[i+1][b-1]=(-m-c*n[i][b-1]+E*n[i][b])/l,n[i+1][b]=(-g-c*n[i][b]-E*n[i][b-1])/l):(d=bt(-A-p*n[i][b-1],-P-p*n[i][b],C,E),n[i+1][b-1]=d[0],n[i+1][b]=d[1])),f=Math.max(Math.abs(n[i][b-1]),Math.abs(n[i][b])),1<x*f*f)for(s=i;s<=b;s++)n[s][b-1]=n[s][b-1]/f,n[s][b]=n[s][b]/f}for(i=0;i<t;i++)if(i<0||M<i)for(s=i;s<t;s++)e[i][s]=n[i][s];for(s=t-1;0<=s;s--)for(i=0;i<=M;i++){for(a=C=0;a<=Math.min(s,M);a++)C+=e[i][a]*n[a][s];e[i][s]=C}}(i,u,a,s,f)}this.n=i,this.e=u,this.d=a,this.V=s}function bt(t,r,o,e){var n,i;return Math.abs(o)>Math.abs(e)?[(t+(n=e/o)*r)/(i=o+n*e),(r-n*t)/i]:[((n=o/e)*t+r)/(i=e+n*o),(n*r-t)/i]}var Mt=(xt.prototype.solve=function(t){t=G.checkMatrix(t);var r=this.L,o=r.rows;if(t.rows!==o)throw new Error(\"Matrix dimensions do not match\");for(var e,n,i=t.columns,s=t.clone(),a=0;a<o;a++)for(n=0;n<i;n++){for(e=0;e<a;e++)s[a][n]-=s[e][n]*r[a][e];s[a][n]/=r[a][a]}for(a=o-1;0<=a;a--)for(n=0;n<i;n++){for(e=a+1;e<o;e++)s[a][n]-=s[e][n]*r[e][a];s[a][n]/=r[a][a]}return s},Object.defineProperty(xt.prototype,\"lowerTriangularMatrix\",{get:function(){return this.L},enumerable:!1,configurable:!0}),xt);function xt(t){if(!(t=G.checkMatrix(t)).isSymmetric())throw new Error(\"Matrix is not symmetric\");for(var r=t,o=r.rows,e=new mt(o,o),n=!0,i=0;i<o;i++){for(var s=e[i],a=0,u=0;u<i;u++){for(var h=e[u],f=0,c=0;c<u;c++)f+=h[c]*s[c];s[u]=f=(r.get(i,u)-f)/e[u][u],a+=f*f}for(n&=0<(a=r.get(i,i)-a),e[i][i]=Math.sqrt(Math.max(a,0)),u=i+1;u<o;u++)e[i][u]=0}if(!n)throw new Error(\"Matrix is not positive definite\");this.L=e}var Rt=(St.prototype.init=function(){this.q=5e-5,this.r=5e-4,this.x=mt.rand(this.L,1,function(){return Math.random()}),this.x.multiply(this.q),this.P=mt.diagonal(new Array(this.L).fill(1),this.L,this.L),this.Q=mt.diagonal(new Array(this.L).fill(Math.pow(this.q,2)),this.L,this.L),this.R=new mt(this.m,this.m),this.R.fill(Math.pow(this.r,2)),this.alpha=.001,this.ki=0,this.beta=2,this.lambda=this.alpha*this.alpha*(this.L+this.ki)-this.L,this.c=this.L+this.lambda,this.Wm=new mt(1,2*this.L+1),this.Wm.fill(.5/this.c),this.Wm.set(0,0,this.lambda/this.c),this.Wc=this.Wm.clone(),this.Wc.set(0,0,this.Wm.get(0,0)+1-this.alpha*this.alpha+this.beta),this.c=Math.sqrt(this.c)},St.prototype.update=function(t){var r;0!==this.m||0<(r=t.length)&&(this.m=r,0===this.L&&(this.L=r),this.init());var o,e,n,i,s,a,u,h,f,c,l,p,m,g,w,v=new mt(this.m,1);v.fill(0),v.setColumn(0,t),this.x&&this.P&&this.c&&this.Wm&&this.Wc&&this.Q&&this.R&&(o=this.getSigmaPoints(this.x,this.P,this.c),n=(e=this.unscentedTransform(o,this.Wm,this.Wc,this.L,this.Q))[0],i=e[1],s=e[2],a=e[3],h=(u=this.unscentedTransform(i,this.Wm,this.Wc,this.m,this.R))[0],u[1],f=u[2],c=u[3],p=(l=this.Wc.getRow(0)).length,m=a.multiply(mt.diagonal(l,p,p)).multiply(c.transpose()),g=new q(f),w=m.clone().multiply(g.inverse()),this.x=n.clone().add(w.clone().multiply(v.clone().subtract(h))),this.P=s.clone().subtract(w.clone().multiply(m.clone().transpose())))},St.prototype.unscentedTransform=function(t,r,o,e,n){for(var i=t.columns,s=new mt(e,1).fill(0),a=new mt(e,i).fill(0),u=0;u<i;u+=1){var h=t.clone().subMatrix(0,t.rows-1,u,1+u-1);a.setSubMatrix2(h,0,a.rows,u,1);var f=a.clone().subMatrix(0,a.rows-1,u,1+u-1).multiply(r.get(0,u)),s=s.add(f)}var c=s.clone().multiply(new mt(1,i).fill(1)),l=a.clone().subtract(c),p=Array.from(o.getRow(0)),m=l.clone().multiply(mt.diagonal(p,p.length,p.length));return[s,a,m=(m=m.multiply(l.transpose())).add(n),l]},St.prototype.getSigmaPoints=function(t,r,o){var e=new Mt(r.clone()).L;e=(e=e.multiply(o)).transpose();for(var n=t.rows,i=new mt(n,n).fill(1),s=0;s<n;s+=1)i.setSubMatrix2(t,0,n,s,1);var a=new mt(n,2*n+1);a.setSubMatrix2(t,0,n,0,1);var u=i.clone().add(e);a.setSubMatrix2(u,0,n,1,n);var h=i.clone().subtract(e);return a.setSubMatrix2(h,0,n,n+1,n),a},St.prototype.getState=function(){return this.x?this.x.getColumn(0):[0]},St);function St(t){void 0===t&&(t=0),this.L=0,this.m=0,this.alpha=0,this.ki=0,this.beta=0,this.lambda=0,this.c=0,this.q=0,this.r=0,this.L=t}var jt=(Et.prototype.filter=function(t,r){var o,e,n;return isNaN(this.x)?(this.x=1/this.C*t,this.cov=1/this.C*this.Q*(1/this.C)):(o=this.predict(r),n=(e=this.uncertainty())*this.C*(1/(this.C*e*this.C+this.Q)),this.x=o+n*(t-this.C*o),this.cov=e-n*this.C*e),this.x},Et.prototype.predict=function(t){return void 0===t&&(t=0),this.A*this.x+this.B*t},Et.prototype.uncertainty=function(){return this.A*this.cov*this.A+this.R},Et.prototype.lastMeasurement=function(){return this.x},Et.prototype.setMeasurementNoise=function(t){this.Q=t},Et.prototype.setProcessNoise=function(t){this.R=t},Et);function Et(t){var r=void 0===t?{}:t,o=r.R,e=void 0===o?1:o,n=r.Q,i=void 0===n?1:n,s=r.A,a=void 0===s?1:s,u=r.B,h=void 0===u?0:u,f=r.C,c=void 0===f?1:f;this.R=e,this.Q=i,this.A=a,this.B=h,this.C=c,this.cov=NaN,this.x=NaN}var At=(Pt.prototype.update=function(t){for(var r=[],o=0;o<t.length;o+=1){var e=t[o].major+\":\"+t[o].minor;this.beaconMap[e]||(this.beaconMap[e]=new jt),r.push(c(c({},t[o]),{accuracy:this.beaconMap[e].filter(t[o].accuracy)}))}return r},Pt);function Pt(){this.beaconMap={}}function Ct(t,r,o){if(void 0===r&&(r={}),void 0===o&&(o=\"GET\"),r.query){var e=[];for(s in r.query)r.query.hasOwnProperty(s)&&e.push(s+\"=\"+encodeURIComponent(r.query[s]));t+=(/\\?/.test(t)?\"&\":\"?\")+e.join(\"&\")}var n,i=new XMLHttpRequest;if(i.open(o.toUpperCase(),t,!0),r.json&&(i.setRequestHeader(\"Content-Type\",\"application/json;charset=utf-8\"),n=JSON.stringify(r.json)),r.form&&(i.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded;charset=utf-8\"),n=JSON.stringify(r.form)),r.body&&(n=r.body),r.headers)for(var s in r.headers)r.headers.hasOwnProperty(s)&&i.setRequestHeader(s,r.headers[s]);return r.timeout&&(i.timeout=r.timeout),r.responseType&&(i.responseType=r.responseType),r.timeout&&(i.timeout=r.timeout),i.send(n),new Promise(function(r,o){i.onload=function(){var t=i.getResponseHeader(\"Content-Type\")||\"\";4===i.readyState&&200===i.status?-1!==t.indexOf(\"application/json\")?r(JSON.parse(i.response)):r(i.response):-1!==t.indexOf(\"application/json\")?o(JSON.parse(i.response)):o(i.response)},i.onerror=function(t){o(t)},i.ontimeout=function(){o(new Error(\"timeout\"))},i.onabort=function(){o(new Error(\"abort\"))}})}Promise||console.error(\"your browser is not support Promise\"),Ct.defaultHeaders={},Ct.setDefaultHeader=function(t){void 0===t&&(t={}),Ct.defaultHeaders=t},Ct.get=function(t,r){return void 0===r&&(r={}),Ct(t,r,\"GET\")},Ct.post=function(t,r){return void 0===r&&(r={}),Ct(t,r,\"POST\")},Ct.del=function(t,r){return void 0===r&&(r={}),Ct(t,r,\"DELETE\")},Ct.put=function(t,r){return void 0===r&&(r={}),Ct(t,r,\"PUT\")};var Vt,It={};function Ot(){var f=this;this.ukfMngX=new Rt,this.ukfMngY=new Rt,this.kalmanMng=new At,this.loadBeaconMap=function(a,u){return t(f,void 0,void 0,function(){var r,o,e,n,i,s;return h(this,function(t){switch(t.label){case 0:return t.trys.push([0,2,,3]),r=new Map,o=Date.now(),[4,Ct.get(a+\"/\"+u)];case 1:for(e=t.sent().data,n=Date.now()-o,postMessage({type:\"loadCindyBeacon\",payload:{isLoadCindyBeacon:!0,loadCindyBeaconTime:n}}),i=0;i<e.length;i+=1)s=e[i].Major+\":\"+e[i].Minor,r.set(s,{majorMinor:s,x:e[i].LocationX,y:e[i].LocationY,floorId:e[i].FloorId});return this.anchorBeacons=r,[3,3];case 2:return t.sent(),postMessage({type:\"error\",payload:\"load beacon failed\"}),[3,3];case 3:return[2]}})})},this.calculate=function(t){if(f.anchorBeacons){var r=f.kalmanMng.update(t),o=f.refineWxBeacons(r),e=o.floorBeacons,n=o.refinedBeacons,i=f.algorithmFloor(e);if(0!==n.length&&i){var s,a,u,h=n=n.filter(function(t){return t.floorId===i}).slice(0,4);return 0!==n.length?(u=(a=n).reduce(function(t,r){return t+1/r.finalAccuracy},0),s=a.reduce(function(t,r){var o=r.finalAccuracy;return{x:t.x+r.x/(u*o),y:t.y+r.y/(u*o)}},{x:0,y:0}),f.ukfMngX.update([s.x]),s.x=f.ukfMngX.getState()[0],f.ukfMngY.update([s.y]),s.y=f.ukfMngY.getState()[0]):s={x:NaN,y:NaN,floor:\"\"},c(c({floor:i},s),{refinedBeacons:h,time:(new Date).getTime()})}}},this.refineWxBeacons=function(t){for(var r=[],o=[],e=0;e<t.length;e+=1){var n,i=t[e];i.rssi=Number(i.rssi),i.accuracy=Number(i.accuracy),i.mac=i.major+\":\"+i.minor,!f.anchorBeacons.has(i.mac)||i.accuracy<=0||(n=f.anchorBeacons.get(i.mac),r.push({x:n.x,y:n.y,floorId:n.floorId,finalAccuracy:i.accuracy}),i.rssi>=f.rssiLimit&&i.rssi<0&&o.push({x:n.x,y:n.y,floorId:n.floorId,finalAccuracy:i.accuracy,wxBeacon:i}))}return r.sort(function(t,r){return t.finalAccuracy-r.finalAccuracy}),o.sort(function(t,r){return t.finalAccuracy-r.finalAccuracy}),{floorBeacons:r,refinedBeacons:o}},this.anchorBeacons=null,this.lastLocationPoint=null,this.lastKalmanParameter=null}var kt=new(Ot.prototype.setRssiLimit=function(t){this.rssiLimit=t},Ot.prototype.algorithmFloor=function(t){var r;if(Array.isArray(t)&&0!==t.length){for(var o in r=t[0].floorId,5<t.length&&t[1].floorId===t[2].floorId&&t[2].floorId===t[3].floorId&&t[3].floorId===t[4].floorId&&(r=t[1].floorId),Vt=Vt||r,r&&(It[r]=It[r]?It[r]+1:1),It)o!==r&&(It[o]=0),3<It[o]&&(Vt=o);return Vt}},Ot);onmessage=function(i){return t(void 0,void 0,void 0,function(){var r,o,e,n;return h(this,function(t){return r=i.data,o=r.type,e=r.payload,\"calculate\"===o?(n=kt.calculate(e),postMessage({type:\"success\",payload:n})):\"initEngine\"===o?(kt.loadBeaconMap(e.beaconsServer,e.buildingId).then(),kt.setRssiLimit(e.rssiLimit)):\"setRssiLimit\"===o&&kt.setRssiLimit(e.rssiLimit),[2]})})}}();\n");

    var AverageEngine = (function () {
        function AverageEngine (palmapLocationConfig) {
            var _this = this;
            this.locationChangeCbs = [];
            this.cindyBeaconCbs = [];
            this.rssiLimit = 0;
            var _a = palmapLocationConfig.average, beaconsServer = _a.beaconsServer, iosRssi = _a.iosRssi, androidRssi = _a.androidRssi;
            var buildingId = palmapLocationConfig.input.buildingId;
            if (!beaconsServer || !buildingId) {
                console.error('AverageEngine: beaconsServer and buildingId are all required');
                return;
            }
            this.averageWorker = new AverageWorker();
            var rssiLimit = this.getRssiLimitByDevice(iosRssi, androidRssi);
            this.rssiLimit = rssiLimit;
            this.averageWorker.postMessage({ type: 'initEngine', payload: { beaconsServer: beaconsServer, buildingId: buildingId, rssiLimit: rssiLimit } });
            this.averageWorker.onmessage = function (e) {
                var data = e.data;
                if (!data)
                    return;
                var type = data.type, payload = data.payload;
                if (type === 'success') {
                    for (var i = 0; i < _this.locationChangeCbs.length; i += 1) {
                        _this.locationChangeCbs[i](payload);
                    }
                }
                if (type === 'loadCindyBeacon') {
                    for (var i = 0; i < _this.cindyBeaconCbs.length; i += 1) {
                        _this.cindyBeaconCbs[i](payload);
                    }
                    LogMgr.log('init engine success');
                }
                if (type === 'error') {
                    LogMgr.log(payload);
                }
            };
        }
        AverageEngine.prototype.getRssiLimitByDevice = function (iosRssi, androidRssi) {
            var rssiLimit;
            switch (checkDeviceType()) {
                case 'Android':
                    rssiLimit = androidRssi;
                    break;
                case 'iOS':
                    rssiLimit = iosRssi;
                    break;
                default:
                    rssiLimit = -75;
                    break;
            }
            return rssiLimit;
        };
        AverageEngine.prototype.calculate = function (wxBeacons) {
            this.averageWorker.postMessage({ type: 'calculate', payload: wxBeacons });
        };
        AverageEngine.prototype.registerLocationChange = function (cb) {
            if (typeof cb === 'function') {
                this.locationChangeCbs.push(cb);
            }
        };
        AverageEngine.prototype.setRssiLimit = function (rssiLimit) {
            this.averageWorker.postMessage({ type: 'setRssiLimit', payload: { rssiLimit: rssiLimit } });
        };
        AverageEngine.prototype.registerCindyBeacons = function (cb) {
            if (typeof cb === 'function') {
                this.cindyBeaconCbs.push(cb);
            }
        };
        return AverageEngine;
    }());

    var CompassManager = (function () {
        function CompassManager (bleManager, palmapLocationConfig) {
            var _this_1 = this;
            this.originAngle = 0;
            this.convertAngle = 0;
            this.isEnableConvert = false;
            this.compassChangCbs = [];
            this.compassHeading = 0;
            this.maxAngelDiff = 10;
            this.headingOffset = 0;
            this.compassSocket = '';
            this.getCompassHeading = function () { return _this_1.compassHeading; };
            this.registerCompassChange = function (cb) {
                if (typeof cb === "function") {
                    _this_1.compassChangCbs.push(cb);
                }
            };
            this.setCompassHeading = function (compassHeading) {
                _this_1.compassHeading = compassHeading + _this_1.headingOffset;
                _this_1.originAngle = compassHeading;
                var angle = Math.abs(_this_1.convertAngle - _this_1.compassHeading);
                if (_this_1.isEnableConvert && angle < _this_1.maxAngelDiff) {
                    _this_1.compassHeading = _this_1.convertAngle;
                }
                window.currentCompassHeading = _this_1.compassHeading;
                _this_1.compassChangCbs.forEach(function (cb) {
                    cb(_this_1.compassHeading);
                });
            };
            this.calcCompassHeading = function (androidCompassHeadingType, iosCompassHeadingType, defaultCompassHeadingType) {
                switch (checkDeviceType()) {
                    case "Android":
                        _this_1.calcCompassHeadingByType(androidCompassHeadingType);
                        break;
                    case "iOS":
                        _this_1.calcCompassHeadingByType(iosCompassHeadingType);
                        break;
                    case "other":
                        _this_1.calcCompassHeadingByType(defaultCompassHeadingType);
                        break;
                }
            };
            this.calcCompassHeadingByType = function (compassHeadingType) {
                var _this = _this_1;
                switch (compassHeadingType) {
                    case 'beacon':
                        _this_1.bleManager.registerSearchBeacon(function (beacons) {
                            if (beacons.length <= 0)
                                return;
                            var sum = beacons.reduce(function (a, val) { return a + Number(val.heading); }, 0);
                            _this_1.setCompassHeading(sum / beacons.length);
                        });
                        break;
                    case 'calculate':
                        window.addEventListener('deviceorientation', function (e) {
                            _this_1.setCompassHeading(_this_1.calcCompassHeadingByOrientation(e.alpha || 0, e.beta || 0, e.gamma || 0));
                        });
                        break;
                    case 'webkit':
                        window.addEventListener('deviceorientation', function (e) {
                            _this_1.setCompassHeading(e.webkitCompassHeading);
                        });
                        break;
                    case 'alpha':
                        window.addEventListener('deviceorientation', function (e) {
                            _this_1.setCompassHeading(360 - (e.alpha || 0));
                        });
                        break;
                    case 'absoluteAlpha':
                        window.addEventListener('deviceorientationabsolute', function (e) {
                            _this_1.setCompassHeading(360 - (e.alpha || 0));
                        });
                        break;
                    case 'webkitDD':
                        if (navigator.userAgent.toLowerCase().indexOf('dingtalk') > -1) {
                            var openId_1 = parseUrl(location.href).openId;
                            if (!openId_1) {
                                console.error('PalmapLocation: 鏃犳硶鑾峰彇openId璇峰湪閫氳繃url浼犲弬鐨勬柟寮忔嫾鎺penId');
                            }
                            var url_1;
                            if (!_this_1.compassSocket) {
                                url_1 = 'wss://park-unified.ipalmap.com:10201/data-exchange/location' + "/" + openId_1;
                            }
                            else {
                                url_1 = _this_1.compassSocket + '/' + openId_1;
                            }
                            _this_1.socketMng = new SocketManager(url_1);
                            _this_1.socketMng.on('message', function (data) {
                                data = JSON.parse(data);
                                _this.setCompassHeading(parseInt(data.direction));
                            });
                        }
                        else {
                            window.addEventListener('deviceorientation', function (e) {
                                _this_1.setCompassHeading(e.webkitCompassHeading);
                            });
                        }
                        break;
                    case 'socket':
                        var openId = parseUrl(location.href).openId;
                        if (!openId) {
                            console.error('CompassManager: 鏃犳硶鑾峰彇openId璇峰湪閫氳繃url浼犲弬鐨勬柟寮忔嫾鎺penId');
                        }
                        var url = void 0;
                        if (!_this_1.compassSocket) {
                            url = 'wss://park-unified.ipalmap.com:10201/data-exchange/location' + "/" + openId;
                        }
                        else {
                            url = _this_1.compassSocket + '/' + openId;
                        }
                        _this_1.socketMng = new SocketManager(url);
                        _this_1.socketMng.on('message', function (data) {
                            data = JSON.parse(data);
                            _this.setCompassHeading(parseInt(data.direction));
                        });
                        break;
                    default:
                        window.addEventListener('deviceorientation', function (e) {
                            _this_1.setCompassHeading(360 - (e.alpha || 0));
                        });
                        break;
                }
            };
            this.calcCompassHeadingByOrientation = function (alpha, beta, gamma) {
                var alphaRad = alpha * (Math.PI / 180);
                var betaRad = beta * (Math.PI / 180);
                var gammaRad = gamma * (Math.PI / 180);
                var cA = Math.cos(alphaRad);
                var sA = Math.sin(alphaRad);
                var sB = Math.sin(betaRad);
                var cG = Math.cos(gammaRad);
                var sG = Math.sin(gammaRad);
                var rA = cA * cG - sA * sB * sG;
                var rB = cG * sA + cA * sB * sG;
                var compassHeading = Math.atan2(rB, rA);
                compassHeading *= 180 / Math.PI;
                return compassHeading;
            };
            var compassHeading = palmapLocationConfig.output.compassHeading || 0;
            var _a = palmapLocationConfig.input, androidCompassHeadingType = _a.androidCompassHeadingType, iosCompassHeadingType = _a.iosCompassHeadingType, defaultCompassHeadingType = _a.defaultCompassHeadingType;
            this.compassSocket = palmapLocationConfig.input.compassSocket;
            this.bleManager = bleManager;
            this.setCompassHeading(compassHeading);
            this.maxAngelDiff = palmapLocationConfig.input.maxAngleDiff || 10;
            this.headingOffset = palmapLocationConfig.input.headingOffset || 0;
            this.calcCompassHeading(androidCompassHeadingType, iosCompassHeadingType, defaultCompassHeadingType);
        }
        CompassManager.prototype.requestPermission = function () {
            if (typeof window.DeviceOrientationEvent !== 'undefined' && typeof (DeviceOrientationEvent.requestPermission) === 'function') {
                var div_1 = document.createElement('div');
                div_1.className = 'locationSDK-requestPermission-div';
                div_1.style.cssText = "\n                width: 100%;\n                height: 100%;\n                position: fixed;\n                top: 0;\n                left: 0;\n                background: rgba(0, 0, 0, 0.35);\n                display: flex;\n                justify-content: center;\n                align-items: center;\n            ";
                var btn = document.createElement('button');
                btn.className = 'locationSDK-requestPermission-btn';
                btn.style.cssText = "\n                padding: 10px 15px;\n                border-radius: 4px;\n                background: #99CC99;\n                border: none;\n                color: #fff;\n                letter-spacing: 2px;\n            ";
                btn.textContent = '鑾峰彇缃楃洏鏉冮檺';
                btn.addEventListener('click', function () {
                    DeviceOrientationEvent.requestPermission().then(function (res) {
                        if (res !== 'granted') {
                            LogMgr.log('not allow');
                        }
                        div_1.remove();
                    }, function (err) {
                        LogMgr.log('request permission', err);
                        div_1.remove();
                    });
                });
                div_1.appendChild(btn);
                document.body.appendChild(div_1);
            }
        };
        CompassManager.prototype.setConvertAngle = function (converAngle) {
            this.convertAngle = converAngle;
        };
        CompassManager.prototype.setEnableConvert = function (isEnableConvert) {
            this.isEnableConvert = isEnableConvert;
        };
        return CompassManager;
    }());

    var gSensorPeak = (function () {
        var oriValues = [];
        var valueNum = 4;
        var tempValue = [];
        var tempCount = 0;
        var isDirectionUp = false;
        var continueUpCount = 0;
        var continueUpFormerCount = 0;
        var lastStatus = false;
        var peakOfWave = 0;
        var valleyOfWave = 0;
        var timeOfThisPeak = 0;
        var timeOfLastPeak = 0;
        var timeOfNow = 0;
        var gravityNew = 0;
        var gravityOld = 0;
        var initialValue = 1.3;
        var ThreadValue = 2.0;
        var stepValue = 0;
        var lastStepValue = 0;
        var diffStepValue = 0;
        window.addEventListener('devicemotion', countStep, false);
        var _callback = null;
        function countStep (eventData) {
            oriValues.splice(0, oriValues.length);
            var accelerationGravity = eventData.accelerationIncludingGravity;
            oriValues.push(accelerationGravity.x);
            oriValues.push(accelerationGravity.y);
            oriValues.push(accelerationGravity.z);
            gravityNew = Math.sqrt(oriValues[0] * oriValues[0]
                + oriValues[1] * oriValues[1] + oriValues[2] * oriValues[2]);
            DetectorNewStep(gravityNew);
            var stepDom = document.getElementById("step");
            stepDom ? stepDom.innerHTML = gSensor.getStep().toString() : "";
            _callback ? _callback(stepValue) : "";
        }
        var onStepListener = null;
        var onStep = function () {
            if (onStepListener) {
                onStepListener();
            }
        };
        var registerStep = function (callback) {
            onStepListener = callback;
        };
        function DetectorNewStep (values) {
            if (gravityOld === 0) {
                gravityOld = values;
            }
            else {
                if (DetectorPeak(values, gravityOld)) {
                    timeOfLastPeak = timeOfThisPeak;
                    timeOfNow = new Date().getTime();
                    if (timeOfNow - timeOfLastPeak >= 250
                        && (peakOfWave - valleyOfWave >= ThreadValue)) {
                        timeOfThisPeak = timeOfNow;
                        onStep();
                        stepValue++;
                        diffStepValue = stepValue - lastStepValue;
                    }
                    if (timeOfNow - timeOfLastPeak >= 250
                        && (peakOfWave - valleyOfWave >= initialValue)) {
                        timeOfThisPeak = timeOfNow;
                        ThreadValue = Peak_Valley_Thread(peakOfWave - valleyOfWave);
                    }
                }
            }
            gravityOld = values;
        }
        function DetectorPeak (newValue, oldValue) {
            lastStatus = isDirectionUp;
            if (newValue >= oldValue) {
                isDirectionUp = true;
                continueUpCount++;
            }
            else {
                continueUpFormerCount = continueUpCount;
                continueUpCount = 0;
                isDirectionUp = false;
            }
            if (!isDirectionUp && lastStatus
                && (continueUpFormerCount >= 2 || oldValue >= 20)) {
                peakOfWave = oldValue;
                return true;
            }
            else if (!lastStatus && isDirectionUp) {
                valleyOfWave = oldValue;
                return false;
            }
            else {
                return false;
            }
        }
        function Peak_Valley_Thread (value) {
            var tempThread = ThreadValue;
            if (tempCount < valueNum) {
                tempValue[tempCount] = value;
                tempCount++;
            }
            else {
                tempThread = averageValue(tempValue, valueNum);
                for (var i = 1; i < valueNum; i++) {
                    tempValue[i - 1] = tempValue[i];
                }
                tempValue[valueNum - 1] = value;
            }
            return tempThread;
        }
        function averageValue (value, n) {
            var ave = 0;
            for (var i = 0; i < n; i++) {
                ave += value[i];
            }
            ave = ave / valueNum;
            if (ave >= 8)
                ave = 4.3;
            else if (ave >= 7 && ave < 8)
                ave = 3.3;
            else if (ave >= 4 && ave < 7)
                ave = 2.3;
            else if (ave >= 3 && ave < 4)
                ave = 2.0;
            else {
                ave = 1.3;
            }
            return ave;
        }
        var gSensor = {
            setCallback: function (callback) {
                _callback = callback;
            },
            getDiffStep: function () {
                diffStepValue = stepValue - lastStepValue;
                lastStepValue = stepValue;
                return diffStepValue;
            },
            onStep: registerStep,
            getStep: function () {
                return stepValue;
            }
        };
        return gSensor;
    })();

    var InertialManager = (function () {
        function InertialManager (palmapLocationConfig, compassManager) {
            var _this = this;
            this.lastGSensorTime = 0;
            this.defaultLength = 0;
            this.stepLength = 0;
            this.onStepCallbacks = [];
            this.registerOnStep = function (cb) {
                if (typeof cb === 'function') {
                    _this.onStepCallbacks.push(cb);
                }
            };
            this.unregisterOnStep = function (cb) {
                var index = _this.onStepCallbacks.indexOf(cb);
                index !== -1 && _this.onStepCallbacks.splice(index, 1);
            };
            this.compassManager = compassManager;
            this.onStepCallbacks = [];
            var _a = palmapLocationConfig.average, iosStepLength = _a.iosStepLength, androidStepLength = _a.androidStepLength;
            switch (checkDeviceType()) {
                case "Android":
                    this.defaultLength = androidStepLength;
                    break;
                case "iOS":
                    this.defaultLength = iosStepLength;
                    break;
                default:
                    this.defaultLength = androidStepLength;
                    break;
            }
            gSensorPeak.onStep(function () {
                var now = Date.now();
                if (!_this.lastGSensorTime) {
                    _this.lastGSensorTime = now - 500;
                }
                var T = (now - _this.lastGSensorTime) / 1000;
                _this.stepLength = _this.defaultLength;
                var compassHeading = _this.compassManager.getCompassHeading();
                var offsetX = _this.stepLength * Math.sin(compassHeading * (Math.PI / 180));
                var offsetY = _this.stepLength * Math.cos(compassHeading * (Math.PI / 180));
                _this.execRegisterOnStep(offsetX, offsetY, T);
                _this.lastGSensorTime = now;
            });
        }
        InertialManager.prototype.execRegisterOnStep = function (offsetX, offsetY, T) {
            this.onStepCallbacks.forEach(function (cb) {
                cb(offsetX, offsetY, T);
            });
        };
        return InertialManager;
    }());

    var lastInertialTimestamp;
    var inertialTimestampAverageDiff;
    var InertialAverage = (function () {
        function InertialAverage (palmapLocationConfig) {
            var _this = this;
            this.isConvertAfterStop = false;
            this.lastAverageLocation = null;
            this.lastLocation = null;
            this.inertialAverageLocation = null;
            this.inertialLocation = null;
            this.calcInertialAverageLocation = function (averageLocation) {
                if (!checkLocation(averageLocation))
                    return null;
                _this.lastAverageLocation = averageLocation;
                if (!_this.lastLocation || _this.lastLocation.floor !== _this.lastAverageLocation.floor ||
                    !_this.inertialLocation) {
                    _this.inertialAverageLocation = _this.lastAverageLocation;
                }
                else {
                    if ((Date.now() - (_this.inertialLocation.timestamp || 0)) > _this.maxOffsetTime) {
                        if (!_this.isConvertAfterStop) {
                            _this.inertialAverageLocation = _this.lastAverageLocation;
                            _this.isConvertAfterStop = true;
                        }
                        else {
                            _this.inertialAverageLocation = _this.lastLocation;
                        }
                    }
                    else {
                        var distance = getDistance(_this.inertialLocation, _this.lastAverageLocation);
                        _this.inertialAverageLocation = distance > _this.minCalibrationDistance ? _this.lastAverageLocation : {
                            x: _this.inertialLocation.x * (1 - _this.radio) + _this.lastAverageLocation.x * _this.radio,
                            y: _this.inertialLocation.y * (1 - _this.radio) + _this.lastAverageLocation.y * _this.radio,
                            floor: _this.lastAverageLocation.floor,
                        };
                    }
                }
                return _this.setCurrentLocation(__assign(__assign({}, _this.inertialAverageLocation), { duration: 800 }));
            };
            this.calcInertialLocation = function (offsetX, offsetY, T) {
                if (!_this.lastLocation || !_this.lastAverageLocation) {
                    return null;
                }
                _this.isConvertAfterStop = false;
                var now = Date.now();
                var offsetLocation = {
                    x: _this.lastLocation.x + offsetX,
                    y: _this.lastLocation.y + offsetY,
                    floor: _this.lastLocation.floor,
                    timestamp: now,
                };
                var distance = getDistance(offsetLocation, _this.lastAverageLocation);
                _this.inertialLocation = distance > _this.maxOffsetDistance ? _this.lastLocation : offsetLocation;
                _this.inertialLocation.timestamp = now;
                if (!lastInertialTimestamp) {
                    inertialTimestampAverageDiff = 300;
                }
                else {
                    var timeDiff = now - lastInertialTimestamp;
                    inertialTimestampAverageDiff = timeDiff > 2000 ?
                        300 : (inertialTimestampAverageDiff + timeDiff) / 2;
                }
                lastInertialTimestamp = now;
                return _this.setCurrentLocation(__assign(__assign({}, _this.inertialLocation), { duration: inertialTimestampAverageDiff }));
            };
            this.setCurrentLocation = function (currentLocation) {
                _this.lastLocation = __assign(__assign({}, currentLocation), { timestamp: Date.now() });
                return _this.lastLocation;
            };
            var _a = palmapLocationConfig.average, maxOffsetDistance = _a.maxOffsetDistance, maxOffsetTime = _a.maxOffsetTime, minCalibrationDistance = _a.minCalibrationDistance, androidAverageLocationTrustRatio = _a.androidAverageLocationTrustRatio, iosAverageLocationTrustRatio = _a.iosAverageLocationTrustRatio;
            switch (checkDeviceType()) {
                case 'Android':
                    this.radio = androidAverageLocationTrustRatio;
                    break;
                case 'iOS':
                    this.radio = iosAverageLocationTrustRatio;
                    break;
                default:
                    this.radio = androidAverageLocationTrustRatio;
                    break;
            }
            this.maxOffsetDistance = maxOffsetDistance;
            this.maxOffsetTime = maxOffsetTime;
            this.minCalibrationDistance = minCalibrationDistance;
            this.lastAverageLocation = null;
            this.lastLocation = null;
            this.inertialAverageLocation = null;
            this.inertialLocation = null;
        }
        return InertialAverage;
    }());

    if (!Promise) {
        console.error('your browser is not support Promise');
    }
    function request (url, options, method) {
        if (options === void 0) { options = {}; }
        if (method === void 0) { method = 'GET'; }
        if (options.query) {
            var arr = [];
            for (var key in options.query) {
                if (options.query.hasOwnProperty(key))
                    arr.push(key + "=" + encodeURIComponent(options.query[key]));
            }
            url += (/\?/.test(url) ? '&' : '?') + arr.join('&');
        }
        var xhr = new XMLHttpRequest();
        xhr.open(method.toUpperCase(), url, true);
        var data;
        if (options.json) {
            xhr.setRequestHeader('Content-Type', 'application/json;charset=utf-8');
            data = JSON.stringify(options.json);
        }
        if (options.form) {
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');
            data = JSON.stringify(options.form);
        }
        if (options.body) {
            data = options.body;
        }
        if (options.headers) {
            for (var key in options.headers) {
                if (options.headers.hasOwnProperty(key))
                    xhr.setRequestHeader(key, options.headers[key]);
            }
        }
        if (options.timeout) {
            xhr.timeout = options.timeout;
        }
        if (options.responseType) {
            xhr.responseType = options.responseType;
        }
        options.timeout && (xhr.timeout = options.timeout);
        xhr.send(data);
        return new Promise(function (resolve, reject) {
            xhr.onload = function () {
                var resContentType = xhr.getResponseHeader('Content-Type') || '';
                if (xhr.readyState === 4 && xhr.status === 200) {
                    if (resContentType.indexOf('application/json') !== -1) {
                        resolve(JSON.parse(xhr.response));
                    }
                    else {
                        resolve(xhr.response);
                    }
                }
                else {
                    if (resContentType.indexOf('application/json') !== -1) {
                        reject(JSON.parse(xhr.response));
                    }
                    else {
                        reject(xhr.response);
                    }
                }
            };
            xhr.onerror = function (err) {
                reject(err);
            };
            xhr.ontimeout = function () {
                reject(new Error('timeout'));
            };
            xhr.onabort = function () {
                reject(new Error('abort'));
            };
        });
    }
    request.defaultHeaders = {};
    request.setDefaultHeader = function (defaultHeaders) {
        if (defaultHeaders === void 0) { defaultHeaders = {}; }
        request.defaultHeaders = defaultHeaders;
    };
    request.get = function (url, options) {
        if (options === void 0) { options = {}; }
        return request(url, options, "GET");
    };
    request.post = function (url, options) {
        if (options === void 0) { options = {}; }
        return request(url, options, 'POST');
    };
    request.del = function (url, options) {
        if (options === void 0) { options = {}; }
        return request(url, options, 'DELETE');
    };
    request.put = function (url, options) {
        if (options === void 0) { options = {}; }
        return request(url, options, 'PUT');
    };

    var LocationSDK = (function () {
        function LocationSDK (palmapLocationConfig) {
            var _this = this;
            this.palmapLocationChangeCallbacks = [];
            this.lastReceiveBeaconTime = null;
            this.locationMode = 'indoor';
            this.beacons = [];
            this.palmapLocation = {};
            this.locationChangeCbs = [];

            this.cindyBeaconCbs = [];
            this.start = function () {
                var locationType = _this.palmapLocationConfig.input.locationType;
                _this.averageEngine = new AverageEngine(_this.palmapLocationConfig);
                switch (locationType) {
                    case 'Average':
                        _this.averageEngine.registerLocationChange(function (averageLocation) {
                            _this.setLocation(averageLocation);
                        });
                        _this.bleMng.registerSearchBeacon(function (beacons) {
                            _this.averageEngine.calculate(beacons);
                        });
                        break;
                    case 'AverageInertial':
                        var inertialManager = new InertialManager(_this.palmapLocationConfig, _this.compassManager);
                        var averageCalculate_1 = new InertialAverage(_this.palmapLocationConfig);
                        inertialManager.registerOnStep(function (offsetX, offsetY, T) {
                            var inertialLocation = averageCalculate_1.calcInertialLocation(offsetX, offsetY, T);
                            _this.setLocation(inertialLocation);
                        });
                        _this.averageEngine.registerLocationChange(function (averageLocation) {
                            if (checkLocation(averageLocation)) {
                                _this.lastReceiveBeaconTime = Date.now();
                                _this.locationMode = 'indoor';
                                _this.averageLocation = averageLocation;
                            }
                            var inertialAverageLocation = averageCalculate_1.calcInertialAverageLocation(averageLocation);
                            _this.setLocation(inertialAverageLocation);
                        });
                        _this.bleMng.registerSearchBeacon(function (beacons) {
                            _this.averageEngine.calculate(beacons);
                        });
                        break;
                    default:
                        console.error("LocationSDK: locationType is uncorrected");
                        break;
                }
            };
            this.stop = function () {
                _this.setLocation(_this.palmapLocationConfig.output.location);
                _this.bleMng.stop();
            };
            this.registerPalmapLocationChange = function (cb) {
                if (typeof cb === 'function') {
                    _this.palmapLocationChangeCallbacks.push(cb);
                }
            };
            this.unregisterPalmapLocationChange = function (cb) {
                var index = _this.palmapLocationChangeCallbacks.indexOf(cb);
                index !== -1 && _this.palmapLocationChangeCallbacks.splice(index, 1);
            };
            this.setLocation = function (location) {
                if (!location)
                    return;
                if (!location.x || !location.y)
                    return;
                _this.palmapLocation = __assign({}, location);
                _this.palmapLocation.timestamp = Date.now();
                if (_this.averageLocation) {
                    _this.averageLocation.x = location.x;
                    _this.averageLocation.y = location.y;
                }
                _this.execPalmapLocationChange(_this.palmapLocation);
            };
            this.getLocation = function () {
                var timestamp = _this.palmapLocation.timestamp;
                if (Date.now() - timestamp > 5 * 1000) {
                    _this.setLocation(_this.palmapLocationConfig.output.location);
                }
                return _this.palmapLocation;
            };
            if (!palmapLocationConfig) {
                console.error('LocationSDK: palmapLocationConfig, is required');
                return;
            }
            this.palmapLocationConfig = palmapLocationConfig;
            this.palmapLocationChangeCallbacks = [];
            var openId = parseUrl(location.href).openId;
            if (!openId) {
                openId = 'oerg95fTEJe50kMwQB8--fjEsKWQ';
                //console.error('LocationSDK: 鏃犳硶鑾峰彇openId璇峰湪閫氳繃url浼犲弬鐨勬柟寮忔嫾鎺penId');
            }
            var defaultSocket = 'wss://hospital-location-transfer.ipalmap.com:8080/location';
            var _a = this.palmapLocationConfig.input, signatureUrl = _a.signatureUrl, wxAppId = _a.wxAppId, uuid = _a.uuid, bleType = _a.bleType, socket = _a.socket;
            this.bleMng = new BleManager({
                signatureUrl: signatureUrl || 'https://weixin.ipalmap.com/api/getSignature',
                appId: wxAppId,
                uuid: uuid,
                bleType: bleType,
                socket: socket || defaultSocket,
                openId: openId,
            });
            this.bleMng.registerSearchBeacon(function (beacons) {
                _this.beacons = beacons;
            });
            this.compassManager = new CompassManager(this.bleMng, this.palmapLocationConfig);
        }
        LocationSDK.prototype.setConvertAngle = function (angle) {
            this.compassManager.setConvertAngle(angle);
        };
        LocationSDK.prototype.setEnableConvert = function (isEnableConvert) {
            this.compassManager.setEnableConvert(isEnableConvert);
        };
        LocationSDK.prototype.registerCompassChange = function (cb) {
            this.compassManager.registerCompassChange(cb);
        };
        LocationSDK.prototype.registerGetSignature = function (cb) {
            this.bleMng && this.bleMng.registerGetSignature(cb);
        };
        LocationSDK.prototype.registerLocationChange = function (cb) {
            if (typeof cb === 'function') {
                this.locationChangeCbs.push(cb);
            }
        };
        LocationSDK.prototype.registerCindyBeacons = function (cb) {
            this.averageEngine.registerCindyBeacons(cb);
        };
        LocationSDK.prototype.registerStartComplete = function (cb) {
            this.bleMng && this.bleMng.registerStartComplete(cb);
        };
        LocationSDK.prototype.execPalmapLocationChange = function (palmapLocation) {
            this.palmapLocationChangeCallbacks.forEach(function (cb) {
                cb(palmapLocation);
            });
        };
        LocationSDK.prototype.getStartBeaconStatus = function () {
            if (!this.bleMng)
                return null;
            return this.bleMng.getStartBeaconStatus();
        };
        LocationSDK.prototype.setRssiLimit = function (rssiLimit) {
            this.averageEngine.setRssiLimit(rssiLimit);
        };
        LocationSDK.setIdConfig = function (userId, projectId) {
            LocationSDK.userId = userId;
            LocationSDK.projectId = projectId;
            request.setDefaultHeader({
                'user-id': userId,
                'project-id': projectId,
            });
        };
        LocationSDK.version = '2.0.1';
        return LocationSDK;
    }());

    var version$1 = "2.0.1";

    LocationSDK.version = version$1;

    var defaultOptions$c = {
        server: 'https://new-sdknagrand.ipalmap.com:18090',
        searchServer: '',
        useCache: true,
        minZoom: 10,
        maxZoom: 30,
        enableOutdoor: false,
        viewType: 'single',
        floorHeight: 30,
        localFontFamily: 'sans-serif',
        fontWeight: 'normal',
        maxTextSize: 10,
        multiFadeOpacity: 0.5,
        isExtra: true,
        pitch: 0,
        bOnly2d: true,
    };

    var Light = (function () {
        function Light(name, pos, color) {
            this.m_name = name;
            this.m_pos = pos;
            this.m_color = color;
        }
        return Light;
    }());

    /*
    Copyright (c) 2011 Juan Mellado

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    */

    /*
    References:
    - "OpenCV: Open Computer Vision Library"
      http://sourceforge.net/projects/opencvlibrary/
    - "Stack Blur: Fast But Goodlooking"
      http://incubator.quasimondo.com/processing/fast_blur_deluxe.php
    */

    var CV = CV || {};

    CV.Image = function(width, height, data){
      this.width = width || 0;
      this.height = height || 0;
      this.data = data || [];
    };

    CV.grayscale = function(imageSrc, imageDst){
      var src = imageSrc.data, dst = imageDst.data, len = src.length,
          i = 0, j = 0;

      for (; i < len; i += 4){
        dst[j ++] =
          (src[i] * 0.299 + src[i + 1] * 0.587 + src[i + 2] * 0.114 + 0.5) & 0xff;
      }
      
      imageDst.width = imageSrc.width;
      imageDst.height = imageSrc.height;
      
      return imageDst;
    };

    CV.threshold = function(imageSrc, imageDst, threshold){
      var src = imageSrc.data, dst = imageDst.data,
          len = src.length, tab = [], i;

      for (i = 0; i < 256; ++ i){
        tab[i] = i <= threshold? 0: 255;
      }

      for (i = 0; i < len; ++ i){
        dst[i] = tab[ src[i] ];
      }

      imageDst.width = imageSrc.width;
      imageDst.height = imageSrc.height;

      return imageDst;
    };

    CV.adaptiveThreshold = function(imageSrc, imageDst, kernelSize, threshold){
      var src = imageSrc.data, dst = imageDst.data, len = src.length, tab = [], i;

      CV.stackBoxBlur(imageSrc, imageDst, kernelSize);

      for (i = 0; i < 768; ++ i){
        tab[i] = (i - 255 <= -threshold)? 255: 0;
      }

      for (i = 0; i < len; ++ i){
        dst[i] = tab[ src[i] - dst[i] + 255 ];
      }

      imageDst.width = imageSrc.width;
      imageDst.height = imageSrc.height;
      
      return imageDst;
    };

    CV.otsu = function(imageSrc){
      var src = imageSrc.data, len = src.length, hist = [],
          threshold = 0, sum = 0, sumB = 0, wB = 0, wF = 0, max = 0,
          mu, between, i;

      for (i = 0; i < 256; ++ i){
        hist[i] = 0;
      }
      
      for (i = 0; i < len; ++ i){
        hist[ src[i] ] ++;
      }

      for (i = 0; i < 256; ++ i){
        sum += hist[i] * i;
      }

      for (i = 0; i < 256; ++ i){
        wB += hist[i];
        if (0 !== wB){
        
          wF = len - wB;
          if (0 === wF){
            break;
          }

          sumB += hist[i] * i;
          
          mu = (sumB / wB) - ( (sum - sumB) / wF );

          between = wB * wF * mu * mu;
          
          if (between > max){
            max = between;
            threshold = i;
          }
        }
      }

      return threshold;
    };

    CV.stackBoxBlurMult =
      [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265];

    CV.stackBoxBlurShift =
      [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13];

    CV.BlurStack = function(){
      this.color = 0;
      this.next = null;
    };

    CV.stackBoxBlur = function(imageSrc, imageDst, kernelSize){
      var src = imageSrc.data, dst = imageDst.data,
          height = imageSrc.height, width = imageSrc.width,
          heightMinus1 = height - 1, widthMinus1 = width - 1,
          size = kernelSize + kernelSize + 1, radius = kernelSize + 1,
          mult = CV.stackBoxBlurMult[kernelSize],
          shift = CV.stackBoxBlurShift[kernelSize],
          stack, stackStart, color, sum, pos, start, p, x, y, i;

      stack = stackStart = new CV.BlurStack();
      for (i = 1; i < size; ++ i){
        stack = stack.next = new CV.BlurStack();
      }
      stack.next = stackStart;

      pos = 0;

      for (y = 0; y < height; ++ y){
        start = pos;
        
        color = src[pos];
        sum = radius * color;
        
        stack = stackStart;
        for (i = 0; i < radius; ++ i){
          stack.color = color;
          stack = stack.next;
        }
        for (i = 1; i < radius; ++ i){
          stack.color = src[pos + i];
          sum += stack.color;
          stack = stack.next;
        }
      
        stack = stackStart;
        for (x = 0; x < width; ++ x){
          dst[pos ++] = (sum * mult) >>> shift;
          
          p = x + radius;
          p = start + (p < widthMinus1? p: widthMinus1);
          sum -= stack.color - src[p];
          
          stack.color = src[p];
          stack = stack.next;
        }
      }

      for (x = 0; x < width; ++ x){
        pos = x;
        start = pos + width;
        
        color = dst[pos];
        sum = radius * color;
        
        stack = stackStart;
        for (i = 0; i < radius; ++ i){
          stack.color = color;
          stack = stack.next;
        }
        for (i = 1; i < radius; ++ i){
          stack.color = dst[start];
          sum += stack.color;
          stack = stack.next;
          
          start += width;
        }
        
        stack = stackStart;
        for (y = 0; y < height; ++ y){
          dst[pos] = (sum * mult) >>> shift;
          
          p = y + radius;
          p = x + ( (p < heightMinus1? p: heightMinus1) * width );
          sum -= stack.color - dst[p];
          
          stack.color = dst[p];
          stack = stack.next;
          
          pos += width;
        }
      }

      return imageDst;
    };

    CV.gaussianBlur = function(imageSrc, imageDst, imageMean, kernelSize){
      var kernel = CV.gaussianKernel(kernelSize);

      imageDst.width = imageSrc.width;
      imageDst.height = imageSrc.height;
      
      imageMean.width = imageSrc.width;
      imageMean.height = imageSrc.height;

      CV.gaussianBlurFilter(imageSrc, imageMean, kernel, true);
      CV.gaussianBlurFilter(imageMean, imageDst, kernel, false);

      return imageDst;
    };

    CV.gaussianBlurFilter = function(imageSrc, imageDst, kernel, horizontal){
      var src = imageSrc.data, dst = imageDst.data,
          height = imageSrc.height, width = imageSrc.width,
          pos = 0, limit = kernel.length >> 1,
          cur, value, i, j, k;
          
      for (i = 0; i < height; ++ i){
        
        for (j = 0; j < width; ++ j){
          value = 0.0;
        
          for (k = -limit; k <= limit; ++ k){

            if (horizontal){
              cur = pos + k;
              if (j + k < 0){
                cur = pos;
              }
              else if (j + k >= width){
                cur = pos;
              }
            }else {
              cur = pos + (k * width);
              if (i + k < 0){
                cur = pos;
              }
              else if (i + k >= height){
                cur = pos;
              }
            }

            value += kernel[limit + k] * src[cur];
          }
        
          dst[pos ++] = horizontal? value: (value + 0.5) & 0xff;
        }
      }

      return imageDst;
    };

    CV.gaussianKernel = function(kernelSize){
      var tab =
        [ [1],
          [0.25, 0.5, 0.25],
          [0.0625, 0.25, 0.375, 0.25, 0.0625],
          [0.03125, 0.109375, 0.21875, 0.28125, 0.21875, 0.109375, 0.03125] ],
        kernel = [], center, sigma, scale2X, sum, x, i;

      if ( (kernelSize <= 7) && (kernelSize % 2 === 1) ){
        kernel = tab[kernelSize >> 1];
      }else {
        center = (kernelSize - 1.0) * 0.5;
        sigma = 0.8 + (0.3 * (center - 1.0) );
        scale2X = -0.5 / (sigma * sigma);
        sum = 0.0;
        for (i = 0; i < kernelSize; ++ i){
          x = i - center;
          sum += kernel[i] = Math.exp(scale2X * x * x);
        }
        sum = 1 / sum;
        for (i = 0; i < kernelSize; ++ i){
          kernel[i] *= sum;
        }  
      }

      return kernel;
    };

    CV.findContours = function(imageSrc, binary){
      var width = imageSrc.width, height = imageSrc.height, contours = [],
          src, deltas, pos, pix, nbd, outer, hole, i, j;
      
      src = CV.binaryBorder(imageSrc, binary);

      deltas = CV.neighborhoodDeltas(width + 2);

      pos = width + 3;
      nbd = 1;

      for (i = 0; i < height; ++ i, pos += 2){
      
        for (j = 0; j < width; ++ j, ++ pos){
          pix = src[pos];

          if (0 !== pix){
            outer = hole = false;

            if (1 === pix && 0 === src[pos - 1]){
              outer = true;
            }
            else if (pix >= 1 && 0 === src[pos + 1]){
              hole = true;
            }

            if (outer || hole){
              ++ nbd;
              
              contours.push( CV.borderFollowing(src, pos, nbd, {x: j, y: i}, hole, deltas) );
            }
          }
        }
      }  

      return contours;
    };

    CV.borderFollowing = function(src, pos, nbd, point, hole, deltas){
      var contour = [], pos1, pos3, pos4, s, s_end;

      contour.hole = hole;
          
      s = s_end = hole? 0: 4;
      do{
        s = (s - 1) & 7;
        pos1 = pos + deltas[s];
        if (src[pos1] !== 0){
          break;
        }
      }while(s !== s_end);
      
      if (s === s_end){
        src[pos] = -nbd;
        contour.push( {x: point.x, y: point.y} );

      }else {
        pos3 = pos;

        while(true){
          s_end = s;
        
          do{
            pos4 = pos3 + deltas[++ s];
          }while(src[pos4] === 0);
          
          s &= 7;
          
          if ( ( (s - 1) >>> 0) < (s_end >>> 0) ){
            src[pos3] = -nbd;
          }
          else if (src[pos3] === 1){
            src[pos3] = nbd;
          }

          contour.push( {x: point.x, y: point.y} );

          point.x += CV.neighborhood[s][0];
          point.y += CV.neighborhood[s][1];

          if ( (pos4 === pos) && (pos3 === pos1) ){
            break;
          }
          
          pos3 = pos4;
          s = (s + 4) & 7;
        }
      }

      return contour;
    };

    CV.neighborhood = 
      [ [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1] ];

    CV.neighborhoodDeltas = function(width){
      var deltas = [], len = CV.neighborhood.length, i = 0;
      
      for (; i < len; ++ i){
        deltas[i] = CV.neighborhood[i][0] + (CV.neighborhood[i][1] * width);
      }
      
      return deltas.concat(deltas);
    };

    CV.approxPolyDP = function(contour, epsilon){
      var slice = {start_index: 0, end_index: 0},
          right_slice = {start_index: 0, end_index: 0},
          poly = [], stack = [], len = contour.length,
          pt, start_pt, end_pt, dist, max_dist, le_eps,
          dx, dy, i, j, k;
      
      epsilon *= epsilon;
      
      k = 0;
      
      for (i = 0; i < 3; ++ i){
        max_dist = 0;
        
        k = (k + right_slice.start_index) % len;
        start_pt = contour[k];
        if (++ k === len) {k = 0;}
      
        for (j = 1; j < len; ++ j){
          pt = contour[k];
          if (++ k === len) {k = 0;}
        
          dx = pt.x - start_pt.x;
          dy = pt.y - start_pt.y;
          dist = dx * dx + dy * dy;

          if (dist > max_dist){
            max_dist = dist;
            right_slice.start_index = j;
          }
        }
      }

      if (max_dist <= epsilon){
        poly.push( {x: start_pt.x, y: start_pt.y} );

      }else {
        slice.start_index = k;
        slice.end_index = (right_slice.start_index += slice.start_index);
      
        right_slice.start_index -= right_slice.start_index >= len? len: 0;
        right_slice.end_index = slice.start_index;
        if (right_slice.end_index < right_slice.start_index){
          right_slice.end_index += len;
        }
        
        stack.push( {start_index: right_slice.start_index, end_index: right_slice.end_index} );
        stack.push( {start_index: slice.start_index, end_index: slice.end_index} );
      }

      while(stack.length !== 0){
        slice = stack.pop();
        
        end_pt = contour[slice.end_index % len];
        start_pt = contour[k = slice.start_index % len];
        if (++ k === len) {k = 0;}
        
        if (slice.end_index <= slice.start_index + 1){
          le_eps = true;
        
        }else {
          max_dist = 0;

          dx = end_pt.x - start_pt.x;
          dy = end_pt.y - start_pt.y;
          
          for (i = slice.start_index + 1; i < slice.end_index; ++ i){
            pt = contour[k];
            if (++ k === len) {k = 0;}
            
            dist = Math.abs( (pt.y - start_pt.y) * dx - (pt.x - start_pt.x) * dy);

            if (dist > max_dist){
              max_dist = dist;
              right_slice.start_index = i;
            }
          }
          
          le_eps = max_dist * max_dist <= epsilon * (dx * dx + dy * dy);
        }
        
        if (le_eps){
          poly.push( {x: start_pt.x, y: start_pt.y} );

        }else {
          right_slice.end_index = slice.end_index;
          slice.end_index = right_slice.start_index;

          stack.push( {start_index: right_slice.start_index, end_index: right_slice.end_index} );
          stack.push( {start_index: slice.start_index, end_index: slice.end_index} );
        }
      }
      
      return poly;
    };

    CV.warp = function(imageSrc, imageDst, contour, warpSize){
      var src = imageSrc.data, dst = imageDst.data,
          width = imageSrc.width, height = imageSrc.height,
          pos = 0,
          sx1, sx2, dx1, dx2, sy1, sy2, dy1, dy2, p1, p2, p3, p4,
          m, r, s, t, u, v, w, x, y, i, j;
      
      m = CV.getPerspectiveTransform(contour, warpSize - 1);

      r = m[8];
      s = m[2];
      t = m[5];
      
      for (i = 0; i < warpSize; ++ i){
        r += m[7];
        s += m[1];
        t += m[4];

        u = r;
        v = s;
        w = t;
        
        for (j = 0; j < warpSize; ++ j){
          u += m[6];
          v += m[0];
          w += m[3];

          x = v / u;
          y = w / u;

          sx1 = x >>> 0;
          sx2 = (sx1 === width - 1)? sx1: sx1 + 1;
          dx1 = x - sx1;
          dx2 = 1.0 - dx1;

          sy1 = y >>> 0;
          sy2 = (sy1 === height - 1)? sy1: sy1 + 1;
          dy1 = y - sy1;
          dy2 = 1.0 - dy1;

          p1 = p2 = sy1 * width;
          p3 = p4 = sy2 * width;

          dst[pos ++] = 
            (dy2 * (dx2 * src[p1 + sx1] + dx1 * src[p2 + sx2]) +
             dy1 * (dx2 * src[p3 + sx1] + dx1 * src[p4 + sx2]) ) & 0xff;

        }
      }

      imageDst.width = warpSize;
      imageDst.height = warpSize;

      return imageDst;
    };

    CV.getPerspectiveTransform = function(src, size){
      var rq = CV.square2quad(src);
      
      rq[0] /= size;
      rq[1] /= size;
      rq[3] /= size;
      rq[4] /= size;
      rq[6] /= size;
      rq[7] /= size;
      
      return rq;
    };

    CV.square2quad = function(src){
      var sq = [], px, py, dx1, dx2, dy1, dy2, den;
      
      px = src[0].x - src[1].x + src[2].x - src[3].x;
      py = src[0].y - src[1].y + src[2].y - src[3].y;
      
      if (0 === px && 0 === py){
        sq[0] = src[1].x - src[0].x;
        sq[1] = src[2].x - src[1].x;
        sq[2] = src[0].x;
        sq[3] = src[1].y - src[0].y;
        sq[4] = src[2].y - src[1].y;
        sq[5] = src[0].y;
        sq[6] = 0;
        sq[7] = 0;
        sq[8] = 1;

      }else {
        dx1 = src[1].x - src[2].x;
        dx2 = src[3].x - src[2].x;
        dy1 = src[1].y - src[2].y;
        dy2 = src[3].y - src[2].y;
        den = dx1 * dy2 - dx2 * dy1;
      
        sq[6] = (px * dy2 - dx2 * py) / den;
        sq[7] = (dx1 * py - px * dy1) / den;
        sq[8] = 1;
        sq[0] = src[1].x - src[0].x + sq[6] * src[1].x;
        sq[1] = src[3].x - src[0].x + sq[7] * src[3].x;
        sq[2] = src[0].x;
        sq[3] = src[1].y - src[0].y + sq[6] * src[1].y;
        sq[4] = src[3].y - src[0].y + sq[7] * src[3].y;
        sq[5] = src[0].y;
      }

      return sq;
    };

    CV.isContourConvex = function(contour){
      var orientation = 0, convex = true,
          len = contour.length, i = 0, j = 0,
          cur_pt, prev_pt, dxdy0, dydx0, dx0, dy0, dx, dy;

      prev_pt = contour[len - 1];
      cur_pt = contour[0];

      dx0 = cur_pt.x - prev_pt.x;
      dy0 = cur_pt.y - prev_pt.y;

      for (; i < len; ++ i){
        if (++ j === len) {j = 0;}

        prev_pt = cur_pt;
        cur_pt = contour[j];

        dx = cur_pt.x - prev_pt.x;
        dy = cur_pt.y - prev_pt.y;
        dxdy0 = dx * dy0;
        dydx0 = dy * dx0;

        orientation |= dydx0 > dxdy0? 1: (dydx0 < dxdy0? 2: 3);

        if (3 === orientation){
            convex = false;
            break;
        }

        dx0 = dx;
        dy0 = dy;
      }

      return convex;
    };

    CV.perimeter = function(poly){
      var len = poly.length, i = 0, j = len - 1,
          p = 0.0, dx, dy;

      for (; i < len; j = i ++){
        dx = poly[i].x - poly[j].x;
        dy = poly[i].y - poly[j].y;
        
        p += Math.sqrt(dx * dx + dy * dy) ;
      }

      return p;
    };

    CV.minEdgeLength = function(poly){
      var len = poly.length, i = 0, j = len - 1, 
          min = Infinity, d, dx, dy;

      for (; i < len; j = i ++){
        dx = poly[i].x - poly[j].x;
        dy = poly[i].y - poly[j].y;

        d = dx * dx + dy * dy;

        if (d < min){
          min = d;
        }
      }
      
      return Math.sqrt(min);
    };

    CV.countNonZero = function(imageSrc, square){
      var src = imageSrc.data, height = square.height, width = square.width,
          pos = square.x + (square.y * imageSrc.width),
          span = imageSrc.width - width,
          nz = 0, i, j;
      
      for (i = 0; i < height; ++ i){

        for (j = 0; j < width; ++ j){
        
          if ( 0 !== src[pos ++] ){
            ++ nz;
          }
        }
        
        pos += span;
      }

      return nz;
    };

    CV.binaryBorder = function(imageSrc, dst){
      var src = imageSrc.data, height = imageSrc.height, width = imageSrc.width,
          posSrc = 0, posDst = 0, i, j;

      for (j = -2; j < width; ++ j){
        dst[posDst ++] = 0;
      }

      for (i = 0; i < height; ++ i){
        dst[posDst ++] = 0;
        
        for (j = 0; j < width; ++ j){
          dst[posDst ++] = (0 === src[posSrc ++]? 0: 1);
        }
        
        dst[posDst ++] = 0;
      }

      for (j = -2; j < width; ++ j){
        dst[posDst ++] = 0;
      }
      
      return dst;
    };

    var cv = CV;

    /*
    Copyright (c) 2011 Juan Mellado

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    */

    /*
    References:
    - "ArUco: a minimal library for Augmented Reality applications based on OpenCv"
      http://www.uco.es/investiga/grupos/ava/node/26
    */



    var AR = AR || {};

    AR.Marker = function(id, corners){
      this.id = id;
      this.corners = corners;
    };

    AR.Detector = function(){
      this.grey = new cv.Image();
      this.thres = new cv.Image();
      this.homography = new cv.Image();
      this.binary = [];
      this.contours = [];
      this.polys = [];
      this.candidates = [];
    };

    AR.Detector.prototype.detect = function(image){
      cv.grayscale(image, this.grey);
      cv.adaptiveThreshold(this.grey, this.thres, 2, 7);
      
      this.contours = cv.findContours(this.thres, this.binary);

      this.candidates = this.findCandidates(this.contours, image.width * 0.20, 0.05, 10);
      this.candidates = this.clockwiseCorners(this.candidates);
      this.candidates = this.notTooNear(this.candidates, 10);

      return this.findMarkers(this.grey, this.candidates, 49);
    };

    AR.Detector.prototype.findCandidates = function(contours, minSize, epsilon, minLength){
      var candidates = [], len = contours.length, contour, poly, i;

      this.polys = [];
      
      for (i = 0; i < len; ++ i){
        contour = contours[i];

        if (contour.length >= minSize){
          poly = cv.approxPolyDP(contour, contour.length * epsilon);

          this.polys.push(poly);

          if ( (4 === poly.length) && ( cv.isContourConvex(poly) ) ){

            if ( cv.minEdgeLength(poly) >= minLength){
              candidates.push(poly);
            }
          }
        }
      }

      return candidates;
    };

    AR.Detector.prototype.clockwiseCorners = function(candidates){
      var len = candidates.length, dx1, dx2, dy1, dy2, swap, i;

      for (i = 0; i < len; ++ i){
        dx1 = candidates[i][1].x - candidates[i][0].x;
        dy1 = candidates[i][1].y - candidates[i][0].y;
        dx2 = candidates[i][2].x - candidates[i][0].x;
        dy2 = candidates[i][2].y - candidates[i][0].y;

        if ( (dx1 * dy2 - dy1 * dx2) < 0){
          swap = candidates[i][1];
          candidates[i][1] = candidates[i][3];
          candidates[i][3] = swap;
        }
      }

      return candidates;
    };

    AR.Detector.prototype.notTooNear = function(candidates, minDist){
      var notTooNear = [], len = candidates.length, dist, dx, dy, i, j, k;

      for (i = 0; i < len; ++ i){
      
        for (j = i + 1; j < len; ++ j){
          dist = 0;
          
          for (k = 0; k < 4; ++ k){
            dx = candidates[i][k].x - candidates[j][k].x;
            dy = candidates[i][k].y - candidates[j][k].y;
          
            dist += dx * dx + dy * dy;
          }
          
          if ( (dist / 4) < (minDist * minDist) ){
          
            if ( cv.perimeter( candidates[i] ) < cv.perimeter( candidates[j] ) ){
              candidates[i].tooNear = true;
            }else {
              candidates[j].tooNear = true;
            }
          }
        }
      }

      for (i = 0; i < len; ++ i){
        if ( !candidates[i].tooNear ){
          notTooNear.push( candidates[i] );
        }
      }

      return notTooNear;
    };

    AR.Detector.prototype.findMarkers = function(imageSrc, candidates, warpSize){
      var markers = [], len = candidates.length, candidate, marker, i;

      for (i = 0; i < len; ++ i){
        candidate = candidates[i];

        cv.warp(imageSrc, this.homography, candidate, warpSize);
      
        cv.threshold(this.homography, this.homography, cv.otsu(this.homography) );

        marker = this.getMarker(this.homography, candidate);
        if (marker){
          markers.push(marker);
        }
      }
      
      return markers;
    };

    AR.Detector.prototype.getMarker = function(imageSrc, candidate){
      var width = (imageSrc.width / 7) >>> 0,
          minZero = (width * width) >> 1,
          bits = [], rotations = [], distances = [],
          square, pair, inc, i, j;

      for (i = 0; i < 7; ++ i){
        inc = (0 === i || 6 === i)? 1: 6;
        
        for (j = 0; j < 7; j += inc){
          square = {x: j * width, y: i * width, width: width, height: width};
          if ( cv.countNonZero(imageSrc, square) > minZero){
            return null;
          }
        }
      }

      for (i = 0; i < 5; ++ i){
        bits[i] = [];

        for (j = 0; j < 5; ++ j){
          square = {x: (j + 1) * width, y: (i + 1) * width, width: width, height: width};
          
          bits[i][j] = cv.countNonZero(imageSrc, square) > minZero? 1: 0;
        }
      }

      rotations[0] = bits;
      distances[0] = this.hammingDistance( rotations[0] );
      
      pair = {first: distances[0], second: 0};
      
      for (i = 1; i < 4; ++ i){
        rotations[i] = this.rotate( rotations[i - 1] );
        distances[i] = this.hammingDistance( rotations[i] );
        
        if (distances[i] < pair.first){
          pair.first = distances[i];
          pair.second = i;
        }
      }

      if (0 !== pair.first){
        return null;
      }

      return new AR.Marker(
        this.mat2id( rotations[pair.second] ), 
        this.rotate2(candidate, 4 - pair.second) );
    };

    AR.Detector.prototype.hammingDistance = function(bits){
      var ids = [ [1,0,0,0,0], [1,0,1,1,1], [0,1,0,0,1], [0,1,1,1,0] ],
          dist = 0, sum, minSum, i, j, k;

      for (i = 0; i < 5; ++ i){
        minSum = Infinity;
        
        for (j = 0; j < 4; ++ j){
          sum = 0;

          for (k = 0; k < 5; ++ k){
              sum += bits[i][k] === ids[j][k]? 0: 1;
          }

          if (sum < minSum){
            minSum = sum;
          }
        }

        dist += minSum;
      }

      return dist;
    };

    AR.Detector.prototype.mat2id = function(bits){
      var id = 0, i;
      
      for (i = 0; i < 5; ++ i){
        id <<= 1;
        id |= bits[i][1];
        id <<= 1;
        id |= bits[i][3];
      }

      return id;
    };

    AR.Detector.prototype.rotate = function(src){
      var dst = [], len = src.length, i, j;
      
      for (i = 0; i < len; ++ i){
        dst[i] = [];
        for (j = 0; j < src[i].length; ++ j){
          dst[i][j] = src[src[i].length - j - 1][i];
        }
      }

      return dst;
    };

    AR.Detector.prototype.rotate2 = function(src, rotation){
      var dst = [], len = src.length, i;
      
      for (i = 0; i < len; ++ i){
        dst[i] = src[ (rotation + i) % len ];
      }

      return dst;
    };

    var aruco = AR;

    /*
    Copyright (c) 2012 Juan Mellado

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    */

    /*
    References:
    - "Numerical Recipes in C - Second Edition"
      http://www.nr.com/
    */

    var SVD = SVD || {};

    SVD.svdcmp = function(a, m, n, w, v){
      var flag, i, its, j, jj, k, l, nm,
          anorm = 0.0, c, f, g = 0.0, h, s, scale = 0.0, x, y, z, rv1 = [];
          
      //Householder reduction to bidiagonal form
      for (i = 0; i < n; ++ i){
        l = i + 1;
        rv1[i] = scale * g;
        g = s = scale = 0.0;
        if (i < m){
          for (k = i; k < m; ++ k){
            scale += Math.abs( a[k][i] );
          }
          if (0.0 !== scale){
            for (k = i; k < m; ++ k){
              a[k][i] /= scale;
              s += a[k][i] * a[k][i];
            }
            f = a[i][i];
            g = -SVD.sign( Math.sqrt(s), f );
            h = f * g - s;
            a[i][i] = f - g;
            for (j = l; j < n; ++ j){
              for (s = 0.0, k = i; k < m; ++ k){
                s += a[k][i] * a[k][j];
              }
              f = s / h;
              for (k = i; k < m; ++ k){
                a[k][j] += f * a[k][i];
              }
            }
            for (k = i; k < m; ++ k){
              a[k][i] *= scale;
            }
          }
        }
        w[i] = scale * g;
        g = s = scale = 0.0;
        if ( (i < m) && (i !== n - 1) ){
          for (k = l; k < n; ++ k){
            scale += Math.abs( a[i][k] );
          }
          if (0.0 !== scale){
            for (k = l; k < n; ++ k){
              a[i][k] /= scale;
              s += a[i][k] * a[i][k];
            }
            f = a[i][l];
            g = -SVD.sign( Math.sqrt(s), f );
            h = f * g - s;
            a[i][l] = f - g;
            for (k = l; k < n; ++ k){
              rv1[k] = a[i][k] / h;
            }
            for (j = l; j < m; ++ j){
              for (s = 0.0, k = l; k < n; ++ k){
                s += a[j][k] * a[i][k];
              }
              for (k = l; k < n; ++ k){
                a[j][k] += s * rv1[k];
              }
            }
            for (k = l; k < n; ++ k){
              a[i][k] *= scale;
            }
          }
        }
        anorm = Math.max(anorm, ( Math.abs( w[i] ) + Math.abs( rv1[i] ) ) );
      }

      //Acumulation of right-hand transformation
      for (i = n - 1; i >= 0; -- i){
        if (i < n - 1){
          if (0.0 !== g){
            for (j = l; j < n; ++ j){
              v[j][i] = ( a[i][j] / a[i][l] ) / g;
            }
            for (j = l; j < n; ++ j){
              for (s = 0.0, k = l; k < n; ++ k){
                s += a[i][k] * v[k][j];
              }
              for (k = l; k < n; ++ k){
                v[k][j] += s * v[k][i];
              }
            }
          }
          for (j = l; j < n; ++ j){
            v[i][j] = v[j][i] = 0.0;
          }
        }
        v[i][i] = 1.0;
        g = rv1[i];
        l = i;
      }

      //Acumulation of left-hand transformation
      for (i = Math.min(n, m) - 1; i >= 0; -- i){
        l = i + 1;
        g = w[i];
        for (j = l; j < n; ++ j){
          a[i][j] = 0.0;
        }
        if (0.0 !== g){
          g = 1.0 / g;
          for (j = l; j < n; ++ j){
            for (s = 0.0, k = l; k < m; ++ k){
              s += a[k][i] * a[k][j];
            }
            f = (s / a[i][i]) * g;
            for (k = i; k < m; ++ k){
              a[k][j] += f * a[k][i];
            }
          }
          for (j = i; j < m; ++ j){
            a[j][i] *= g;
          }
        }else {
            for (j = i; j < m; ++ j){
              a[j][i] = 0.0;
            }
        }
        ++ a[i][i];
      }

      //Diagonalization of the bidiagonal form
      for (k = n - 1; k >= 0; -- k){
        for (its = 1; its <= 30; ++ its){
          flag = true;
          for (l = k; l >= 0; -- l){
            nm = l - 1;
            if ( Math.abs( rv1[l] ) + anorm === anorm ){
              flag = false;
              break;
            }
            if ( Math.abs( w[nm] ) + anorm === anorm ){
              break;
            }
          }
          if (flag){
            c = 0.0;
            s = 1.0;
            for (i = l; i <= k; ++ i){
              f = s * rv1[i];
              if ( Math.abs(f) + anorm === anorm ){
                break;
              }
              g = w[i];
              h = SVD.pythag(f, g);
              w[i] = h;
              h = 1.0 / h;
              c = g * h;
              s = -f * h;
              for (j = 1; j <= m; ++ j){
                y = a[j][nm];
                z = a[j][i];
                a[j][nm] = y * c + z * s;
                a[j][i] = z * c - y * s;
              }
            }
          }

          //Convergence
          z = w[k];
          if (l === k){
            if (z < 0.0){
              w[k] = -z;
              for (j = 0; j < n; ++ j){
                v[j][k] = -v[j][k];
              }
            }
            break;
          }

          if (30 === its){
            return false;
          }

          //Shift from bottom 2-by-2 minor
          x = w[l];
          nm = k - 1;
          y = w[nm];
          g = rv1[nm];
          h = rv1[k];
          f = ( (y - z) * (y + z) + (g - h) * (g + h) ) / (2.0 * h * y);
          g = SVD.pythag( f, 1.0 );
          f = ( (x - z) * (x + z) + h * ( (y / (f + SVD.sign(g, f) ) ) - h) ) / x;

          //Next QR transformation
          c = s = 1.0;
          for (j = l; j <= nm; ++ j){
            i = j + 1;
            g = rv1[i];
            y = w[i];
            h = s * g;
            g = c * g;
            z = SVD.pythag(f, h);
            rv1[j] = z;
            c = f / z;
            s = h / z;
            f = x * c + g * s;
            g = g * c - x * s;
            h = y * s;
            y *= c;
            for (jj = 0; jj < n; ++ jj){
              x = v[jj][j];
              z = v[jj][i];
              v[jj][j] = x * c + z * s;
              v[jj][i] = z * c - x * s;
            }
            z = SVD.pythag(f, h);
            w[j] = z;
            if (0.0 !== z){
              z = 1.0 / z;
              c = f * z;
              s = h * z;
            }
            f = c * g + s * y;
            x = c * y - s * g;
            for (jj = 0; jj < m; ++ jj){
              y = a[jj][j];
              z = a[jj][i];
              a[jj][j] = y * c + z * s;
              a[jj][i] = z * c - y * s;
            }
          }
          rv1[l] = 0.0;
          rv1[k] = f;
          w[k] = x;
        }
      }

      return true;
    };

    SVD.pythag = function(a, b){
      var at = Math.abs(a), bt = Math.abs(b), ct;

      if (at > bt){
        ct = bt / at;
        return at * Math.sqrt(1.0 + ct * ct);
      }
        
      if (0.0 === bt){
        return 0.0;
      }

      ct = at / bt;
      return bt * Math.sqrt(1.0 + ct * ct);
    };

    SVD.sign = function(a, b){
      return b >= 0.0? Math.abs(a): -Math.abs(a);
    };

    var svd = SVD;

    /*
    Copyright (c) 2012 Juan Mellado

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    */

    /*
    References:
    - "Iterative Pose Estimation using Coplanar Feature Points"
      Denis Oberkampf, Daniel F. DeMenthon, Larry S. Davis
      http://www.cfar.umd.edu/~daniel/daniel_papersfordownload/CoplanarPts.pdf
    */



    var POS$1 = POS$1 || {};

    POS$1.Posit = function(modelSize, focalLength){
      this.objectPoints = this.buildModel(modelSize);
      this.focalLength = focalLength;

      this.objectVectors = [];
      this.objectNormal = [];
      this.objectMatrix = [[],[],[]];
      
      this.init();
    };

    POS$1.Posit.prototype.buildModel = function(modelSize){
      var half = modelSize / 2.0;
      
      return [
        [-half,  half, 0.0],
        [ half,  half, 0.0],
        [ half, -half, 0.0],
        [-half, -half, 0.0] ];
    };

    POS$1.Posit.prototype.init = function(){
      var np = this.objectPoints.length,
          vectors = [], n = [], len = 0.0, row = 2, i;
      
      for (i = 0; i < np; ++ i){
        this.objectVectors[i] = [this.objectPoints[i][0] - this.objectPoints[0][0],
                                 this.objectPoints[i][1] - this.objectPoints[0][1],
                                 this.objectPoints[i][2] - this.objectPoints[0][2]];
                                 
        vectors[i] = [this.objectVectors[i][0],
                      this.objectVectors[i][1],
                      this.objectVectors[i][2]];
      }

      while(0.0 === len){
        n[0] = this.objectVectors[1][1] * this.objectVectors[row][2] -
               this.objectVectors[1][2] * this.objectVectors[row][1];
        n[1] = this.objectVectors[1][2] * this.objectVectors[row][0] -
               this.objectVectors[1][0] * this.objectVectors[row][2];
        n[2] = this.objectVectors[1][0] * this.objectVectors[row][1] -
               this.objectVectors[1][1] * this.objectVectors[row][0];
        
        len = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
        
        ++ row;
      }

      for (i = 0; i < 3; ++ i){
        this.objectNormal[i] = n[i] / len;
      }

      POS$1.pseudoInverse(vectors, np, this.objectMatrix);
    };

    POS$1.Posit.prototype.pose = function(imagePoints){
      var posRotation1 = [[],[],[]], posRotation2 = [[],[],[]], posTranslation = [],
          rotation1 = [[],[],[]], rotation2 = [[],[],[]], translation1 = [], translation2 = [],
          error1, error2, valid1, valid2, i, j;

      this.pos(imagePoints, posRotation1, posRotation2, posTranslation);

      valid1 = this.isValid(posRotation1, posTranslation);
      if (valid1){
        error1 = this.iterate(imagePoints, posRotation1, posTranslation, rotation1, translation1);
      }else {
        error1 = {euclidean: -1.0, pixels: -1, maximum: -1.0};
      }
      
      valid2 = this.isValid(posRotation2, posTranslation);
      if (valid2){
        error2 = this.iterate(imagePoints, posRotation2, posTranslation, rotation2, translation2);
      }else {
        error2 = {euclidean: -1.0, pixels: -1, maximum: -1.0};
      }

      for (i = 0; i < 3; ++ i){
        for (j = 0; j < 3; ++ j){
          if (valid1){
            translation1[i] -= rotation1[i][j] * this.objectPoints[0][j];
          }
          if (valid2){
            translation2[i] -= rotation2[i][j] * this.objectPoints[0][j];
          }
        }
      }

      return error1.euclidean < error2.euclidean?
        new POS$1.Pose(error1.pixels, rotation1, translation1, error2.pixels, rotation2, translation2):
        new POS$1.Pose(error2.pixels, rotation2, translation2, error1.pixels, rotation1, translation1);
    };

    POS$1.Posit.prototype.pos = function(imagePoints, rotation1, rotation2, translation){
      var np = this.objectPoints.length, imageVectors = [],
          i0 = [], j0 = [], ivec = [], jvec = [], row1 = [], row2 = [], row3 = [],
          i0i0, j0j0, i0j0, delta, q, lambda, mu, scale, i, j;

      for (i = 0; i < np; ++ i){
        imageVectors[i] = [imagePoints[i].x - imagePoints[0].x,
                           imagePoints[i].y - imagePoints[0].y];
      }

      //i0 and j0
      for (i = 0; i < 3; ++ i){
        i0[i] = 0.0;
        j0[i] = 0.0;
        for (j = 0; j < np; ++ j){
          i0[i] += this.objectMatrix[i][j] * imageVectors[j][0];
          j0[i] += this.objectMatrix[i][j] * imageVectors[j][1];
        }
      }

      i0i0 = i0[0] * i0[0] + i0[1] * i0[1] + i0[2] * i0[2];
      j0j0 = j0[0] * j0[0] + j0[1] * j0[1] + j0[2] * j0[2];
      i0j0 = i0[0] * j0[0] + i0[1] * j0[1] + i0[2] * j0[2];

      //Lambda and mu
      delta = (j0j0 - i0i0) * (j0j0 - i0i0) + 4.0 * (i0j0 * i0j0);
      
      if (j0j0 - i0i0 >= 0.0){
        q = (j0j0 - i0i0 + Math.sqrt(delta) ) / 2.0;
      }else {
        q = (j0j0 - i0i0 - Math.sqrt(delta) ) / 2.0;
      }
      
      if (q >= 0.0){
        lambda = Math.sqrt(q);
        if (0.0 === lambda){
          mu = 0.0;
        }else {
          mu = -i0j0 / lambda;
        }
      }else {
        lambda = Math.sqrt( -(i0j0 * i0j0) / q);
        if (0.0 === lambda){
          mu = Math.sqrt(i0i0 - j0j0);
        }else {
          mu = -i0j0 / lambda;
        }
      }

      //First rotation
      for (i = 0; i < 3; ++ i){
        ivec[i] = i0[i] + lambda * this.objectNormal[i];
        jvec[i] = j0[i] + mu * this.objectNormal[i];
      }
      
      scale = Math.sqrt(ivec[0] * ivec[0] + ivec[1] * ivec[1] + ivec[2] * ivec[2]);
      
      for (i = 0; i < 3; ++ i){
        row1[i] = ivec[i] / scale;
        row2[i] = jvec[i] / scale;
      }
      
      row3[0] = row1[1] * row2[2] - row1[2] * row2[1];
      row3[1] = row1[2] * row2[0] - row1[0] * row2[2];
      row3[2] = row1[0] * row2[1] - row1[1] * row2[0];

      for (i = 0; i < 3; ++ i){
        rotation1[0][i] = row1[i];
        rotation1[1][i] = row2[i];
        rotation1[2][i] = row3[i];
      }

      //Second rotation
      for (i = 0; i < 3; ++ i){
        ivec[i] = i0[i] - lambda * this.objectNormal[i];
        jvec[i] = j0[i] - mu * this.objectNormal[i];
      }
      
      for (i = 0; i < 3; ++ i){
        row1[i] = ivec[i] / scale;
        row2[i] = jvec[i] / scale;
      }
      
      row3[0] = row1[1] * row2[2] - row1[2] * row2[1];
      row3[1] = row1[2] * row2[0] - row1[0] * row2[2];
      row3[2] = row1[0] * row2[1] - row1[1] * row2[0];
      
      for (i = 0; i < 3; ++ i){
        rotation2[0][i] = row1[i];
        rotation2[1][i] = row2[i];
        rotation2[2][i] = row3[i];
      }

      //Translation
      translation[0] = imagePoints[0].x / scale;
      translation[1] = imagePoints[0].y / scale;
      translation[2] = this.focalLength / scale;
    };

    POS$1.Posit.prototype.isValid = function(rotation, translation){
      var np = this.objectPoints.length, zmin = Infinity, i = 0, zi;

      for (; i < np; ++ i){
        zi = translation[2] +
          (rotation[2][0] * this.objectVectors[i][0] +
           rotation[2][1] * this.objectVectors[i][1] +
           rotation[2][2] * this.objectVectors[i][2]);
        if (zi < zmin){
          zmin = zi;
        }
      }

      return zmin >= 0.0;
    };

    POS$1.Posit.prototype.iterate = function(imagePoints, posRotation, posTranslation, rotation, translation){
      var np = this.objectPoints.length,
          oldSopImagePoints = [], sopImagePoints = [],
          rotation1 = [[],[],[]], rotation2 = [[],[],[]],
          translation1 = [], translation2 = [],
          converged = false, iteration = 0,
          oldImageDifference, imageDifference, factor,
          error, error1, error2, delta, i, j;

      for (i = 0; i < np; ++ i){
        oldSopImagePoints[i] = {x: imagePoints[i].x,
                                y: imagePoints[i].y};
      }
      
      for (i = 0; i < 3; ++ i){
        for (j = 0; j < 3; ++ j){
          rotation[i][j] = posRotation[i][j];
        }
        translation[i] = posTranslation[i];
      }

      for (i = 0; i < np; ++ i){
        factor = 0.0;
        for (j = 0; j < 3; ++ j){
          factor += this.objectVectors[i][j] * rotation[2][j] / translation[2];
        }
        sopImagePoints[i] = {x: (1.0 + factor) * imagePoints[i].x,
                             y: (1.0 + factor) * imagePoints[i].y};
      }

      imageDifference = 0.0;
      
      for (i = 0; i < np; ++ i){
        imageDifference += Math.abs(sopImagePoints[i].x - oldSopImagePoints[i].x);
        imageDifference += Math.abs(sopImagePoints[i].y - oldSopImagePoints[i].y);
      }

      for (i = 0; i < 3; ++ i){
        translation1[i] = translation[i] -
          (rotation[i][0] * this.objectPoints[0][0] +
           rotation[i][1] * this.objectPoints[0][1] +
           rotation[i][2] * this.objectPoints[0][2]);
      }
      
      error = error1 = this.error(imagePoints, rotation, translation1);

      //Convergence
      converged = (0.0 === error1.pixels) || (imageDifference < 0.01);
      
      while( iteration ++ < 100 && !converged ){
      
        for (i = 0; i < np; ++ i){
          oldSopImagePoints[i].x = sopImagePoints[i].x;
          oldSopImagePoints[i].y = sopImagePoints[i].y;
        }

        this.pos(sopImagePoints, rotation1, rotation2, translation);

        for (i = 0; i < 3; ++ i){
          translation1[i] = translation[i] -
            (rotation1[i][0] * this.objectPoints[0][0] +
             rotation1[i][1] * this.objectPoints[0][1] +
             rotation1[i][2] * this.objectPoints[0][2]);
            
          translation2[i] = translation[i] -
            (rotation2[i][0] * this.objectPoints[0][0] +
             rotation2[i][1] * this.objectPoints[0][1] +
             rotation2[i][2] * this.objectPoints[0][2]);
        }

        error1 = this.error(imagePoints, rotation1, translation1);
        error2 = this.error(imagePoints, rotation2, translation2);

        if ( (error1.euclidean >= 0.0) && (error2.euclidean >= 0.0) ){
          if (error2.euclidean < error1.euclidean){
            error = error2;
            for (i = 0; i < 3; ++ i){
              for (j = 0; j < 3; ++ j){
                rotation[i][j] = rotation2[i][j];
              }
            }
          }else {
            error = error1;
            for (i = 0; i < 3; ++ i){
              for (j = 0; j < 3; ++ j){
                rotation[i][j] = rotation1[i][j];
              }
            }
          }
        }

        if ( (error1.euclidean < 0.0) && (error2.euclidean >= 0.0) ){
          error = error2;
          for (i = 0; i < 3; ++ i){
            for (j = 0; j < 3; ++ j){
              rotation[i][j] = rotation2[i][j];
            }
          }
        }
        
        if ( (error2.euclidean < 0.0) && (error1.euclidean >= 0.0) ){
          error = error1;
          for (i = 0; i < 3; ++ i){
            for (j = 0; j < 3; ++ j){
              rotation[i][j] = rotation1[i][j];
            }
          }
        }

        for (i = 0; i < np; ++ i){
          factor = 0.0;
          for (j = 0; j < 3; ++ j){
            factor += this.objectVectors[i][j] * rotation[2][j] / translation[2];
          }
          sopImagePoints[i].x = (1.0 + factor) * imagePoints[i].x;
          sopImagePoints[i].y = (1.0 + factor) * imagePoints[i].y;
        }

        oldImageDifference = imageDifference;
        imageDifference = 0.0;
        
        for (i = 0; i < np; ++ i){
          imageDifference += Math.abs(sopImagePoints[i].x - oldSopImagePoints[i].x);
          imageDifference += Math.abs(sopImagePoints[i].y - oldSopImagePoints[i].y);
        }

        delta = Math.abs(imageDifference - oldImageDifference);

        converged = (0.0 === error.pixels) || (delta < 0.01);
      }
      
      return error;
    };

    POS$1.Posit.prototype.error = function(imagePoints, rotation, translation){
      var np = this.objectPoints.length,
          move = [], projection = [], errorvec = [],
          euclidean = 0.0, pixels = 0.0, maximum = 0.0,
          i, j, k;

      if ( !this.isValid(rotation, translation) ){
        return {euclidean: -1.0, pixels: -1, maximum: -1.0};
      }
      
      for (i = 0; i < np; ++ i){
        move[i] = [];
        for (j = 0; j < 3; ++ j){
          move[i][j] = translation[j];
        }
      }
      
      for (i = 0; i < np; ++ i){
        for (j = 0; j < 3; ++ j){
          for (k = 0; k < 3; ++ k){
            move[i][j] += rotation[j][k] * this.objectPoints[i][k];
          }
        }
      }

      for (i = 0; i < np; ++ i){
        projection[i] = [];
        for (j = 0; j < 2; ++ j){
          projection[i][j] = this.focalLength * move[i][j] / move[i][2];
        }
      }
      
      for (i = 0; i < np; ++ i){
        errorvec[i] = [projection[i][0] - imagePoints[i].x,
                       projection[i][1] - imagePoints[i].y];
      }

      for (i = 0; i < np; ++ i){
        euclidean += Math.sqrt(errorvec[i][0] * errorvec[i][0] +
                               errorvec[i][1] * errorvec[i][1]);
                           
        pixels += Math.abs( Math.round(projection[i][0]) - Math.round(imagePoints[i].x) ) +
                  Math.abs( Math.round(projection[i][1]) - Math.round(imagePoints[i].y) );
                  
        if (Math.abs(errorvec[i][0]) > maximum){
          maximum = Math.abs(errorvec[i][0]);
        }
        if (Math.abs(errorvec[i][1]) > maximum){
          maximum = Math.abs(errorvec[i][1]);
        }
      }

      return {euclidean: euclidean / np, pixels: pixels, maximum: maximum};
    };

    POS$1.pseudoInverse = function(a, n, b){
      var w = [], v = [[],[],[]], s = [[],[],[]],
          wmax = 0.0, cn = 0,
          i, j, k;

      svd.svdcmp(a, n, 3, w, v);

      for (i = 0; i < 3; ++ i){
        if (w[i] > wmax){
          wmax = w[i];
        }
      }

      wmax *= 0.01;

      for (i = 0; i < 3; ++ i){
        if (w[i] < wmax){
          w[i] = 0.0;
        }
      }

      for (j = 0; j < 3; ++ j){
        if (0.0 === w[j]){
          ++ cn;
          for (k = j; k < 2; ++ k){
            for (i = 0; i < n; ++ i){
              a[i][k] = a[i][k + 1];
            }
            for (i = 0; i < 3; ++ i){
              v[i][k] = v[i][k + 1];
            }
          }
        }
      }

      for (j = 0; j < 2; ++ j){
        if (0.0 === w[j]){
          w[j] = w[j + 1];
        }
      }

      for (i = 0; i < 3; ++ i){
        for (j = 0; j < 3 - cn; ++ j){
          s[i][j] = v[i][j] / w[j];
        }
      }
      
      for (i = 0; i < 3; ++ i){
        for (j = 0; j < n; ++ j){
          b[i][j] = 0.0;
          for (k = 0; k < 3 - cn; ++ k){
            b[i][j] += s[i][k] * a[j][k];
          }
        }
      }
    };

    POS$1.Pose = function(error1, rotation1, translation1, error2, rotation2, translation2){
      this.bestError = error1;
      this.bestRotation = rotation1;
      this.bestTranslation = translation1;
      this.alternativeError = error2;
      this.alternativeRotation = rotation2;
      this.alternativeTranslation = translation2;
    };

    var posit1 = POS$1;

    /*
    Copyright (c) 2012 Juan Mellado

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    THE SOFTWARE.
    */

    /*
    References:
    - "3D Pose Estimation"
      Andrew Kirillow
      http://www.aforgenet.com/articles/posit/
    */



    var POS = POS || {};

    POS.Posit = function(modelSize, focalLength){
      this.model = this.buildModel(modelSize);
      this.focalLength = focalLength;

      this.init();
    };

    POS.Posit.prototype.buildModel = function(modelSize){
      var half = modelSize / 2.0;
      
      return [
        new Vec3(-half,  half, 0.0),
        new Vec3( half,  half, 0.0),
        new Vec3( half, -half, 0.0),
        new Vec3(-half, -half, 0.0) ];
    };

    POS.Posit.prototype.init = function(){
      var d = new Vec3(), v = new Mat3(), u;
      
      this.modelVectors = Mat3.fromRows(
          Vec3.sub(this.model[1], this.model[0]),
          Vec3.sub(this.model[2], this.model[0]),
          Vec3.sub(this.model[3], this.model[0]) );

      u = Mat3.clone(this.modelVectors);

      svd.svdcmp(u.m, 3, 3, d.v, v.m);

      this.modelPseudoInverse = Mat3.mult(
        Mat3.mult(v, Mat3.fromDiagonal( Vec3.inverse(d) ) ), Mat3.transpose(u) );
      
      this.modelNormal = v.column( d.minIndex() );
    };

    POS.Posit.prototype.pose = function(points){
      var eps = new Vec3(1.0, 1.0, 1.0),
          rotation1 = new Mat3(), rotation2 = new Mat3(),
          translation1 = new Vec3(), translation2 = new Vec3(),
          error1, error2;

      this.pos(points, eps, rotation1, rotation2, translation1, translation2);

      error1 = this.iterate(points, rotation1, translation1);
      error2 = this.iterate(points, rotation2, translation2);

      return error1 < error2?
        new POS.Pose(error1, rotation1.m, translation1.v, error2, rotation2.m, translation2.v):
        new POS.Pose(error2, rotation2.m, translation2.v, error1, rotation1.m, translation1.v);
    };

    POS.Posit.prototype.pos = function(points, eps, rotation1, rotation2, translation1, translation2){
      var xi = new Vec3(points[1].x, points[2].x, points[3].x),
          yi = new Vec3(points[1].y, points[2].y, points[3].y),
          xs = Vec3.addScalar( Vec3.mult(xi, eps), -points[0].x),
          ys = Vec3.addScalar( Vec3.mult(yi, eps), -points[0].y),
          i0 = Mat3.multVector(this.modelPseudoInverse, xs),
          j0 = Mat3.multVector(this.modelPseudoInverse, ys),
          s = j0.square() - i0.square(),
          ij = Vec3.dot(i0, j0),
          r = 0.0, theta = 0.0,
          i, j, k, inorm, jnorm, scale, temp, lambda, mu;

      if (0.0 === s){
        r = Math.sqrt( Math.abs(2.0 * ij) );
        theta = (-Math.PI / 2.0) * (ij < 0.0? -1: (ij > 0.0? 1.0: 0.0) );
      }else {
        r = Math.sqrt( Math.sqrt(s * s + 4.0 * ij * ij) );
        theta = Math.atan(-2.0 * ij / s);
        if (s < 0.0){
          theta += Math.PI;
        }
        theta /= 2.0;
      }

      lambda = r * Math.cos(theta);
      mu = r * Math.sin(theta);

      //First possible rotation/translation
      i = Vec3.add(i0, Vec3.multScalar(this.modelNormal, lambda) );
      j = Vec3.add(j0, Vec3.multScalar(this.modelNormal, mu) );
      inorm = i.normalize();
      jnorm = j.normalize();
      k = Vec3.cross(i, j);
      rotation1.copy( Mat3.fromRows(i, j, k) );
      
      scale = (inorm + jnorm) / 2.0;
      temp = Mat3.multVector(rotation1, this.model[0]);
      translation1.v = [
        points[0].x / scale - temp.v[0],
        points[0].y / scale - temp.v[1],
        this.focalLength / scale];

      //Second possible rotation/translation
      i = Vec3.sub(i0, Vec3.multScalar(this.modelNormal, lambda) );
      j = Vec3.sub(j0, Vec3.multScalar(this.modelNormal, mu) );
      inorm = i.normalize();
      jnorm = j.normalize();
      k = Vec3.cross(i, j);
      rotation2.copy( Mat3.fromRows(i, j, k) );
      
      scale = (inorm + jnorm) / 2.0;
      temp = Mat3.multVector(rotation2, this.model[0]);
      translation2.v = [
        points[0].x / scale - temp.v[0],
        points[0].y / scale - temp.v[1],
        this.focalLength / scale];
    };

    POS.Posit.prototype.iterate = function(points, rotation, translation){
      var prevError = Infinity,
          rotation1 = new Mat3(), rotation2 = new Mat3(),
          translation1 = new Vec3(), translation2 = new Vec3(),
          i = 0, eps, error, error1, error2;

      for (; i < 100; ++ i){
        eps = Vec3.addScalar( Vec3.multScalar( 
          Mat3.multVector( this.modelVectors, rotation.row(2) ), 1.0 / translation.v[2]), 1.0);

        this.pos(points, eps, rotation1, rotation2, translation1, translation2);

        error1 = this.getError(points, rotation1, translation1);
        error2 = this.getError(points, rotation2, translation2);

        if (error1 < error2){
          rotation.copy(rotation1);
          translation.copy(translation1);
          error = error1;
        }else {
          rotation.copy(rotation2);
          translation.copy(translation2);
          error = error2;
        }

        if ( (error <= 2.0) || (error > prevError) ){
          break;
        }

        prevError = error;
      }

      return error;
    };

    POS.Posit.prototype.getError = function(points, rotation, translation){
      var v1 = Vec3.add( Mat3.multVector(rotation, this.model[0]), translation),
          v2 = Vec3.add( Mat3.multVector(rotation, this.model[1]), translation),
          v3 = Vec3.add( Mat3.multVector(rotation, this.model[2]), translation),
          v4 = Vec3.add( Mat3.multVector(rotation, this.model[3]), translation),
          modeled, ia1, ia2, ia3, ia4, ma1, ma2, ma3, ma4;
      
      v1 = v1.v; v2 = v2.v; v3 = v3.v; v4 = v4.v;
      
      v1[0] *= this.focalLength / v1[2];
      v1[1] *= this.focalLength / v1[2];
      v2[0] *= this.focalLength / v2[2];
      v2[1] *= this.focalLength / v2[2];
      v3[0] *= this.focalLength / v3[2];
      v3[1] *= this.focalLength / v3[2];
      v4[0] *= this.focalLength / v4[2];
      v4[1] *= this.focalLength / v4[2];
      
      modeled = [
        {x: v1[0], y: v1[1]},
        {x: v2[0], y: v2[1]},
        {x: v3[0], y: v3[1]},
        {x: v4[0], y: v4[1]}
      ];

      ia1 = this.angle( points[0], points[1], points[3] );
      ia2 = this.angle( points[1], points[2], points[0] );
      ia3 = this.angle( points[2], points[3], points[1] );
      ia4 = this.angle( points[3], points[0], points[2] );

      ma1 = this.angle( modeled[0], modeled[1], modeled[3] );
      ma2 = this.angle( modeled[1], modeled[2], modeled[0] );
      ma3 = this.angle( modeled[2], modeled[3], modeled[1] );
      ma4 = this.angle( modeled[3], modeled[0], modeled[2] );

      return ( Math.abs(ia1 - ma1) +
               Math.abs(ia2 - ma2) +
               Math.abs(ia3 - ma3) +
               Math.abs(ia4 - ma4) ) / 4.0;
    };

    POS.Posit.prototype.angle = function(a, b, c){
      var x1 = b.x - a.x, y1 = b.y - a.y,
          x2 = c.x - a.x, y2 = c.y - a.y;
      
      return Math.acos( (x1 * x2 + y1 * y2) / 
        (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2) ) ) * 180.0 / Math.PI;
    };

    POS.Pose = function(error1, rotation1, translation1, error2, rotation2, translation2){
      this.bestError = error1;
      this.bestRotation = rotation1;
      this.bestTranslation = translation1;
      this.alternativeError = error2;
      this.alternativeRotation = rotation2;
      this.alternativeTranslation = translation2;
    };

    var Vec3 = function(x, y, z){
      this.v = [x || 0.0, y || 0.0, z || 0.0];
    };

    Vec3.prototype.copy = function(a){
      var v = this.v;

      a = a.v;

      v[0] = a[0];
      v[1] = a[1];
      v[2] = a[2];

      return this;
    };

    Vec3.add = function(a, b){
      var vector = new Vec3(), v = vector.v;
      
      a = a.v; b = b.v;

      v[0] = a[0] + b[0];
      v[1] = a[1] + b[1];
      v[2] = a[2] + b[2];
      
      return vector;
    };

    Vec3.sub = function(a, b){
      var vector = new Vec3(), v = vector.v;
      
      a = a.v; b = b.v;

      v[0] = a[0] - b[0];
      v[1] = a[1] - b[1];
      v[2] = a[2] - b[2];
      
      return vector;
    };

    Vec3.mult = function(a, b){
      var vector = new Vec3(), v = vector.v;
      
      a = a.v; b = b.v;

      v[0] = a[0] * b[0];
      v[1] = a[1] * b[1];
      v[2] = a[2] * b[2];
      
      return vector;
    };

    Vec3.addScalar = function(a, b){
      var vector = new Vec3(), v = vector.v;
      
      a = a.v;

      v[0] = a[0] + b;
      v[1] = a[1] + b;
      v[2] = a[2] + b;
      
      return vector;
    };

    Vec3.multScalar = function(a, b){
      var vector = new Vec3(), v = vector.v;
      
      a = a.v;

      v[0] = a[0] * b;
      v[1] = a[1] * b;
      v[2] = a[2] * b;
      
      return vector;
    };

    Vec3.dot = function(a, b){
      a = a.v; b = b.v;

      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    };

    Vec3.cross = function(a, b){
      a = a.v; b = b.v;

     return new Vec3(
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]);
    };

    Vec3.prototype.normalize = function(){
      var v = this.v,
          len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
          
      if (len > 0.0){
        v[0] /= len;
        v[1] /= len;
        v[2] /= len;
      }

      return len;
    };

    Vec3.inverse = function(a){
      var vector = new Vec3(), v = vector.v;
      
      a = a.v;
      
      if (a[0] !== 0.0){
        v[0] = 1.0 / a[0];
      }
      if (a[1] !== 0.0){
        v[1] = 1.0 / a[1];
      }
      if (a[2] !== 0.0){
        v[2] = 1.0 / a[2];
      }
      
      return vector;
    };

    Vec3.prototype.square = function(){
      var v = this.v;

      return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
    };

    Vec3.prototype.minIndex = function(){
      var v = this.v;

      return v[0] < v[1]? (v[0] < v[2]? 0: 2): (v[1] < v[2]? 1: 2);
    };

    var Mat3 = function(){
      this.m = [ [0.0, 0.0, 0.0],
                 [0.0, 0.0, 0.0],
                 [0.0, 0.0, 0.0] ];
    };

    Mat3.clone = function(a){
      var matrix = new Mat3(), m = matrix.m;
      
      a = a.m;

      m[0][0] = a[0][0];
      m[0][1] = a[0][1];
      m[0][2] = a[0][2];
      m[1][0] = a[1][0];
      m[1][1] = a[1][1];
      m[1][2] = a[1][2];
      m[2][0] = a[2][0];
      m[2][1] = a[2][1];
      m[2][2] = a[2][2];
      
      return matrix;
    };

    Mat3.prototype.copy = function(a){
      var m = this.m;

      a = a.m;

      m[0][0] = a[0][0];
      m[0][1] = a[0][1];
      m[0][2] = a[0][2];
      m[1][0] = a[1][0];
      m[1][1] = a[1][1];
      m[1][2] = a[1][2];
      m[2][0] = a[2][0];
      m[2][1] = a[2][1];
      m[2][2] = a[2][2];

      return this;
    };

    Mat3.fromRows = function(a, b, c){
      var matrix = new Mat3(), m = matrix.m;
      
      a = a.v; b = b.v; c = c.v;
      
      m[0][0] = a[0];
      m[0][1] = a[1];
      m[0][2] = a[2];
      m[1][0] = b[0];
      m[1][1] = b[1];
      m[1][2] = b[2];
      m[2][0] = c[0];
      m[2][1] = c[1];
      m[2][2] = c[2];

      return matrix;
    };

    Mat3.fromDiagonal = function(a){
      var matrix = new Mat3(), m = matrix.m;
      
      a = a.v;
      
      m[0][0] = a[0];
      m[1][1] = a[1];
      m[2][2] = a[2];
      
      return matrix;
    };

    Mat3.transpose = function(a){
      var matrix = new Mat3(), m = matrix.m;
      
      a = a.m;
      
      m[0][0] = a[0][0];
      m[0][1] = a[1][0];
      m[0][2] = a[2][0];
      m[1][0] = a[0][1];
      m[1][1] = a[1][1];
      m[1][2] = a[2][1];
      m[2][0] = a[0][2];
      m[2][1] = a[1][2];
      m[2][2] = a[2][2];
                
      return matrix;
    };

    Mat3.mult = function(a, b){
      var matrix = new Mat3(), m = matrix.m;
      
      a = a.m; b = b.m;

      m[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0];
      m[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1];
      m[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2];
      m[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0];
      m[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1];
      m[1][2] = a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2];
      m[2][0] = a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0];
      m[2][1] = a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1];
      m[2][2] = a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2];

      return matrix;
    };

    Mat3.multVector = function(m, a){
      m = m.m; a = a.v;
      
      return new Vec3(
        m[0][0] * a[0] + m[0][1] * a[1] + m[0][2] * a[2],
        m[1][0] * a[0] + m[1][1] * a[1] + m[1][2] * a[2],
        m[2][0] * a[0] + m[2][1] * a[1] + m[2][2] * a[2]);
    };

    Mat3.prototype.column = function(index){
      var m = this.m;
      
      return new Vec3( m[0][index], m[1][index], m[2][index] );
    };

    Mat3.prototype.row = function(index){
      var m = this.m;
      
      return new Vec3( m[index][0], m[index][1], m[index][2] );
    };

    var posit2 = POS;

    var D__Project_PalMap_HeTunYinLuMerged_palmapMap_node_modules_jsAruco = {
      CV: cv,
      AR: aruco,
      SVD: svd,
      POS1: posit1,
      POS2: posit2
    };

    var InertiaLocationMgr = (function () {
        function InertiaLocationMgr() {
            this.m_velocity = new Vector3(0, 0, 0);
            this.m_accelerate = new Vector3(0, 0, 0);
            this.m_lastVelocityUpdateTime = 0;
            this.m_lastAccelerateUpdateTime = 0;
            this.m_posOffset = new Vector3(0, 0, 0);
            this.m_debugTextCtrl = null;
            this.m_linearTimeStep = 1;
            this.m_lastAcce = new Vector3(0, 0, 0);
        }
        InertiaLocationMgr.GetInstance = function () {
            if (InertiaLocationMgr.m_instance == null || InertiaLocationMgr.m_instance == undefined) {
                InertiaLocationMgr.m_instance = new InertiaLocationMgr();
            }
            return InertiaLocationMgr.m_instance;
        };
        InertiaLocationMgr.prototype.SetDebugTextCtrl = function (ctrl) {
            this.m_debugTextCtrl = ctrl;
        };
        InertiaLocationMgr.prototype.ResetPosOffset = function () {
            this.m_posOffset = new Vector3(0, 0, 0);
        };
        InertiaLocationMgr.prototype.UpdatePosOffset = function () {
            var curTime = Date.now();
            var dt = (curTime - this.m_lastVelocityUpdateTime) / 1000.0;
            this.m_posOffset.x += dt * this.m_velocity.x;
            this.m_posOffset.y += dt * this.m_velocity.y;
            this.m_posOffset.z += dt * this.m_posOffset.z;
        };
        InertiaLocationMgr.prototype.OnAccelerateUpdate = function (acce) {
            var x = acce.x / acce.w;
            var y = acce.y / acce.w;
            var z = acce.z / acce.w;
            var curTime = Date.now();
            var dt = (curTime - this.m_lastAccelerateUpdateTime) / 1000.0;
            for (var i = 0; i < dt; i += this.m_linearTimeStep) {
                var x1 = (x - this.m_lastAcce.x) * this.m_linearTimeStep / dt;
                var y1 = (y - this.m_lastAcce.y) * this.m_linearTimeStep / dt;
                var z1 = (z - this.m_lastAcce.z) * this.m_linearTimeStep / dt;
                this.m_velocity.x += this.m_linearTimeStep * x1;
                this.m_velocity.y += this.m_linearTimeStep * y1;
                this.m_velocity.z += this.m_linearTimeStep * z1;
                this.m_posOffset.x += this.m_linearTimeStep * this.m_velocity.x;
                this.m_posOffset.y += this.m_linearTimeStep * this.m_velocity.y;
                this.m_posOffset.z += this.m_linearTimeStep * this.m_velocity.z;
            }
            this.m_lastVelocityUpdateTime = curTime;
            this.m_lastVelocityUpdateTime = curTime;
            this.m_lastAcce = new Vector3(x, y, z);
        };
        InertiaLocationMgr.prototype.GetInertialOffset = function () {
            return this.m_posOffset;
        };
        InertiaLocationMgr.prototype.OnOrientationUpdate = function (orientation) {
        };
        InertiaLocationMgr.m_instance = null;
        return InertiaLocationMgr;
    }());

    var VideoCamera = (function () {
        function VideoCamera(options) {
            this.m_projectionMatrix = new Matrix4$1();
            this.m_viewMatrix = new Matrix4$1();
            this.m_eulerMatrix = new Matrix4$1();
            this.m_pixelMatrix = new Matrix4$1();
            this.m_pixelInvertMatrix = new Matrix4$1();
            this.m_fov = 84.4;
            this.m_width = 1920;
            this.m_height = 1080;
            this.m_near = 0.044;
            this.m_far = 100000.0;
            this.m_resolutionTable = null;
            this.m_left = 0;
            this.m_right = 0;
            this.m_mid = 0;
            this.m_selectedWidth = 640;
            this.m_selectedHeight = 640;
            this.m_canvasWidth = 480;
            this.m_canvasHeight = 480;
            this.m_bResolutionCheck = true;
            this.m_videoContainer = null;
            this.m_videoCanvas = null;
            this.m_debugTextCtrl = null;
            this.m_qrScanInterval = 0.1;
            this.m_bStartScan = false;
            this.m_qrScanTimePassed = 0;
            this.m_videoStream = null;
            this.m_qrWidth = 0.044;
            this.m_qrWidthFactor = 0.088;
            this.m_faceMode = 1;
            this.m_alpha = 0;
            this.m_beta = 0;
            this.m_gamma = 0;
            this.m_orientationAbsolute = true;
            this.m_screenX = 0;
            this.m_screenY = 0;
            this.m_lookAtDir3 = new Vector3(0, 0, 0);
            this.m_upDir3 = new Vector3(0, 0, 0);
            this.m_deviceStr = '';
            this.m_deviceFullName = '';
            this.m_platform = 1;
            this.m_nearPoint = new Vector3(0, 0, 0);
            this.m_cameraPosServer = 'https://lbsmanage.ipalmap.com/lbs/front/aruco/point?';
            this.m_bdid = '0C3J01';
            this.m_cameraPosJsonObj = null;
            this.m_inertialOffset = new Vector3(0, 0, 0);
            this.m_lastVideoPos = new Vector3(0, 0, 0);
            this.m_lastFloorId = '';
            var Height = options.Height, Width = options.Width, CanvasWidth = options.CanvasWidth, CanvasHeight = options.CanvasHeight;
            if (Height != undefined && Width != undefined) {
                this.m_selectedWidth = Width;
                this.m_selectedHeight = Height;
                this.m_canvasWidth = CanvasWidth;
                this.m_canvasHeight = CanvasHeight;
            }
            VideoCamera.m_instance = this;
            this.InitResolutionCheckTable();
            this.InitCameraPosTable();
        }
        VideoCamera.prototype.InitCameraPosTable = function () {
            return __awaiter(this, void 0, void 0, function () {
                var url, cameraPosJson;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = this.m_cameraPosServer + 'bdid=' + this.m_bdid;
                            return [4, new HttpClient().get(url)];
                        case 1:
                            cameraPosJson = _a.sent();
                            this.m_cameraPosJsonObj = cameraPosJson;
                            return [2];
                    }
                });
            });
        };
        VideoCamera.prototype.Destroy = function () {
        };
        VideoCamera.prototype.SetDebugTextCtrl = function (ctrl) {
            this.m_debugTextCtrl = ctrl;
            InertiaLocationMgr.GetInstance().SetDebugTextCtrl(ctrl);
        };
        VideoCamera.prototype.SetVideoDom = function (dom) {
            this.m_videoContainer = dom;
        };
        VideoCamera.prototype.SetVideoCanvas = function (dom) {
            this.m_videoCanvas = dom;
        };
        VideoCamera.prototype.OnResolutionSuccessCallBack = function () {
            this.m_bResolutionCheck = true;
            this.DoOpenCamera();
        };
        VideoCamera.prototype.FindMaximum_WidthHeight_ForCamera = function () {
            console.log('left:right = ', this.m_left, ':', this.m_right);
            if (this.m_left > this.m_right) {
                console.log('Selected Height:Width = ', this.m_selectedWidth, ':', this.m_selectedHeight);
                this.OnResolutionSuccessCallBack();
                return;
            }
            this.m_mid = Math.floor((this.m_left + this.m_right) / 2);
            ({
                'audio': false,
                'video': {
                    'mandatory': {
                        'minWidth': this.m_resolutionTable[this.m_mid].width,
                        'minHeight': this.m_resolutionTable[this.m_mid].height,
                        'maxWidth': this.m_resolutionTable[this.m_mid].width,
                        'maxHeight': this.m_resolutionTable[this.m_mid].height
                    },
                    'optional': []
                },
                peerIdentity: 'one',
            });
        };
        VideoCamera.prototype.GetPlatform = function () {
            var sUserAgent = navigator.userAgent.toLowerCase();
            var bIsIpad = sUserAgent.match(/ipad/i) == 'ipad';
            var bIsIphoneOs = sUserAgent.match(/iphone/i) == 'iphone';
            var bIsMidp = sUserAgent.match(/midp/i) == 'midp';
            var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == 'rv:1.2.3.4';
            var bIsUc = sUserAgent.match(/ucweb/i) == 'ucweb';
            var bIsAndroid = sUserAgent.match(/android/i) == 'android';
            var bIsCE = sUserAgent.match(/windows ce/i) == 'windows ce';
            var bIsWM = sUserAgent.match(/windows mobile/i) == 'windows mobile';
            sUserAgent.match(/win64/i) == 'win64';
            if (bIsIpad || bIsIphoneOs) {
                return 2;
            }
            else if (bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {
                return 1;
            }
            else {
                return 3;
            }
        };
        VideoCamera.prototype.GetFaceModeStr = function () {
            var sUserAgent = navigator.userAgent.toLowerCase();
            var bIsIpad = sUserAgent.match(/ipad/i) == 'ipad';
            var bIsIphoneOs = sUserAgent.match(/iphone/i) == 'iphone';
            var bIsMidp = sUserAgent.match(/midp/i) == 'midp';
            var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == 'rv:1.2.3.4';
            var bIsUc = sUserAgent.match(/ucweb/i) == 'ucweb';
            var bIsAndroid = sUserAgent.match(/android/i) == 'android';
            var bIsCE = sUserAgent.match(/windows ce/i) == 'windows ce';
            var bIsWM = sUserAgent.match(/windows mobile/i) == 'windows mobile';
            var bWindowsPC = sUserAgent.match(/win64/i) == 'win64';
            var strCameraFace = 'environment';
            this.m_faceMode = 1;
            this.m_deviceFullName = sUserAgent;
            if (bIsIpad || bIsIphoneOs) {
                strCameraFace = 'environment';
                this.m_faceMode = 1;
                this.m_deviceStr = 'ios';
            }
            else if (bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {
                strCameraFace = 'environment';
                this.m_faceMode = 1;
                this.m_deviceStr = 'android';
            }
            else if (bWindowsPC) {
                strCameraFace = 'user';
                this.m_faceMode = 2;
                this.m_deviceStr = 'pc';
            }
            return strCameraFace;
        };
        VideoCamera.prototype.checkSuccess = function (stream) {
            var instance = VideoCamera.m_instance;
            console.log('Success for --> ', instance.m_mid, ' ', instance.m_resolutionTable[instance.m_mid]);
            instance.m_selectedWidth = instance.m_resolutionTable[instance.m_mid].width;
            instance.m_selectedHeight = instance.m_resolutionTable[instance.m_mid].height;
            instance.m_left = instance.m_mid + 1;
            for (var _i = 0, _a = stream.getTracks(); _i < _a.length; _i++) {
                var track = _a[_i];
                track.stop();
            }
            instance.FindMaximum_WidthHeight_ForCamera();
        };
        VideoCamera.prototype.checkError = function (error) {
            var instance = VideoCamera.m_instance;
            console.log('Failed for --> ' + instance.m_mid, ' ', instance.m_resolutionTable[instance.m_mid], ' ', error);
            instance.m_right = instance.m_mid - 1;
            instance.FindMaximum_WidthHeight_ForCamera();
        };
        VideoCamera.prototype.ResolutionCheck = function () {
            this.m_left = 0;
            this.m_right = this.m_resolutionTable.length;
            this.FindMaximum_WidthHeight_ForCamera();
        };
        VideoCamera.prototype.InitResolutionCheckTable = function () {
            VideoCamera.m_instance = this;
            this.m_resolutionTable = [
                { width: 160, height: 120 },
                { width: 320, height: 180 },
                { width: 320, height: 240 },
                { width: 640, height: 360 },
                { width: 640, height: 480 },
                { width: 768, height: 576 },
                { width: 1024, height: 576 },
                { width: 1280, height: 720 },
                { width: 1280, height: 768 },
                { width: 1280, height: 800 },
                { width: 1280, height: 900 },
                { width: 1280, height: 1000 },
                { width: 1920, height: 1080 },
                { width: 1920, height: 1200 },
                { width: 2560, height: 1440 },
                { width: 3840, height: 2160 },
                { width: 4096, height: 2160 }
            ];
        };
        VideoCamera.prototype.GetMostLikelyDeviceId = function (callback) {
            if (callback === void 0) { callback = null; }
            var matches;
            matches = ['back', 'rear'];
            navigator.mediaDevices.enumerateDevices().then(function (devices) {
                var deviceId = '';
                devices = devices.filter(function (d) {
                    return d.kind === 'videoinput';
                });
                var dev = devices.find(function (d) {
                    return matches.some(function (match) {
                        return d.label.toLowerCase().indexOf(match) !== -1;
                    });
                });
                if (!dev && devices.length && matches.indexOf('back') !== -1) {
                    dev = devices[devices.length - 1];
                }
                if (dev) {
                    deviceId = dev.deviceId;
                }
                callback(deviceId);
            });
        };
        VideoCamera.prototype.DoOpenCamera = function () {
            var strFaceMode = this.GetFaceModeStr();
            this.m_platform = this.GetPlatform();
            var constrants = {
                video: {
                    width: { min: this.m_selectedWidth, max: this.m_selectedWidth },
                    height: { min: this.m_selectedHeight, max: this.m_selectedHeight },
                    deviceId: '',
                    facingMode: { exact: strFaceMode },
                },
            };
            this.GetMostLikelyDeviceId(function (deviceId) {
                var instance = VideoCamera.m_instance;
                if (deviceId == null || deviceId == undefined) {
                    return;
                }
                constrants.video.deviceId = deviceId;
                try {
                    if (instance.m_platform == 1 || instance.m_platform == 3) {
                        navigator.mediaDevices.getUserMedia(constrants).then(instance.DoGetMediaStream).catch(instance.DoOpenCameraFailed);
                    }
                    else {
                        navigator.mediaDevices.getUserMedia(constrants).then(instance.DoGetMediaStream).catch(instance.DoOpenCameraFailed);
                    }
                }
                catch (_) {
                    var instance_1 = VideoCamera.m_instance;
                    instance_1.InitAccelarator();
                }
            });
        };
        VideoCamera.prototype.DoOpenCameraFailed = function (error) {
            console.log('failed');
        };
        VideoCamera.prototype.DoGetMediaStream = function (stream) {
            var instance = VideoCamera.m_instance;
            if (instance.m_videoContainer == null || instance.m_videoContainer == undefined
                || instance.m_videoCanvas == null || instance.m_videoCanvas == undefined) {
                return;
            }
            instance.m_videoContainer.srcObject = stream;
            instance.m_videoContainer.setAttribute('playsinline', true);
            instance.m_videoStream = stream;
            instance.m_videoContainer.play();
            instance.m_videoContainer.hidden = true;
            instance.m_videoCanvas.width = instance.m_canvasWidth;
            instance.m_videoCanvas.height = instance.m_canvasHeight;
            instance.m_videoCanvas.style.zIndex = '1';
            instance.m_videoCanvas.hidden = false;
            instance.m_debugTextCtrl.style.zIndex = '2';
            instance.m_debugTextCtrl.hidden = false;
            instance.InitAccelarator();
            instance.SetCameraParam(instance.m_fov, instance.m_selectedWidth, instance.m_selectedHeight, instance.m_near, instance.m_far);
            var strFaceMode = instance.GetFaceModeStr();
            if (strFaceMode == 'user') {
                instance.m_videoCanvas.style.cssText = 'transform:rotateY(0deg);';
            }
            instance.m_bStartScan = true;
            instance.m_qrScanTimePassed = 0;
            var mapView = MapView$1.GetInstance();
            mapView.SetMapCanvas2AR();
        };
        VideoCamera.prototype.IsRunning = function () {
            return this.m_bStartScan;
        };
        VideoCamera.prototype.OpenCamera = function () {
            if (this.m_bResolutionCheck == false) {
                this.ResolutionCheck();
                return;
            }
            else {
                this.DoOpenCamera();
            }
        };
        VideoCamera.prototype.CloseCamera = function () {
            if (this.m_videoStream) {
                this.m_videoStream.getTracks().forEach(function (track) {
                    track.stop();
                });
                this.m_videoStream = null;
            }
            this.m_videoCanvas.style.zIndex = '-1';
            this.m_videoCanvas.hidden = true;
            this.m_debugTextCtrl.style.zIndex = '-1';
            this.m_debugTextCtrl.hidden = true;
            this.m_bStartScan = false;
            var mapView = MapView$1.GetInstance();
            mapView.RecoverMapCanvas();
        };
        VideoCamera.prototype.Tick = function (dt) {
            if (this.m_bStartScan == false) {
                return;
            }
            this.m_qrScanTimePassed += dt;
            if (this.m_qrScanTimePassed >= this.m_qrScanInterval) {
                this.m_qrScanTimePassed -= this.m_qrScanInterval;
                this.ProcessVideoImage();
            }
        };
        VideoCamera.prototype.GetStrLocatoinById = function (id) {
            if (this.m_cameraPosJsonObj == null || this.m_cameraPosJsonObj == undefined) {
                console.log('鏈嶅姟鍣╭rCode鍧愭爣鏂囦欢鑾峰彇澶辫触');
                return 'x=0,y=0,floorid=0A0A0AF01';
            }
            var cameraPosList = this.m_cameraPosJsonObj.data;
            for (var i = 0; i < cameraPosList.length; i++) {
                var cameraPos = cameraPosList[i];
                if (cameraPos.arucoCode == id) {
                    var result = 'x=' + cameraPos.pointX + ',y=' + cameraPos.pointY + ',floorid=' + cameraPos.floorId;
                    return result;
                }
            }
        };
        VideoCamera.prototype.ProcessVideoImage = function () {
            var AR = D__Project_PalMap_HeTunYinLuMerged_palmapMap_node_modules_jsAruco.AR;
            var detector = new AR.Detector();
            if (this.m_videoCanvas == null || this.m_videoCanvas == undefined) {
                return;
            }
            var context = this.m_videoCanvas.getContext('2d');
            var canvasWidth = this.m_videoCanvas.width;
            var canvasHeight = this.m_videoCanvas.height;
            this.m_selectedWidth * 0.5;
            this.m_selectedHeight * 0.5;
            context.drawImage(this.m_videoContainer, 0, 0, canvasWidth, canvasHeight);
            var imageData = context.getImageData(0, 0, canvasWidth, canvasHeight);
            var markers = detector.detect(imageData);
            var code = null;
            if (markers.length > 0) {
                var id = markers[0].id;
                code = {
                    binaryData: [],
                    data: this.GetStrLocatoinById(id),
                    chunks: [],
                    version: 0,
                    location: {
                        topRightCorner: { x: markers[0].corners[1].x, y: markers[0].corners[1].y },
                        topLeftCorner: { x: markers[0].corners[0].x, y: markers[0].corners[0].y },
                        bottomRightCorner: { x: markers[0].corners[2].x, y: markers[0].corners[2].y },
                        bottomLeftCorner: { x: markers[0].corners[3].x, y: markers[0].corners[3].y },
                        topRightFinderPattern: { x: 0, y: 0 },
                        topLeftFinderPattern: { x: 0, y: 0 },
                        bottomLeftFinderPattern: { x: 0, y: 0 },
                        bottomRightAlignmentPattern: { x: 0, y: 0 }
                    }
                };
            }
            if (code) {
                if (code.data && code.data != '') {
                    console.log(code.data);
                    if (this.m_debugTextCtrl) ;
                    this.OnFindQRCode(code);
                    this.drawBox(code.location);
                }
            }
        };
        VideoCamera.prototype.drawBox = function (location) {
            this.drawLine(location.topLeftCorner, location.topRightCorner);
            this.drawLine(location.topRightCorner, location.bottomRightCorner);
            this.drawLine(location.bottomRightCorner, location.bottomLeftCorner);
            this.drawLine(location.bottomLeftCorner, location.topLeftCorner);
        };
        VideoCamera.prototype.drawLine = function (begin, end) {
            if (this.m_videoCanvas == null || this.m_videoCanvas == undefined) {
                return;
            }
            var canvas = this.m_videoCanvas.getContext('2d');
            var ctx = canvas;
            ctx.beginPath();
            ctx.moveTo(begin.x, begin.y);
            ctx.lineTo(end.x, end.y);
            ctx.lineWidth = '3';
            ctx.strokeStyle = 'red';
            ctx.stroke();
        };
        VideoCamera.prototype.OnFindQRCode = function (code) {
            InertiaLocationMgr.GetInstance().ResetPosOffset();
            var strData = code.data;
            var location = code.location;
            var _a = this.GetQRPos(strData), x = _a.x, y = _a.y, floorId = _a.floorId;
            console.log('缁忓害涓�:', x);
            console.log('绾害涓�:', y);
            console.log('妤煎眰涓�:', floorId);
            var centerPoint = new Point(0, 0);
            centerPoint.x = (location.topLeftCorner.x + location.topRightCorner.x + location.bottomLeftCorner.x + location.bottomRightCorner.x) / 4;
            centerPoint.y = (location.topLeftCorner.y + location.topRightCorner.y + location.bottomLeftCorner.y + location.bottomRightCorner.y) / 4;
            this.m_screenX = (centerPoint.x / this.m_selectedWidth * 2 - 1.0) * 0.5;
            this.m_screenY = ((1 - centerPoint.y / this.m_selectedHeight) * 2 - 1) * 0.5;
            var diagonalWidth = Math.pow(centerPoint.x - location.topLeftCorner.x, 2) + Math.pow(centerPoint.y - location.topLeftCorner.y, 2);
            diagonalWidth = Math.pow(diagonalWidth, 0.5);
            var qrPixelWidth = diagonalWidth / 1.414 * 2;
            var screenZ = 1 - qrPixelWidth / Math.min(this.m_selectedWidth, this.m_selectedHeight);
            this.screenToWorld2(centerPoint.x, centerPoint.y, screenZ, new Point(x, y));
            var cameraDir = new Vector4([0, 0, -1, 1]);
            cameraDir = cameraDir.multiplyMat4(this.m_eulerMatrix);
            cameraDir.x /= cameraDir.w;
            cameraDir.y /= cameraDir.w;
            cameraDir.z /= cameraDir.w;
            var nearPoint = new Vector3(cameraDir.x * this.m_near, cameraDir.y * this.m_near, cameraDir.z * this.m_near);
            this.m_nearPoint = new Vector3(-nearPoint.x, -nearPoint.y, -nearPoint.z);
            var worldPoint1 = this.screenToWorld2(location.topLeftCorner.x, location.topLeftCorner.y, screenZ, new Point(x, y));
            var worldPoint2 = this.screenToWorld2(location.topRightCorner.x, location.topRightCorner.y, screenZ, new Point(x, y));
            var worldPoint3 = this.screenToWorld2(location.bottomLeftCorner.x, location.bottomLeftCorner.y, screenZ, new Point(x, y));
            var worldPoint4 = this.screenToWorld2(location.bottomRightCorner.x, location.bottomRightCorner.y, screenZ, new Point(x, y));
            var qrPos = new Point3(0, 0, 0);
            qrPos.x = (worldPoint1.x + worldPoint2.x + worldPoint3.x + worldPoint4.x) * 0.25;
            qrPos.y = (worldPoint1.y + worldPoint2.y + worldPoint3.y + worldPoint4.y) * 0.25;
            qrPos.z = (worldPoint1.z + worldPoint2.z + worldPoint3.z + worldPoint4.z) * 0.25;
            qrPos.x += nearPoint.x;
            qrPos.y += nearPoint.y;
            qrPos.z += nearPoint.z;
            var cameraCoordinates = { x: x, y: y, floorId: floorId };
            this.GetCameraPos(qrPos);
            var inertialOffset = InertiaLocationMgr.GetInstance().GetInertialOffset();
            qrPos.x += inertialOffset.x;
            qrPos.y += inertialOffset.y;
            qrPos.z += inertialOffset.z;
            this.UpdateLocation(floorId, qrPos.x, qrPos.y, qrPos.z, cameraCoordinates);
        };
        VideoCamera.prototype.GetCameraPos = function (qrPos) {
            var result = new Point3(0, 0, 0);
            return result;
        };
        VideoCamera.prototype.screenToWorld2 = function (screenX, screenY, screenZ, qrLocation) {
            var finalMatrix = this.m_projectionMatrix.clone().multiply(this.m_viewMatrix);
            var invFinalMatrix = finalMatrix.clone().invert();
            var ndc = new Vector3((screenX / this.m_selectedWidth * 2.0 - 1.0) * 0.5, ((1 - screenY / this.m_selectedHeight) * 2 - 1) * 0.5, screenZ * 2 - 1);
            var worldPos = new Vector4([ndc.x, ndc.y, ndc.z, 1]);
            worldPos = worldPos.multiplyMat4(invFinalMatrix);
            worldPos.x /= worldPos.w;
            worldPos.y /= worldPos.w;
            worldPos.z /= worldPos.w;
            worldPos.w /= worldPos.w;
            if (this.m_faceMode == 1) {
                return new Point3(-worldPos.x, -worldPos.y, -worldPos.z);
            }
            else {
                return new Point3(worldPos.x, worldPos.y, worldPos.z);
            }
        };
        VideoCamera.prototype.screenToWorld = function (screenX, screenY, qrLocation) {
            var tempTenWorldPoint = new Vector4([10, 0, 0, 1]);
            var tempOneWorldPoint = new Vector4([1, 0, 0, 1]);
            var finalMatrix = this.m_projectionMatrix.clone().multiply(this.m_viewMatrix);
            var invFinalMatrix = finalMatrix.clone().invert();
            var _a = tempTenWorldPoint.multiplyMat4(finalMatrix), tenProjZ = _a.z, tenProjW = _a.w;
            var _b = tempOneWorldPoint.multiplyMat4(finalMatrix), oneProjZ = _b.z, oneProjW = _b.w;
            var halfWidth = this.m_width / 2;
            var halfHeight = this.m_height / 2;
            var tenProjX = (screenX - halfWidth) / halfWidth * tenProjW;
            var tenProjY = (halfHeight - screenY) / halfHeight * tenProjW;
            var tenProjPoint = new Vector4([tenProjX, tenProjY, tenProjZ, tenProjW]);
            var tenWorldPoint = tenProjPoint.multiplyMat4(invFinalMatrix);
            var oneProjX = (screenX - halfWidth) / halfWidth * oneProjW;
            var oneProjY = (halfHeight - screenY) / halfHeight * oneProjW;
            var oneProjPoint = new Vector4([oneProjX, oneProjY, oneProjZ, oneProjW]);
            var oneWorldPoint = oneProjPoint.multiplyMat4(invFinalMatrix);
            var cameraZ = 0;
            var resultX = (cameraZ - tenWorldPoint.z) * (tenWorldPoint.x - oneWorldPoint.x) / (tenWorldPoint.z - oneWorldPoint.z) + tenWorldPoint.x;
            var resultY = (cameraZ - tenWorldPoint.z) * (tenWorldPoint.y - oneWorldPoint.y) / (tenWorldPoint.z - oneWorldPoint.z) + tenWorldPoint.y;
            var resultZ = (cameraZ - tenWorldPoint.z) * (tenWorldPoint.z - oneWorldPoint.z) / (tenWorldPoint.z - oneWorldPoint.z) + tenWorldPoint.z;
            return new Point3(resultX, resultY, resultZ);
        };
        VideoCamera.prototype.GetQRPos = function (strData) {
            var result = { x: 0, y: 0, floorId: '' };
            if (strData == null || strData == undefined) {
                return result;
            }
            var strArray = strData.split(',');
            if (strArray.length < 3) {
                return result;
            }
            console.log('strArray鏄�', strArray);
            result.floorId = strArray[2].substring(8, strArray[2].length);
            result.x = Number(strArray[0].substring(2, strArray[0].length));
            result.y = Number(strArray[1].substring(2, strArray[1].length));
            return result;
        };
        VideoCamera.prototype.UpdateAlphaBetaGamme = function (alpha, beta, gamma) {
            if (alpha == null || beta == null || gamma == null) {
                return;
            }
            if (this.m_debugTextCtrl) ;
        };
        VideoCamera.prototype.UpdateLocation = function (floorId, x, y, z, cameraCoordinates) {
            var _a, _b;
            console.log('x涓�:', x);
            console.log('y涓�:', y);
            console.log('z涓�:', z);
            console.log('cameraCoordinates涓�:', cameraCoordinates);
            if (this.m_debugTextCtrl) {
                var strAlphaBetaGamma = 'alpha=' + this.m_alpha + ',\nbeta=' + this.m_beta + '\ngamma=' + this.m_gamma;
                strAlphaBetaGamma += '\nabsolute=' + this.m_orientationAbsolute;
                strAlphaBetaGamma += '\nscreenX=' + this.m_screenX + '\nscreenY=' + this.m_screenY;
                strAlphaBetaGamma += '\ndevice=' + this.m_deviceStr;
                strAlphaBetaGamma += '\nLookAtDir=' + this.m_lookAtDir3.x + ' ' + this.m_lookAtDir3.y + ' ' + this.m_lookAtDir3.z;
                strAlphaBetaGamma += '\nUpDir=' + this.m_upDir3.x + ' ' + this.m_upDir3.y + ' ' + this.m_upDir3.z;
            }
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined) {
                return;
            }
            this.m_lastVideoPos = new Vector3(x + cameraCoordinates.x, y + cameraCoordinates.y, z);
            this.m_lastFloorId = floorId;
            mapView.m_navi.locationChange(floorId, { x: x + cameraCoordinates.x, y: y + cameraCoordinates.y }, 0);
            mapView.easeTo({
                center: { x: x + cameraCoordinates.x, y: y + cameraCoordinates.y },
                rotate: -this.m_alpha,
                duration: 300,
                easing: 'linear',
            });
            (_b = (_a = mapView.m_navi) === null || _a === void 0 ? void 0 : _a._locationMng) === null || _b === void 0 ? void 0 : _b.setRotate(-this.m_alpha);
        };
        VideoCamera.prototype.InitCameraMatrix = function () {
        };
        VideoCamera.prototype.OnUpdateAccelarator = function (event) {
            var instance = VideoCamera.m_instance;
            instance.UpdateViewMatrix(event.alpha, event.beta, event.gamma, event.absolute, event.webkitCompassHeading);
        };
        VideoCamera.prototype.SetQRCodeRealWidth = function (realWidth) {
            this.m_qrWidth = realWidth;
            this.m_near = this.m_qrWidth;
            if (this.m_videoContainer == null || this.m_videoContainer == undefined) {
                return;
            }
            this.SetCameraParam(this.m_fov, this.m_selectedWidth, this.m_selectedHeight, this.m_near, this.m_far);
        };
        VideoCamera.prototype.UpdateViewMatrix = function (alpha, beta, gamma, absolute, webkitCompassHeading) {
            var _a, _b;
            this.m_alpha = alpha;
            this.m_beta = beta;
            this.m_gamma = gamma;
            this.m_orientationAbsolute = absolute;
            var radianAlpha = this.m_alpha / 360.0 * 2 * Math.PI;
            var radianBeta = this.m_beta / 360.0 * 2 * Math.PI;
            var radianGamma = this.m_gamma / 360.0 * 2 * Math.PI;
            this.m_viewMatrix.setIdentity();
            this.m_viewMatrix.setLookAt([0, 0, 0], [0, 0, -1], [0, 1, 0]);
            var eulerMatrix = new Matrix4$1();
            eulerMatrix.setIdentity();
            eulerMatrix.makeRotationFromEuler(radianBeta, radianGamma, radianAlpha, 'ZXY');
            this.m_eulerMatrix = eulerMatrix;
            var lookAtDir = new Vector4([0, 0, -1, 1]);
            lookAtDir = lookAtDir.multiplyMat4(eulerMatrix);
            var upDir = new Vector4([0, 1, 0, 1]);
            upDir = upDir.multiplyMat4(eulerMatrix);
            var lookAtDirVec3 = new Vector3(lookAtDir.x / lookAtDir.w, lookAtDir.y / lookAtDir.w, lookAtDir.z / lookAtDir.w);
            var upDirVec3 = new Vector3(upDir.x / upDir.w, upDir.y / upDir.w, upDir.z / upDir.w);
            this.m_lookAtDir3 = lookAtDirVec3;
            this.m_upDir3 = upDirVec3;
            this.m_viewMatrix.setIdentity();
            this.m_viewMatrix.setLookAt([0, 0, 0], [lookAtDirVec3.x, lookAtDirVec3.y, lookAtDirVec3.z], [upDirVec3.x, upDirVec3.y, upDirVec3.z]);
            this.m_pixelMatrix = this.m_projectionMatrix.clone().multiply(this.m_viewMatrix);
            this.m_pixelInvertMatrix = this.m_pixelMatrix.clone().invert();
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined) {
                return;
            }
            (_b = (_a = mapView.m_navi) === null || _a === void 0 ? void 0 : _a._locationMng) === null || _b === void 0 ? void 0 : _b.setRotate(-this.m_alpha);
        };
        VideoCamera.prototype.InitAccelarator = function () {
            {
                window.addEventListener('deviceorientationabsolute', this.OnUpdateAccelarator, true);
            }
            window.addEventListener('devicemotion', this.OnUpdateDeviceMotion);
        };
        VideoCamera.prototype.OnUpdateDeviceMotion = function (e) {
            var _a;
            e.acceleration;
            var stdAcce = new Vector4([e.acceleration.x, e.acceleration.y, e.acceleration.z, 1]);
            var worldAcce = stdAcce.multiplyMat4(this.m_eulerMatrix);
            InertiaLocationMgr.GetInstance().OnAccelerateUpdate(worldAcce);
            this.m_inertialOffset = InertiaLocationMgr.GetInstance().GetInertialOffset();
            var mixedPos = new Vector3(this.m_lastVideoPos.x + this.m_inertialOffset.x, this.m_lastVideoPos.y + this.m_inertialOffset.y, this.m_lastVideoPos.z + this.m_inertialOffset.z);
            var mapView = MapView$1.GetInstance();
            if (mapView == null || mapView == undefined) {
                return;
            }
            (_a = mapView.m_navi) === null || _a === void 0 ? void 0 : _a.locationChange(this.m_lastFloorId, mixedPos, 0);
            var strDebug = '';
            this.m_debugTextCtrl.innerText = strDebug + '\noriAcceX=' + e.acceleration.x + ',\noriAcceY=' + e.acceleration.x + ',\noriAcceZ=' + e.acceleration.x
                + '\nacceX=' + worldAcce.x + '\nacceY=' + worldAcce.y + '\nacceZ=' + worldAcce.z
                + '\noffsetX=' + this.m_inertialOffset.x + '\noffsetY=' + this.m_inertialOffset.y + '\noffsetZ=' + this.m_inertialOffset.z;
        };
        VideoCamera.prototype.SetCameraParam = function (fov, width, height, near, far) {
            if (near === void 0) { near = 1; }
            if (far === void 0) { far = 10; }
            this.m_fov = fov;
            this.m_width = width;
            this.m_height = height;
            this.m_near = near;
            this.m_far = far;
            this.m_viewMatrix = new Matrix4$1();
            this.m_projectionMatrix.setPerspective(this.m_fov, 1080 / 1920, this.m_near, this.m_far);
            this.m_pixelMatrix = this.m_projectionMatrix.clone().multiply(this.m_viewMatrix);
            this.m_pixelInvertMatrix = this.m_pixelMatrix.clone().invert();
        };
        VideoCamera.m_instance = null;
        return VideoCamera;
    }());

    var MapView = (function (_super) {
        __extends$1(MapView, _super);
        function MapView(options) {
            var _this = _super.call(this, __assign$1(__assign$1({}, defaultOptions$c), options)) || this;
            _this._floors = [];
            _this._floorMap = new Map();
            _this._status = 'init';
            _this.m_videoContainer = null;
            _this.m_bVideoTest = false;
            _this.m_videoCamera = null;
            _this.m_qrCodeWidth = 0.175;
            _this.m_videoCanvas = null;
            _this.m_debugTextDom = null;
            _this._controls = new Map();
            _this._hasDrawMultiple = false;
            _this._planarGraphMap = new Map();
            _this.m_lights = new Array();
            _this.m_bLightEnable = true;
            _this.m_bTextureEnable = false;
            _this.m_bExtraPerspecAnim = true;
            _this.m_bShadowEnable = false;
            _this.m_bFeatureZoomRangeEnable = true;
            _this.m_maxDisplayedPOICount = 10000;
            _this.m_maxDisplayedRoomCount = 10000;
            _this.m_bPerspective = true;
            _this.m_bOnly2d = false;
            _this.m_extraPrespectiveStartZoom = 17.5;
            _this.m_featureTextureCoordRatio = 0.1;
            _this.m_bDisplayNaviPickMarker = false;
            _this.m_brightness = 1;
            _this.m_saturation = 1;
            _this.m_contrast = 1;
            _this.m_locationSDK = null;
            _this.m_afterSignatureGet = 0;
            _this.m_afterStartSearch = 0;
            _this.m_preNetworkRequestCallBack = null;
            _this.m_postNetworkRequestCallBack = null;
            _this._3dResourceLoading = false;
            _this._3dResourceLoaded = false;
            _this.m_noDrawBeforeFirstFitNaviLine = false;
            _this.m_bucketTaskCount = 0;
            _this.m_bCanDraw = true;
            _this.m_version = 'MapSDK-PhoneCJ3.1.1';
            _this.m_mapViewStartTime = 0;
            _this.m_blinkFeatureIdArr = new Array();
            _this.m_mapViewStartTime = Date.now();
            LogMgr$1.log('sdk version: ' + _this.m_version);
            var _a = _this._options, buildingId = _a.buildingId, appKey = _a.appKey;
            if (!buildingId || !appKey) {
                throw new Error('MapView: init failed');
            }
            _this._canvasContainer = document.createElement('div');
            _this._canvasContainer.classList.add('ngr-canvas-container');
            _this._canvasContainer.style.background = _this._options.background || '';
            var leftTopDom = document.createElement('div');
            leftTopDom.classList.add('ngr-control-top-left');
            var rightTopDom = document.createElement('div');
            rightTopDom.classList.add('ngr-control-top-right');
            var leftBottomDom = document.createElement('div');
            leftBottomDom.classList.add('ngr-control-bottom-left');
            var rightBottomDom = document.createElement('div');
            rightBottomDom.classList.add('ngr-control-bottom-right');
            _this._domControls = {
                'top-left': leftTopDom,
                'top-right': rightTopDom,
                'bottom-left': leftBottomDom,
                'bottom-right': rightBottomDom,
            };
            _this._gestureManager = new GestureManager(_this);
            _this._res = new DataSource$1({
                appKey: _this._options.appKey,
                server: _this._options.server,
                useCache: _this._options.useCache,
            });
            if (MapView.m_instance == null) {
                MapView.m_instance = _this;
            }
            ParkingMgr.getInstance().Init();
            return _this;
        }
        MapView.prototype.GetMapViewStartTime = function () {
            return this.m_mapViewStartTime;
        };
        MapView.prototype.DrawBox = function (canvas, location) {
            this.DrawLine(canvas, location.topLeftCorner, location.topRightCorner);
            this.DrawLine(canvas, location.topRightCorner, location.bottomRightCorner);
            this.DrawLine(canvas, location.bottomRightCorner, location.bottomLeftCorner);
            this.DrawLine(canvas, location.bottomLeftCorner, location.topLeftCorner);
        };
        MapView.prototype.SetMapCanvas2AR = function () {
            if (this._canvasContainer == null || this._canvasContainer == undefined) {
                return;
            }
            this._canvasContainer.style.top = '480px';
            this._canvasContainer.style.width = '480px';
            this._canvasContainer.style.height = '240px';
            this._engine.resize();
        };
        MapView.prototype.RecoverMapCanvas = function () {
            if (this._canvasContainer == null || this._canvasContainer == undefined) {
                return;
            }
            this._canvasContainer.style.top = '0px';
            this._canvasContainer.style.height = '100%';
            this._canvasContainer.style.width = '100%';
            this._engine.resize();
        };
        MapView.prototype.GetModelTextByFeature = function (feature) {
            if (feature == null || feature == undefined) {
                return null;
            }
            if (this.m_config == null || this.m_config == undefined
                || this.m_config.modelTexts == null || this.m_config.modelTexts == undefined
                || this.m_config.modelTexts.length <= 0) {
                return null;
            }
            for (var i = 0; i < this.m_config.modelTexts.length; i++) {
                var model = this.m_config.modelTexts[i];
                if (model.featureId == feature.properties.id) {
                    return model;
                }
            }
            return null;
        };
        MapView.prototype.IsTopSymbolFeature = function (feature) {
            if (feature == null || feature == undefined) {
                return false;
            }
            if (this.m_config == null || this.m_config == undefined
                || this.m_config.modelTexts == null || this.m_config.modelTexts == undefined
                || this.m_config.modelTexts.length <= 0) {
                return false;
            }
            for (var i = 0; i < this.m_config.modelTexts.length; i++) {
                var modelText = this.m_config.modelTexts[i];
                if (modelText.featureId == feature.properties.featureId) {
                    return true;
                }
            }
            return false;
        };
        MapView.prototype.DrawLine = function (canvas, begin, end) {
            if (canvas == null || canvas == undefined) {
                return;
            }
            var ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.moveTo(begin.x, begin.y);
            ctx.lineTo(end.x, end.y);
            ctx.lineWidth = '3';
            ctx.strokeStyle = 'red';
            ctx.stroke();
        };
        MapView.prototype.InitVideoStream = function () {
            this.m_videoContainer = document.createElement('video');
            this.m_videoContainer.id = 'videoTest';
            this.m_videoContainer.style.width = '480px';
            this.m_videoContainer.style.height = '480px';
            this.m_videoContainer.style.position = 'absolute';
            this.m_videoContainer.style.zIndex = '-1';
            this._container.appendChild(this.m_videoContainer);
            this.m_videoCanvas = document.createElement('canvas');
            this.m_videoCanvas.id = 'canvasTest';
            this.m_videoCanvas.style.width = '480px';
            this.m_videoCanvas.style.height = '480px';
            this.m_videoCanvas.style.position = 'absolute';
            this.m_videoCanvas.style.left = '0px';
            this.m_videoCanvas.style.top = '0px';
            this.m_videoCanvas.style.zIndex = '-1';
            this._container.appendChild(this.m_videoCanvas);
            this.m_debugTextDom = document.createElement('div');
            this.m_debugTextDom.id = 'debugText';
            this.m_debugTextDom.style.width = '640px';
            this.m_debugTextDom.style.height = '480px';
            this.m_debugTextDom.style.position = 'absolute';
            this.m_debugTextDom.style.left = '0px';
            this.m_debugTextDom.style.top = '0px';
            this.m_debugTextDom.style.zIndex = '-1';
            this.m_debugTextDom.style.color = 'red';
            this._container.appendChild(this.m_debugTextDom);
            this.m_videoCanvas;
            this.m_videoContainer;
            this.m_debugTextDom;
            var sUserAgent = navigator.userAgent.toLowerCase();
            sUserAgent.match(/ipad/i) === 'ipad';
            sUserAgent.match(/iphone os/i) === 'iphone os';
            sUserAgent.match(/midp/i) == 'midp';
            sUserAgent.match(/rv:1.2.3.4/i) == 'rv:1.2.3.4';
            sUserAgent.match(/ucweb/i) == 'ucweb';
            sUserAgent.match(/android/i) == 'android';
            sUserAgent.match(/windows ce/i) == 'windows ce';
            sUserAgent.match(/windows mobile/i) == 'windows mobile';
            sUserAgent.match(/win64/i) == 'win64';
            var videoOption = { Height: 480, Width: 480, CanvasWidth: 480, CanvasHeight: 480 };
            this.m_videoCamera = new VideoCamera(videoOption);
            this.m_videoCamera.SetQRCodeRealWidth(this.m_qrCodeWidth);
            this.m_videoCamera.SetVideoDom(this.m_videoContainer);
            this.m_videoCamera.SetVideoCanvas(this.m_videoCanvas);
            this.m_videoCamera.SetDebugTextCtrl(this.m_debugTextDom);
        };
        MapView.GetInstance = function () {
            return MapView.m_instance;
        };
        MapView.prototype.Tick = function (dt) {
            this.Tick2d3dCheck(dt);
            if (this.m_videoCamera) {
                this.m_videoCamera.Tick(dt);
            }
        };
        MapView.prototype.Tick2d3dCheck = function (dt) {
        };
        MapView.prototype.handleLocationTip = function (status) {
        };
        MapView.prototype.handleSignature = function (status) {
            this.setBrightness(2.0);
            status.isGetSignature; status.getSignatureTime;
            this.m_afterSignatureGet = Date.now();
        };
        MapView.prototype.componentWillMount = function () {
            var _this = this;
            {
                this.m_locationSDK.registerGetSignature &&
                    this.m_locationSDK.registerGetSignature(this.handleSignature);
                this.m_locationSDK.registerCindyBeacons &&
                    this.m_locationSDK.registerCindyBeacons(function (status) {
                        status.isLoadCindyBeacon; status.loadCindyBeaconTime;
                    });
                this.m_locationSDK.registerStartComplete
                    &&
                        this.m_locationSDK.registerStartComplete(function (status) {
                            _this.setBrightness(2.0);
                            if (status === 'startSearchBeacons:ok') {
                                Date.now() - _this.m_afterSignatureGet;
                                _this.m_afterStartSearch = Date.now();
                            }
                        });
                this.m_afterStartSearch = Date.now();
            }
        };
        MapView.prototype.InitLocationSdk = function (config) {
            var _this = this;
            var globalConfig = __assign$1({}, config);
            var locationConfig = globalConfig.locationConfig, baseConfig = globalConfig.baseConfig; globalConfig.navigateConfig; globalConfig.tipConfig; globalConfig.GPSLocationConfig;
            baseConfig.buildingId; baseConfig.mapConfig; baseConfig.isNeedLocate; baseConfig.locationSDKType; baseConfig.routeStrategies; baseConfig.naviType; baseConfig.outside;
            this.m_locationSDK = new LocationSDK(locationConfig);
            this.m_locationSDK.start();
            this.m_locationSDK.registerStartComplete(function (status) {
            });
            this.m_locationSDK.registerCompassChange(function (angle) {
                if (isNaN(angle) || typeof angle !== 'number')
                    return;
            });
            this.m_locationSDK.registerPalmapLocationChange(function (locationRes) { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this.setBrightness(2.0);
                    LogMgr$1.log('zhengli m_locationSDK.registerPalmapLocationChange 1 ');
                    if (locationRes.floor === 'any') ;
                    if (locationRes.floor !== '0' && locationRes.floor) ;
                    if (this.m_navi) {
                        this.m_navi.locationChange(locationRes.floor, {
                            x: locationRes.x,
                            y: locationRes.y,
                        }, locationRes.duration);
                    }
                    return [2];
                });
            }); });
            this.componentWillMount();
            this.componentDidMount();
        };
        MapView.prototype.componentDidMount = function () {
            this.m_locationSDK.bleMng.registerSearchBeacon(function (data) {
                if ((typeof data === 'object') && data.length > 0) ;
            });
        };
        MapView.prototype.getBdId = function () {
            return this._options.buildingId;
        };
        MapView.prototype.getFloorData = function (floorId) {
            return this._floorMap.get(floorId);
        };
        MapView.prototype.UpdateEuler = function (alpha, beta, gamma) {
            var eular = [];
            eular.push(alpha);
            eular.push(beta);
            eular.push(gamma);
            this.fire('updateEular', eular);
        };
        MapView.prototype.OnClick2d3d = function () {
            console.log('鐐逛簡2d3d鎸夐挳');
            if (this.m_videoCamera != null && this.m_videoCamera != undefined) {
                if (this.m_videoCamera.IsRunning()) {
                    console.log('鍏抽棴鎽勫儚澶�');
                    this.m_videoCamera.CloseCamera();
                }
                else {
                    console.log('鎵撳紑鎽勫儚澶�');
                    this.m_videoCamera.OpenCamera();
                }
            }
        };
        MapView.prototype.OpenVideoLocationCamera = function () {
            console.log('鎵撳紑鎽勫儚澶�');
            if (this.m_videoCamera == null || this.m_videoCamera == undefined) {
                return;
            }
            this.m_videoCamera.OpenCamera();
        };
        MapView.prototype.CloseVideoLocationCamera = function () {
            console.log('鍏抽棴鎽勫儚澶�');
            this.m_videoCamera.CloseCamera();
        };
        MapView.prototype.setViewType = function (viewType) {
            return __awaiter(this, void 0, void 0, function () {
                var offset, i, i, _a;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this._engine || this._viewType === viewType)
                                return [2];
                            this._viewType = viewType;
                            offset = this._engine.getOffset();
                            if (!(this._viewType === 'single')) return [3, 3];
                            this._engine.getCamera().setZ(0);
                            for (i = 0; i < this._outdoorLayers.size(); i += 1) {
                                this._outdoorLayers.get(i).setMultiLayout({ opacity: 1, base: 0 });
                            }
                            for (i = 0; i < this._layers.size(); i += 1) {
                                this._layers.get(i).setMultiLayout({ opacity: 1, base: 0 });
                            }
                            _a = this.currentFloor;
                            if (!_a) return [3, 2];
                            return [4, this._drawPlanarGraph(this.currentFloor)];
                        case 1:
                            _a = (_b.sent());
                            _b.label = 2;
                        case 2:
                            this._easeTo({
                                pitch: 0,
                                center: this._options.center || { x: -offset[0], y: -offset[1] },
                            });
                            return [3, 4];
                        case 3:
                            if (this._viewType === 'multiple') {
                                this._hasDrawMultiple = false;
                                this._easeTo({
                                    pitch: 60,
                                    center: this._options.multipleCenter || { x: -offset[0], y: -offset[1] },
                                    complete: function () {
                                        _this._drawMultiPlanarGraph();
                                    },
                                });
                            }
                            _b.label = 4;
                        case 4:
                            this.fire('changeViewType', this._viewType);
                            return [2];
                    }
                });
            });
        };
        MapView.prototype._setupContainer = function (container) {
            container.classList.add('ngr-map');
            container.appendChild(this._domControls['bottom-left']);
            container.appendChild(this._domControls['bottom-right']);
            container.appendChild(this._domControls['top-left']);
            container.appendChild(this._domControls['top-right']);
            container.appendChild(this._canvasContainer);
        };
        MapView.prototype.getDomControls = function () {
            return this._domControls;
        };
        MapView.prototype.setControlTop = function (style, duration) {
            if (duration === void 0) { duration = 0; }
            this._domControls['top-right'].style.transform = "translateY(" + style + ")";
            this._domControls['top-right'].style.transition = "transform " + duration + "s";
            this._domControls['top-left'].style.transform = "translateY(" + style + ")";
            this._domControls['top-left'].style.transition = "transform " + duration + "s";
        };
        MapView.prototype.setControlBottom = function (style, duration) {
            if (duration === void 0) { duration = 0; }
            this._domControls['bottom-right'].style.transform = "translateY(-" + style + ")";
            this._domControls['bottom-right'].style.transition = "transform " + duration + "s";
            this._domControls['bottom-left'].style.transform = "translateY(-" + style + ")";
            this._domControls['bottom-left'].style.transition = "transform " + duration + "s";
        };
        MapView.prototype.LoadConfig = function (strConfigUrl) {
            return __awaiter(this, void 0, Promise, function () {
                var jsonObj, res;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            jsonObj = null;
                            if (!(typeof strConfigUrl === 'string')) return [3, 2];
                            return [4, new HttpClient().get(strConfigUrl)];
                        case 1:
                            res = _a.sent();
                            jsonObj = typeof res === 'string' ? JSON.parse(res) : res;
                            return [3, 3];
                        case 2:
                            jsonObj = strConfigUrl;
                            _a.label = 3;
                        case 3:
                            this.m_config = jsonObj;
                            this.m_naviConfig = jsonObj.Navigation;
                            return [2];
                    }
                });
            });
        };
        MapView.prototype.GetNaviParam = function () {
            var defaultParam = {
                maxRoadAttachDistance: 12,
                maxDistanceReInitNavi: 30,
                maxOutRoadAttachDistance: 30,
                maxOutDistanceReInitNavi: 50,
            };
            {
                var navi = this.m_navi;
                if (navi == null || navi == undefined) {
                    return defaultParam;
                }
                var naviOption = navi.GetOption();
                if (naviOption == null || naviOption == undefined) {
                    return defaultParam;
                }
                return {
                    maxRoadAttachDistance: naviOption.maxRoadAttachDistance,
                    maxDistanceReInitNavi: naviOption.maxDistanceReInitNavi,
                    maxOutRoadAttachDistance: naviOption.outdoorMaxRoadAttachDistance,
                    maxOutDistanceReInitNavi: naviOption.outdoorMaxDistanceReInitNavi,
                };
            }
        };
        MapView.prototype.GetSymbolHeight = function (featureId) {
            if (this.m_config == null || this.m_config == undefined) {
                return 0;
            }
            if (this.m_config.extraTable == null
                || this.m_config.extraTable == undefined) {
                return 0;
            }
            for (var i = 0; i < this.m_config.extraTable.length; i++) {
                if (this.m_config.extraTable[i].featureId == featureId) {
                    if (this.m_config.extraTable[i].symbolHeight == null
                        || this.m_config.extraTable[i].symbolHeight == undefined) {
                        return 0;
                    }
                    else {
                        return parseFloat(this.m_config.extraTable[i].symbolHeight);
                    }
                }
            }
            return 0;
        };
        MapView.prototype.GetFeatureHeight = function (featureId) {
            if (featureId == null || featureId == undefined || featureId == '') {
                return undefined;
            }
            if (this.m_config == null || this.m_config == undefined) {
                return undefined;
            }
            if (this.m_config.extraTable == null
                || this.m_config.extraTable == undefined) {
                return undefined;
            }
            for (var i = 0; i < this.m_config.extraTable.length; i++) {
                if (this.m_config.extraTable[i].featureId == featureId) {
                    return parseFloat(this.m_config.extraTable[i].height);
                }
            }
            return undefined;
        };
        MapView.prototype.GetFeatureTextureCoordFactor = function (featureId) {
            var defaultTextureCoordFactor = 0.5;
            if (this.m_config == null || this.m_config == undefined) {
                return defaultTextureCoordFactor;
            }
            if (this.m_config.chartlet == null
                || this.m_config.chartlet == undefined) {
                return defaultTextureCoordFactor;
            }
            for (var i = 0; i < this.m_config.chartlet.length; i++) {
                if (this.m_config.chartlet[i].featureId === featureId) {
                    if (this.m_config.chartlet[i].textureCoordFactor != null
                        && this.m_config.chartlet[i].textureCoordFactor != undefined) {
                        return this.m_config.chartlet[i].textureCoordFactor;
                    }
                    else {
                        return defaultTextureCoordFactor;
                    }
                }
            }
            return defaultTextureCoordFactor;
        };
        MapView.prototype.GetChartletTable = function () {
            if (this.m_config == null || this.m_config == undefined) {
                return null;
            }
            return this.m_config.chartlet;
        };
        MapView.prototype.GetFeatureTextureURL = function (featureId) {
            if (this.m_config == null || this.m_config == undefined) {
                return '';
            }
            if (this.m_config.chartlet == null
                || this.m_config.chartlet == undefined) {
                return '';
            }
            for (var i = 0; i < this.m_config.chartlet.length; i++) {
                if (this.m_config.chartlet[i].featureId === featureId) {
                    return this.m_config.chartlet[i].url;
                }
            }
            return '';
        };
        MapView.prototype.setMaxDisplayedPOICount = function (maxDisplayedPOICount) {
            this.m_maxDisplayedPOICount = maxDisplayedPOICount;
        };
        MapView.prototype.getMaxDisplayedPOICount = function () {
            return this.m_maxDisplayedPOICount;
        };
        MapView.prototype.setMaxDisplayedRoomCount = function (maxDisplayedRoomCount) {
            this.m_maxDisplayedRoomCount = maxDisplayedRoomCount;
        };
        MapView.prototype.getMaxDisplayedRoomCount = function () {
            return this.m_maxDisplayedRoomCount;
        };
        MapView.prototype.setMaxFloorCachedAllowed = function (maxFloorCachedAllowed) {
            Global.m_maxFloorCachedAllowed = maxFloorCachedAllowed;
        };
        MapView.prototype.getMaxFloorCachedAllowed = function () {
            return Global.m_maxFloorCachedAllowed;
        };
        MapView.prototype.GetPreNetworkRequestCallBack = function () {
            return this.m_preNetworkRequestCallBack;
        };
        MapView.prototype.SetPreNetworkRequestCallBack = function (callback) {
            this.m_preNetworkRequestCallBack = callback;
        };
        MapView.prototype.GetPostNetworkRequestCallBack = function () {
            return this.m_postNetworkRequestCallBack;
        };
        MapView.prototype.SetPostNetworkRequestCallBack = function (callback) {
            this.m_postNetworkRequestCallBack = callback;
        };
        MapView.prototype.setExtraPerspective = function (bPerspective) {
            this.m_bPerspective = bPerspective;
        };
        MapView.prototype.getExtraPerspective = function () {
            return this.m_bPerspective;
        };
        MapView.prototype.getOnly2d = function () {
            return this.m_bOnly2d;
        };
        MapView.prototype.setOnly2d = function (bOnly2d) {
            return;
        };
        MapView.prototype.SetOutDoor = function (bOutDoor) {
            Global.getInstance().SetOutDoor(bOutDoor);
        };
        MapView.prototype.AddHideFeatureByCategoryId = function (categoryId) {
            Global.getInstance().AddHideFeatureByCategoryId(categoryId);
        };
        MapView.prototype.RemoveHideFeatureByCategoryId = function (categoryId) {
            Global.getInstance().RemoveHideFeatureByCategoryId(categoryId);
        };
        MapView.prototype.AddHideFeatureByColorId = function (colorId) {
            Global.getInstance().AddHideFeatureByColorId(colorId);
        };
        MapView.prototype.setParkInfo = function (featureId, state) {
            ParkingMgr.getInstance().SetParkInfo(featureId, state);
        };
        MapView.prototype.setParkStateColorString = function (state, colorString) {
            ParkingMgr.getInstance().SetParkStateColorString(state, colorString);
        };
        MapView.prototype.updateParkInfoToMapView = function () {
            ParkingMgr.getInstance().UpdateParkInfoToMapView();
        };
        MapView.prototype.StartBlink = function (featureId) {
            if (featureId == null || featureId == undefined) {
                return;
            }
            var bFind = false;
            for (var i = 0; i < this.m_blinkFeatureIdArr.length; i++) {
                if (this.m_blinkFeatureIdArr[i] == featureId) {
                    bFind = true;
                    break;
                }
            }
            if (bFind == false) {
                this.m_blinkFeatureIdArr.push(featureId);
            }
        };
        MapView.prototype.StopBlick = function (featureId) {
            if (featureId == null || featureId == undefined) {
                return;
            }
            for (var i = 0; i < this.m_blinkFeatureIdArr.length; i++) {
                if (this.m_blinkFeatureIdArr[i] == featureId) {
                    this.m_blinkFeatureIdArr.splice(i, 1);
                    i--;
                }
            }
        };
        MapView.prototype.setExtraPrespectiveStartZoom = function (zoom) {
            this.m_extraPrespectiveStartZoom = zoom;
        };
        MapView.prototype.getExtraPrespectiveStartZoom = function () {
            return this.m_extraPrespectiveStartZoom;
        };
        MapView.prototype.setFeatureTextureCroodRatio = function (factor) {
            this.m_featureTextureCoordRatio = factor;
        };
        MapView.prototype.getFeatureTextureCoordRatio = function () {
            return this.m_featureTextureCoordRatio;
        };
        MapView.prototype.IsExtraByColorId = function (colorId) {
            if (colorId == null || colorId == undefined) {
                return false;
            }
            if (colorId == 7 || colorId == 8) {
                return true;
            }
            else {
                return false;
            }
        };
        MapView.prototype.IsExtra = function (feature) {
            var _a;
            if (feature == null || feature == undefined) {
                return false;
            }
            if (feature.properties != null && feature.properties != undefined) {
                if (feature.properties.isExtra != null && feature.properties.isExtra != undefined) {
                    return feature.properties.isExtra;
                }
            }
            var colorid = (_a = feature === null || feature === void 0 ? void 0 : feature.properties) === null || _a === void 0 ? void 0 : _a.colorid;
            if (colorid == null || colorid == undefined) {
                return false;
            }
            if (colorid == 7 || colorid == 8) {
                return true;
            }
            else {
                return false;
            }
        };
        MapView.prototype.GetFeatureSideTextureURL = function (featureId) {
            if (this.m_config == null || this.m_config == undefined) {
                return '';
            }
            if (this.m_config.chartlet == null
                || this.m_config.chartlet == undefined) {
                return;
            }
            for (var i = 0; i < this.m_config.chartlet.length; i++) {
                if (this.m_config.chartlet[i].featureId == featureId) {
                    return this.m_config.chartlet[i].sideTextureUrl;
                }
            }
            return '';
        };
        MapView.prototype.LoadTexture = function () {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var i;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (this.m_config == null || this.m_config == undefined) {
                                return [2];
                            }
                            if (this.m_config.chartlet == null || this.m_config.chartlet == undefined) {
                                return [2];
                            }
                            i = 0;
                            _d.label = 1;
                        case 1:
                            if (!(i < this.m_config.chartlet.length)) return [3, 5];
                            return [4, ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.getTextureMng().loadTexture(this.m_config.chartlet[i].url, {
                                    xRepeat: true,
                                    yRepeat: true
                                }))];
                        case 2:
                            _d.sent();
                            return [4, ((_b = this._engine) === null || _b === void 0 ? void 0 : _b.getTextureMng().loadTexture(this.m_config.chartlet[i].sideTextureUrl, {
                                    xRepeat: true,
                                    yRepeat: true
                                }))];
                        case 3:
                            _d.sent();
                            _d.label = 4;
                        case 4:
                            i++;
                            return [3, 1];
                        case 5: return [4, ((_c = this._engine) === null || _c === void 0 ? void 0 : _c.getTextureMng().loadTexture('./assets/tube1.png', { xRepeat: true, yRepeat: true }))];
                        case 6:
                            _d.sent();
                            return [2];
                    }
                });
            });
        };
        MapView.prototype.init = function (container, style, isExtra, bEnterDefaultFloor) {
            if (isExtra === void 0) { isExtra = true; }
            if (bEnterDefaultFloor === void 0) { bEnterDefaultFloor = true; }
            return __awaiter(this, void 0, void 0, function () {
                var this1, dom, floorItem;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, _super.prototype.init.call(this, this._canvasContainer, style)];
                        case 1:
                            _a.sent();
                            this1 = this;
                            return [4, this.LoadConfig(style).then(function (param1) {
                                    var _a;
                                    (_a = this1.m_navi) === null || _a === void 0 ? void 0 : _a.UpdateNaviConfig();
                                    this1.UpdateZoomRangeTable();
                                    this1.InitTopSymbolLayerTable();
                                })];
                        case 2:
                            _a.sent();
                            this.LoadTexture();
                            if (typeof container === 'string') {
                                dom = document.getElementById(container);
                            }
                            else if (container instanceof HTMLElement) {
                                dom = container;
                            }
                            if (!dom) {
                                throw new Error('the container is not exit');
                            }
                            this._container = dom;
                            this._setupContainer(this._container);
                            if (!style) {
                                throw new Error('style is required');
                            }
                            if (!isExtra)
                                sessionStorage.setItem('isExtra', 'off');
                            this._execLoading();
                            this.fire('init');
                            return [4, this._loadFloors()];
                        case 3:
                            _a.sent();
                            if (!this._defaultFloor) {
                                this._execError(new Error("the " + this._options.buildingId + " is empty"));
                                return [2];
                            }
                            floorItem = this._outdoorFloor || this._floorMap.get(this._defaultFloor);
                            this._setupOffset(floorItem);
                            this._setupTileLayer();
                            if (!(this._outdoorFloor && this._options.enableOutdoor)) return [3, 5];
                            return [4, this._drawPlanarGraph(this._outdoorFloor.flId)];
                        case 4:
                            _a.sent();
                            _a.label = 5;
                        case 5:
                            if (!bEnterDefaultFloor) return [3, 7];
                            return [4, this.setCurrentFloor(this._defaultFloor)];
                        case 6:
                            _a.sent();
                            _a.label = 7;
                        case 7:
                            ShadowMgr$1.GetInstance().Init(this._engine);
                            if (this.m_bVideoTest) {
                                this.InitVideoStream();
                            }
                            this.resize();
                            this._execLoaded();
                            return [2];
                    }
                });
            });
        };
        MapView.prototype.SetEnableVideoTest = function (bEnable) {
            this.m_bVideoTest = bEnable;
        };
        MapView.prototype.InitTopSymbolLayerTable = function () {
            if (this.m_config == null || this.m_config == undefined
                || this.m_config.modelTexts == null || this.m_config.modelTexts == undefined) {
                return;
            }
            if (!this._styleMng)
                return;
            var areaTextStyle = this._styleMng.getStyle('areaText');
            if (!areaTextStyle)
                return;
            this.m_topSymbolLayer = new SymbolLayer(areaTextStyle);
            this.m_topSymbolLayer.setOrder(15);
            this.addLayer(this.m_topSymbolLayer);
        };
        MapView.prototype.UpdateZoomRangeTable = function () {
            if (this.m_config == null || this.m_config == undefined
                || this.m_config.zoomRangeTable == null || this.m_config.zoomRangeTable == undefined) {
                return;
            }
            for (var i = 0; i < this.m_config.zoomRangeTable.length; i++) {
                var obj = this.m_config.zoomRangeTable[i];
                var index = parseInt(obj.featurenumber);
                ZoomRangeConfig.zoomRangeTable[index] = obj.zoom;
            }
            return;
        };
        MapView.prototype.preload = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this._loadFloors()];
                        case 1:
                            _a.sent();
                            this._outdoorFloor && this._requestPlanarGraph(this._outdoorFloor.flId);
                            this._defaultFloor && this._requestPlanarGraph(this._defaultFloor);
                            return [2];
                    }
                });
            });
        };
        MapView.prototype.reload = function () {
            this._reset();
            this._loadFloors();
        };
        MapView.prototype.setCurrentFloor = function (floorId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.currentFloor === floorId || !this._floorMap.has(floorId))
                                return [2];
                            this.currentFloor = floorId;
                            this.fire('FloorStart', this.currentFloor);
                            if (!(this._viewType === 'single')) return [3, 2];
                            return [4, this._drawPlanarGraph(floorId)];
                        case 1:
                            _a.sent();
                            return [3, 4];
                        case 2:
                            if (!(this._viewType === 'multiple')) return [3, 4];
                            return [4, this._drawMultiPlanarGraph()];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4:
                            this.fire('changeFloor', floorId);
                            return [2];
                    }
                });
            });
        };
        MapView.prototype.getDefaultFloor = function () {
            return this._defaultFloor;
        };
        MapView.prototype.LoadOutDoorFloor = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._options.enableOutdoor = true;
                            return [4, this._drawPlanarGraph(this._outdoorFloor.flId)];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        MapView.prototype.SetQRCodeRealWidth = function (realWidth) {
            this.m_qrCodeWidth = realWidth;
            if (this.m_videoCamera) {
                this.m_videoCamera.SetQRCodeRealWidth(realWidth);
            }
        };
        MapView.prototype.UpdateVideoLocation = function (floorId, x, y) {
        };
        MapView.prototype.SetEnableOutDoor = function (bEnableOutDoor) {
            this._options.enableOutdoor = bEnableOutDoor;
        };
        MapView.prototype.updateBuildingId = function (buildingId) {
            return __awaiter(this, void 0, void 0, function () {
                var floorItem, _a, x, y, camera;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (this._options.buildingId === buildingId)
                                return [2];
                            this._options.buildingId = buildingId;
                            if (!this._engine)
                                return [2];
                            this._reset();
                            this._engine.reset();
                            this._execLoading();
                            return [4, this._loadFloors()];
                        case 1:
                            _b.sent();
                            if (!this._defaultFloor)
                                return [2];
                            floorItem = this._outdoorFloor || this._floorMap.get(this._defaultFloor);
                            this._setupOffset(floorItem);
                            _a = floorItem.center.coordinates, x = _a[0], y = _a[1];
                            camera = this._engine.getCamera();
                            camera.set({ center: { x: x, y: y } });
                            if (!(this._outdoorFloor && this._options.enableOutdoor)) return [3, 3];
                            return [4, this._drawPlanarGraph(this._outdoorFloor.flId)];
                        case 2:
                            _b.sent();
                            _b.label = 3;
                        case 3: return [4, this.setCurrentFloor(this._defaultFloor)];
                        case 4:
                            _b.sent();
                            this._execLoaded();
                            return [2];
                    }
                });
            });
        };
        MapView.prototype._reset = function () {
            this._layers.clear();
            this._outdoorLayers.clear();
            this._hasDrawFloorId.clear();
            this._hasDrawMultiple = false;
            this._planarGraphMap.clear();
            this._floors.length = 0;
            this._floorMap.clear();
            delete this._outdoorFloor;
            delete this._defaultFloor;
        };
        MapView.prototype.highlightFloor = function (floors) {
            if (this._viewType !== 'multiple')
                return;
            this._updatePlanarGraphOpacity(floors);
            this._engine && this._engine.render();
        };
        MapView.prototype.getLights = function () {
            return this.m_lights;
        };
        MapView.prototype.getLightCount = function () {
            return this.m_lights.length;
        };
        MapView.prototype.addLight = function (pos, color) {
            var light = new Light('', pos, color);
            var index = this.m_lights.push(light);
            return index;
        };
        MapView.prototype.deleteLight = function (index) {
            this.m_lights.splice(index, 1);
        };
        MapView.prototype.removeAllLights = function () {
            this.m_lights = new Array();
        };
        MapView.prototype.setLightEnable = function (bEnable) {
            this.m_bLightEnable = bEnable;
        };
        MapView.prototype.setTextureEnable = function (bEnable) {
            var _a;
            this.m_bTextureEnable = bEnable;
            Global.m_bTextureEnable = bEnable;
            (_a = this._engine) === null || _a === void 0 ? void 0 : _a.render();
        };
        MapView.prototype.getTextureEnable = function () {
            return this.m_bTextureEnable;
        };
        MapView.prototype.setShadowEnable = function (bEnable) {
            this.m_bShadowEnable = bEnable;
        };
        MapView.prototype.getShadowEnable = function () {
            return this.m_bShadowEnable;
        };
        MapView.prototype.setFeatureZoomRangeEnable = function (bEnable) {
            this.m_bFeatureZoomRangeEnable = bEnable;
        };
        MapView.prototype.getFeatureZoomRangeEnabled = function () {
            return this.m_bFeatureZoomRangeEnable;
        };
        MapView.prototype.setCurNavi = function (navi) {
            this.m_navi = navi;
        };
        MapView.prototype.getCurNavi = function () {
            return this.m_navi;
        };
        MapView.prototype.setDisplayNaviPickMarker = function (bDisplay) {
            this.m_bDisplayNaviPickMarker = bDisplay;
        };
        MapView.prototype.getDisplayNaviPickMarker = function () {
            return this.m_bDisplayNaviPickMarker;
        };
        MapView.prototype.setBrightness = function (brightness) {
            this.m_brightness = brightness;
        };
        MapView.prototype.getBrightness = function () {
            return this.m_brightness;
        };
        MapView.prototype.setSaturation = function (saturaion) {
            this.m_saturation = saturaion;
        };
        MapView.prototype.getSaturation = function () {
            return this.m_saturation;
        };
        MapView.prototype.setContrast = function (contrast) {
            this.m_contrast = contrast;
        };
        MapView.prototype.getContrast = function () {
            return this.m_contrast;
        };
        MapView.prototype.setLowDisplay = function (bLowDisplay) {
            Global.m_bLowDisplay = bLowDisplay;
        };
        MapView.prototype.getLowDisplay = function () {
            return Global.m_bLowDisplay;
        };
        MapView.prototype.render = function () {
            var _a;
            (_a = this._engine) === null || _a === void 0 ? void 0 : _a.render();
        };
        MapView.prototype._drawMultiPlanarGraph = function () {
            return __awaiter(this, void 0, void 0, function () {
                var num_1, engine_1, camera_1, num, showLen, floorArray, i, floorId, planarGraph_1, planarGraph, i, planarGraph;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.currentFloor)
                                return [2];
                            if (this._hasDrawMultiple) {
                                num_1 = this.getFloorHeight(this.currentFloor);
                                engine_1 = this._engine;
                                if (engine_1) {
                                    camera_1 = engine_1.getCamera();
                                    this._animator && this._animator.stop();
                                    this._animator = new Animator();
                                    this._animator.ofNumber(camera_1.getZ(), num_1, 500);
                                    this._animator.easing('easeOutCirc');
                                    this._animator.on('update', function (e) {
                                        camera_1.setZ(e.num);
                                        engine_1.render();
                                    }).on('complete', function () {
                                        delete _this._animator;
                                        if (_this.currentFloor) {
                                            _this._updatePlanarGraphOpacity();
                                            engine_1.updateCollision();
                                        }
                                    }).start();
                                }
                            }
                            num = num || this._floors.length;
                            showLen = Math.min(num, this._floors.length);
                            this.fire('startRender');
                            if (!(this.m_navi && this.m_navi.IsInNaviMode() && this.m_navi._naviMng)) return [3, 6];
                            floorArray = this.m_navi._naviMng.getFloorOrder();
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < floorArray.length)) return [3, 4];
                            floorId = floorArray[i];
                            return [4, this._requestPlanarGraph(floorId)];
                        case 2:
                            planarGraph_1 = _a.sent();
                            this._drawPlanarGraphLayer(floorId, planarGraph_1);
                            _a.label = 3;
                        case 3:
                            i++;
                            return [3, 1];
                        case 4: return [4, this._requestPlanarGraph(this.currentFloor)];
                        case 5:
                            planarGraph = _a.sent();
                            this._drawPlanarGraphLayer(this.currentFloor, planarGraph);
                            return [3, 10];
                        case 6:
                            i = 0;
                            _a.label = 7;
                        case 7:
                            if (!(i < showLen)) return [3, 10];
                            return [4, this._requestPlanarGraph(this._floors[i].flId)];
                        case 8:
                            planarGraph = _a.sent();
                            this._drawPlanarGraphLayer(this._floors[i].flId, planarGraph);
                            _a.label = 9;
                        case 9:
                            i += 1;
                            return [3, 7];
                        case 10:
                            if (this._engine) {
                                this._engine.getCamera().setZ(this.getFloorHeight(this.currentFloor));
                            }
                            this._update(this._floors);
                            this.fire('renderEnd');
                            this._hasDrawMultiple = true;
                            return [2];
                    }
                });
            });
        };
        MapView.prototype.getPlanarGraph = function (floorId) {
            return this._requestPlanarGraph(floorId);
        };
        MapView.prototype.getFloorHeight = function (floorId) {
            var item = this._floorMap.get(floorId);
            var num = item ? (item.altitude === 1 ? 0 : item.altitude) / 5 : 0;
            return num * this._options.floorHeight;
        };
        MapView.prototype.getFloors = function () {
            return this._floors;
        };
        MapView.prototype.setCanDraw = function (bCanDraw) {
            this.m_bCanDraw = bCanDraw;
        };
        MapView.prototype.getCanDraw = function () {
            return this.m_bCanDraw;
        };
        MapView.prototype.OnRenderDataUpdated = function (floorId) {
            if (floorId == null || floorId == undefined) {
                return;
            }
            LogMgr$1.log('MapView.ts OnRenderDataUpdated 1 floorId: ' + floorId);
            this.m_bucketTaskCount--;
            if (floorId == this.m_loadingFloorId
                && this.m_isLoading == true
                && this.m_bucketTaskCount <= 0) {
                this.m_isLoading = false;
                this.m_bucketTaskCount = Math.max(0, this.m_bucketTaskCount);
                this.fire('endReload3d');
            }
            if (this.m_bucketTaskCount <= 0) {
                this.fire('FloorRenderDataEnd', floorId);
                this.m_bCanDraw = true;
            }
        };
        MapView.prototype.Reload3dRenderInfo = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [2];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        MapView.prototype._drawPlanarGraph = function (floorId) {
            return __awaiter(this, void 0, void 0, function () {
                var planarGraph;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._styleMng)
                                return [2];
                            if (this._hasDrawFloorId.has(floorId)) {
                                this.fire('FloorRenderDataStart', floorId);
                                this._update(this._floors);
                                this.fire('FloorRenderDataEnd', floorId);
                                return [2];
                            }
                            return [4, this._requestPlanarGraph(floorId)];
                        case 1:
                            planarGraph = _a.sent();
                            this.fire('startRender');
                            this._drawPlanarGraphLayer(floorId, planarGraph);
                            this._update(this._floors);
                            this.fire('renderEnd');
                            return [2];
                    }
                });
            });
        };
        MapView.prototype._loadFloors = function () {
            return __awaiter(this, void 0, void 0, function () {
                var floors, defaultFloor, i;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this._requestFloors(this._options.buildingId)];
                        case 1:
                            floors = _a.sent();
                            sort(floors, function (a, b) { return a.altitude - b.altitude; });
                            for (i = 0; i < floors.length; i += 1) {
                                if (floors[i].altitude === 0) {
                                    this._outdoorFloor = floors[i];
                                }
                                else {
                                    this._floors.push(floors[i]);
                                    this._floorMap.set(floors[i].flId, floors[i]);
                                }
                                if (floors[i].defaultFloor) {
                                    defaultFloor = floors[i].flId;
                                }
                            }
                            if (!defaultFloor && this._floors.length > 0) {
                                defaultFloor = this._floors[0].flId;
                            }
                            if (!this._defaultFloor) {
                                this._defaultFloor = defaultFloor;
                            }
                            this._floors.sort(function (a, b) { return a.altitude - b.altitude; });
                            this.fire('loadFloors', this._floors);
                            return [2];
                    }
                });
            });
        };
        MapView.prototype._execLoading = function () {
            this._status = 'loading';
            this.fire('loading');
        };
        MapView.prototype._execError = function (err) {
            this._status = 'error';
            this.fire('error', err);
        };
        MapView.prototype._execLoaded = function () {
            this._status = 'loaded';
            this.fire('loaded');
        };
        MapView.prototype.getContainer = function () {
            return this._container;
        };
        MapView.prototype.getCanvasContainer = function () {
            return this._canvasContainer;
        };
        MapView.prototype.getStatus = function () {
            return this._status;
        };
        MapView.prototype.addControl = function (control) {
            this._controls.set(control.getName(), control);
        };
        MapView.prototype.getControl = function (name) {
            return this._controls.get(name);
        };
        MapView.prototype.removeControl = function (name) {
            return this._controls.delete(name);
        };
        MapView.prototype.GetLayers = function () {
            if (this._engine == null || this._engine == undefined) {
                return;
            }
            return this._engine.getLayers().getValues();
        };
        MapView.prototype.validFloorId = function (floorId) {
            return this._floorMap.has(floorId);
        };
        MapView.prototype.queryModelByWorld = function (x, y, layerName) {
            if (!this._engine || !this.currentFloor || !this._styleMng)
                return [];
            var areaStyle = this._styleMng.getStyle('area');
            if (!areaStyle)
                return [];
            var features = [];
            var layers = this._engine.getLayers().getValues();
            for (var i = 0; i < layers.length; i += 1) {
                var floorId = layers[i].getFloorId();
                !layerName || layers[i].getName() === layerName;
                floorId === this.currentFloor || MapView.OUT_REG.test(floorId);
                var type = layers[i].getType();
                if (type === 'Model') {
                    features.push.apply(features, layers[i].queryFeaturesByWorld(x, y));
                }
            }
            features.reverse();
            var result = [];
            for (var i = 0; i < features.length; i += 1) {
                {
                    result.push({
                        feature: features[i],
                        height: StyleUtils.getStyle(areaStyle, 'height', features[i].properties) || 0,
                        dis: features[i].dis,
                    });
                }
            }
            sort(result, function (a, b) { return a.dis - b.dis; });
            return result.map(function (item) { return item.feature; });
        };
        MapView.prototype.queryExtraByWorld = function (x, y, layerName) {
            if (!this._engine || !this.currentFloor || !this._styleMng)
                return [];
            var areaStyle = this._styleMng.getStyle('area');
            if (!areaStyle)
                return [];
            var features = [];
            var layers = this._engine.getLayers().getValues();
            for (var i = 0; i < layers.length; i += 1) {
                var floorId = layers[i].getFloorId();
                var checkName = !layerName || layers[i].getName() === layerName;
                var checkFloor = floorId === this.currentFloor || MapView.OUT_REG.test(floorId);
                var type = layers[i].getType();
                if ((type === 'FillExtrusion') && checkName && checkFloor) {
                    features.push.apply(features, layers[i].queryFeaturesByWorld(x, y));
                }
                else if (type === 'Model') {
                    features.push.apply(features, layers[i].queryFeaturesByWorld(x, y));
                }
            }
            features.reverse();
            var result = [];
            for (var i = 0; i < features.length; i += 1) {
                if (this.IsExtra(features[i]) == true) {
                    result.push({
                        feature: features[i],
                        height: StyleUtils.getStyle(areaStyle, 'height', features[i].properties) || 0,
                    });
                }
            }
            sort(result, function (a, b) { return b.height - a.height; });
            return result.map(function (item) { return item.feature; });
        };
        MapView.prototype.queryFeaturesByName = function (searchString, callBack) {
            return __awaiter(this, void 0, void 0, function () {
                var url, res;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (searchString == null || searchString == undefined) {
                                return [2];
                            }
                            url = this._options.searchServer;
                            return [4, new HttpClient().post(url, {
                                    json: {
                                        'bdId': this.getBdId(),
                                        'keyword': searchString,
                                        'types': [
                                            'shop',
                                            'area'
                                        ]
                                    },
                                })];
                        case 1:
                            res = _a.sent();
                            if (res == null || res == undefined) {
                                return [2];
                            }
                            console.log(res);
                            if (res.data == null || res.data == undefined) {
                                return [2];
                            }
                            callBack(res.data);
                            return [2, res.data];
                    }
                });
            });
        };
        MapView.prototype.queryFeaturesByWorld = function (x, y, layerName) {
            if (!this._engine || !this.currentFloor || !this._styleMng)
                return [];
            var areaStyle = this._styleMng.getStyle('area');
            if (!areaStyle)
                return [];
            var features = [];
            var layers = this._engine.getLayers().getValues();
            for (var i = 0; i < layers.length; i += 1) {
                var floorId = layers[i].getFloorId();
                var checkName = !layerName || layers[i].getName() === layerName;
                var checkFloor = floorId === this.currentFloor || MapView.OUT_REG.test(floorId);
                var type = layers[i].getType();
                if ((type === 'FillExtrusion' || type === 'Fill') && checkName && checkFloor) {
                    features.push.apply(features, layers[i].queryFeaturesByWorld(x, y));
                }
            }
            features.reverse();
            var result = [];
            for (var i = 0; i < features.length; i += 1) {
                result.push({
                    feature: features[i],
                    height: StyleUtils.getStyle(areaStyle, 'height', features[i].properties) || 0,
                });
            }
            sort(result, function (a, b) { return b.height - a.height; });
            return result.map(function (item) { return item.feature; });
        };
        MapView.prototype.queryFeaturesByPoint = function (x, y, layerName) {
            if (!this._engine || !this.currentFloor || !this._styleMng)
                return [];
            var point = this.screenToWorldCoordinate(x, y);
            return this.queryFeaturesByWorld(point.x, point.y, layerName);
        };
        MapView.prototype.queryExtraByPoint = function (x, y, layerName) {
            if (!this._engine || !this.currentFloor || !this._styleMng)
                return [];
            var point = this.screenToWorldCoordinate(x, y);
            return this.queryExtraByWorld(point.x, point.y, layerName);
        };
        MapView.prototype.queryModelByPoint = function (x, y, layerName) {
            if (!this._engine || !this.currentFloor || !this._styleMng)
                return [];
            var point = this.screenToWorldCoordinate(x, y);
            return this.queryModelByWorld(point.x, point.y, layerName);
        };
        MapView.prototype.setBackground = function (background) {
            this._canvasContainer.style.background = background;
        };
        MapView.prototype.setBackgroundColor = function (colorString) {
            this._canvasContainer.style.backgroundColor = colorString;
        };
        MapView.prototype.setBackgroundImg = function (url) {
            this._canvasContainer.style.backgroundImage = "url(" + url + ")";
        };
        MapView.prototype.transformFloorId = function (floorId) {
            if (MapView.OUT_REG.test(floorId)) {
                return floorId.replace(MapView.OUT_REG, 'F01');
            }
            return floorId;
        };
        MapView.prototype.destroy = function () {
            this._engine && this._engine.destroy();
            this._domControls['bottom-left'].remove();
            this._domControls['bottom-right'].remove();
            this._domControls['top-left'].remove();
            this._domControls['top-right'].remove();
            this._canvasContainer.remove();
            if (this._container) {
                this._container.classList.remove('ngr-map');
                delete this._container;
            }
            this._gestureManager.destroy();
            this._reset();
        };
        Object.defineProperty(MapView.prototype, "gestureManager", {
            get: function () {
                return this._gestureManager;
            },
            enumerable: false,
            configurable: true
        });
        MapView.prototype.getStyle = function () {
            return this._styleMng && this._styleMng.getOriginStyle();
        };
        MapView.prototype.getLayout = function (name) {
            return this._styleMng && this._styleMng.getStyle(name);
        };
        MapView.prototype.updateStyle = function (style) {
            return __awaiter(this, void 0, void 0, function () {
                var diff, styleDiff, background, ids, layers, i, isCanAdd, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4, this._styleMng.updateStyle(style)];
                        case 1:
                            diff = _b.sent();
                            styleDiff = new Set(diff);
                            background = this._styleMng.getStyle('mapBackgroundColor');
                            background && this.setBackground(background);
                            if (!(this._viewType === 'single')) return [3, 2];
                            if (!this._engine || !this.currentFloor)
                                return [2];
                            this._hasDrawFloorId.clear();
                            ids = [];
                            ids.push.apply(ids, this._updatePlanarGraphDiff(this.currentFloor, styleDiff));
                            this._hasDrawFloorId.add(this.currentFloor);
                            this._options.enableOutdoor && this._outdoorFloor && ids.push.apply(ids, this._updatePlanarGraphDiff(this._outdoorFloor.flId, styleDiff));
                            this._engine.getBucketMng().normalize(ids);
                            layers = this._outdoorLayers.valuesConcat(this._layers);
                            this._engine.clear();
                            for (i = 0; i < layers.length; i += 1) {
                                layers[i].setGroupId(this.currentFloor);
                                isCanAdd = i < this._outdoorLayers.size() || this._checkIsNeedAdd(layers[i]);
                                isCanAdd && this._engine.addLayer(layers[i]);
                            }
                            this._engine.sortLayer();
                            return [3, 6];
                        case 2:
                            this._hasDrawMultiple = false;
                            this._hasDrawFloorId.clear();
                            this._layers.clear();
                            this._outdoorLayers.clear();
                            _a = this._options.enableOutdoor && this._outdoorFloor;
                            if (!_a) return [3, 4];
                            return [4, this._drawPlanarGraph(this._outdoorFloor.flId)];
                        case 3:
                            _a = (_b.sent());
                            _b.label = 4;
                        case 4:
                            return [4, this._drawMultiPlanarGraph()];
                        case 5:
                            _b.sent();
                            _b.label = 6;
                        case 6: return [2];
                    }
                });
            });
        };
        MapView.prototype.removeFloorPlanarData = function (floorId) {
            if (floorId == null || floorId == undefined) {
                return;
            }
            this._planarGraphMap.delete(floorId);
        };
        MapView.prototype._updatePlanarGraphDiff = function (floorId, styleDiff) {
            var planarGraph = this._planarGraphMap.get(floorId);
            if (!planarGraph)
                return [];
            var isOutdoor = /F00$/.test(floorId);
            var _a = this._filterDiffLayers(isOutdoor ? this._outdoorLayers : this._layers, styleDiff), frameLayers = _a.frameLayers, areaLayers = _a.areaLayers, otherLayers = _a.otherLayers;
            var frame = planarGraph.frame, area = planarGraph.area, shop = planarGraph.shop, facility = planarGraph.facility;
            if (isOutdoor) {
                this._outdoorLayers.clear();
            }
            else {
                this._layers.clear();
            }
            var temp;
            styleDiff.has('frame') && this._drawFrame(frame, floorId);
            styleDiff.has('area') && (temp = this._drawArea(area.concat(shop), floorId));
            styleDiff.has('facility') && this._drawFacility(facility, floorId);
            if (styleDiff.has('areaText')) {
                var textFeatures = temp ? temp.text : DataSource$1.getTextByArea(area.concat(shop));
                this._drawAreaText(textFeatures, floorId);
            }
            if (styleDiff.has('extra')) {
                var extraFeatures = temp ? temp.extra : this._filterExtra(area.concat(shop));
                this._drawExtra(extraFeatures, floorId);
            }
            var outdoorList = this._outdoorLayers.getValues();
            var list = this._layers.getValues();
            var ids = (isOutdoor ? outdoorList : list).map(function (item) { return item.id; });
            if (isOutdoor) {
                var result = frameLayers.concat(outdoorList).concat(areaLayers).concat(otherLayers);
                this._outdoorLayers = new ArraySet(result);
            }
            else {
                var result = frameLayers.concat(list).concat(areaLayers).concat(otherLayers);
                this._layers = new ArraySet(result);
            }
            return ids;
        };
        MapView.prototype._filterExtra = function (features) {
            var result = [];
            for (var i = 0; i < features.length; i += 1) {
                this._styleMng.filterExtra(features[i].properties) && result.push(features[i]);
            }
            return result;
        };
        MapView.prototype._filterDiffLayers = function (layers, styleDiff) {
            var frameLayers = [], areaLayers = [], otherLayers = [];
            for (var i = 0; i < layers.size(); i += 1) {
                var name = layers.get(i).getName();
                if (!MapView.isSelf(name) || !styleDiff.has(name)) {
                    if (name === 'area') {
                        areaLayers.push(layers.get(i));
                    }
                    else if (name === 'frame') {
                        frameLayers.push(layers.get(i));
                    }
                    else {
                        otherLayers.push(layers.get(i));
                    }
                }
            }
            return { frameLayers: frameLayers, areaLayers: areaLayers, otherLayers: otherLayers };
        };
        MapView.prototype._requestFloors = function (bdId) {
            return __awaiter(this, void 0, void 0, function () {
                var res, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.fire('loadFloorStart');
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4, this._res.requestFloors(bdId, 'version' in this._options ? {
                                    version: this._options.version,
                                } : {})];
                        case 2:
                            res = _a.sent();
                            this.fire('loadFloorEnd');
                            return [2, res];
                        case 3:
                            error_1 = _a.sent();
                            this._execError(error_1);
                            this.fire('loadFloorEnd');
                            throw error_1;
                        case 4: return [2];
                    }
                });
            });
        };
        MapView.prototype._requestPlanarGraph = function (floorId) {
            return __awaiter(this, void 0, void 0, function () {
                var planarGraph, res, error_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.fire('loadPlanarGraphStart', floorId);
                            planarGraph = this._planarGraphMap.get(floorId);
                            if (planarGraph)
                                return [2, planarGraph];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4, this._res.requestPlanarGraph(floorId, 'version' in this._options ? {
                                    version: this._options.version,
                                } : {})];
                        case 2:
                            res = _a.sent();
                            this._planarGraphMap.set(floorId, res);
                            this.fire('loadPlanarGraphEnd', floorId);
                            return [2, res];
                        case 3:
                            error_2 = _a.sent();
                            this._execError(error_2);
                            this.fire('loadPlanarGraphEnd', floorId);
                            throw error_2;
                        case 4: return [2];
                    }
                });
            });
        };
        MapView.prototype.setAreaTextVisible = function (visible) {
            this._setVisible('areaText', visible);
        };
        MapView.prototype.setFacilityVisible = function (visible) {
            this._setVisible('facility', visible);
        };
        MapView.prototype._setVisible = function (layerName, visible) {
            var layers = this._outdoorLayers.valuesConcat(this._layers);
            for (var i = 0; i < layers.length; i += 1) {
                if (layers[i].getName() === layerName) {
                    layers[i].setLayout({ visible: visible });
                }
            }
            this._engine && this._engine.updateCollision();
        };
        MapView.prototype.quickSetColorById = function (id, color) {
            if (id == null || id == undefined || color == null || color == undefined) {
                return;
            }
            var layers = this._outdoorLayers.valuesConcat(this._layers);
            for (var i = 0; i < layers.length; i += 1) {
                var type = layers[i].getType();
                if (type === 'Fill' || type === 'FillExtrusion') {
                    var layer = layers[i];
                    layer.QuickUpdateFeatureColor(id, color);
                }
            }
        };
        MapView.prototype.setColorById = function (ids, color) {
            if (ids.length === 0)
                return;
            var values = {};
            for (var i = 0; i < ids.length; i += 1) {
                values[ids[i]] = { fillColor: color };
            }
            var layers = this._outdoorLayers.valuesConcat(this._layers);
            for (var i = 0; i < layers.length; i += 1) {
                var type = layers[i].getType();
                if (type === 'Fill' || type === 'FillExtrusion') {
                    var features = layers[i].getFeatures();
                    var layout = layers[i].getLayout();
                    var keys = __spreadArrays((layout.keys || []));
                    if (keys.indexOf('id') === -1) {
                        keys.unshift('id');
                    }
                    for (var j = 0; j < features.length; j += 1) {
                        var id = (features[j].properties || {}).id;
                        if (values[id]) {
                            layers[i].setLayout({ keys: keys, values: __assign$1(__assign$1({}, layout.values), values) });
                            break;
                        }
                    }
                }
            }
        };
        MapView.prototype.resetColorById = function (ids) {
            var idSet = new Set(ids);
            var layers = this._outdoorLayers.valuesConcat(this._layers);
            for (var i = 0; i < layers.length; i += 1) {
                var type = layers[i].getType();
                if (type === 'Fill' || type === 'FillExtrusion') {
                    var features = layers[i].getFeatures();
                    for (var j = 0; j < features.length; j += 1) {
                        var id = (features[j].properties || {}).id;
                        if (idSet.has(id)) {
                            layers[i].resetLayout();
                            break;
                        }
                    }
                }
            }
        };
        return MapView;
    }(AbstractView));
    var MapView$1 = MapView;

    var Control = (function () {
        function Control(name, options) {
            this._name = name;
            this._options = options;
            this._container = document.createElement('div');
            this._container.classList.add('ngr-control');
        }
        Control.prototype.setStyle = function (styles) {
            for (var key in styles) {
                this._container.style[key] = styles[key];
            }
        };
        Control.prototype.addTo = function (mapView) {
            this._mapView = mapView;
            this._mapView.addControl(this);
            var domControls = this._mapView.getDomControls();
            var position = this._options.position;
            domControls && domControls[position].appendChild(this._container);
        };
        Control.prototype.hide = function () {
            this._container.style.display = 'none';
        };
        Control.prototype.show = function () {
            this._container.style.display = '';
        };
        Control.prototype.getName = function () {
            return this._name;
        };
        Control.prototype.getContainer = function () {
            return this._container;
        };
        Control.prototype.remove = function () {
            this._container.remove();
            this._mapView && this._mapView.removeControl(this._name);
            delete this._mapView;
        };
        return Control;
    }());

    var defaultOptions$b = {
        position: 'bottom-right',
    };
    var ZoomControl = (function (_super) {
        __extends$1(ZoomControl, _super);
        function ZoomControl(options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, 'zoom', __assign$1(__assign$1({}, defaultOptions$b), options)) || this;
            bindAll([
                '_zoomIn',
                '_zoomOut',
                '_onZoomEnd',
            ], _this);
            _this._container.classList.add('ngr-zoom-control');
            _this._zoomInBtn = document.createElement('button');
            _this._zoomInBtn.classList.add('ngr-zoom-in-btn');
            _this._zoomInBtn.classList.add('ngr-click-active');
            if (_this._options.zoomInImg) {
                _this._zoomInBtn.style.backgroundImage = "url(" + _this._options.zoomInImg + ")";
            }
            _this._zoomOutBtn = document.createElement('button');
            _this._zoomOutBtn.classList.add('ngr-zoom-out-btn');
            _this._zoomOutBtn.classList.add('ngr-click-active');
            if (_this._options.zoomOutImg) {
                _this._zoomOutBtn.style.backgroundImage = "url(" + _this._options.zoomOutImg + ")";
            }
            _this._container.appendChild(_this._zoomInBtn);
            _this._container.appendChild(_this._zoomOutBtn);
            _this._zoomInBtn.addEventListener('click', _this._zoomIn);
            _this._zoomOutBtn.addEventListener('click', _this._zoomOut);
            return _this;
        }
        ZoomControl.prototype._zoomIn = function () {
            this._mapView && this._mapView.zoomIn();
        };
        ZoomControl.prototype._zoomOut = function () {
            this._mapView && this._mapView.zoomOut();
        };
        ZoomControl.prototype._onZoomEnd = function () {
            if (!this._mapView)
                return;
            this._zoomInBtn.disabled = true;
            this._zoomOutBtn.disabled = true;
            var maxZoom = this._mapView.getMaxZoom();
            var minZoom = this._mapView.getMinZoom();
            var zoom = this._mapView.getZoom();
            if (zoom <= minZoom) {
                this._zoomInBtn.disabled = false;
            }
            else if (zoom < maxZoom) {
                this._zoomInBtn.disabled = false;
                this._zoomOutBtn.disabled = false;
            }
            else {
                this._zoomOutBtn.disabled = false;
            }
        };
        ZoomControl.prototype.addTo = function (mapView) {
            _super.prototype.addTo.call(this, mapView);
            mapView.on('zoomEnd', this._onZoomEnd);
        };
        ZoomControl.prototype.remove = function () {
            this._zoomInBtn.removeEventListener('click', this._zoomIn);
            this._zoomOutBtn.removeEventListener('click', this._zoomOut);
            if (this._mapView) {
                this._mapView.off('zoomEnd', this._onZoomEnd);
            }
            _super.prototype.remove.call(this);
        };
        return ZoomControl;
    }(Control));

    var defaultOptions$a = {
        position: 'bottom-left',
        duration: 300,
    };
    var FloorControl = (function (_super) {
        __extends$1(FloorControl, _super);
        function FloorControl(options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, 'floor', __assign$1(__assign$1({}, defaultOptions$a), options)) || this;
            _this._floors = [];
            _this._isShow = true;
            _this._initTime = 0;
            _this._itemHeight = 0;
            _this.m_lastAnimEnd = 0;
            _this.m_delayClock = null;
            bindAll([
                '_onGetFloors',
                '_onChangeFloor',
                '_onChangeViewType'
            ], _this);
            _this._options.showMultiple && _this._setupMultiple();
            _this._floorList = document.createElement('ul');
            _this._floorList.classList.add('ngr-floor-list');
            _this._container.appendChild(_this._floorList);
            _this._container.classList.add('ngr-floor-control');
            var activeColor = _this._options.activeColor;
            activeColor && _this._setupCustom(activeColor);
            return _this;
        }
        FloorControl.prototype._onChangeViewType = function () {
            if (!this._mapView || !this._multiDom)
                return;
            if (this._mapView.getViewType() === 'multiple') {
                if (this._options.singleUrl) {
                    this._multiDom.style.backgroundImage = "url(" + this._options.singleUrl + ")";
                }
                else {
                    this._multiDom.classList.remove('ngr-multiple');
                    this._multiDom.classList.add('ngr-single');
                }
            }
            else {
                if (this._options.multipleUrl) {
                    this._multiDom.style.backgroundImage = "url(" + this._options.multipleUrl + ")";
                }
                else {
                    this._multiDom.classList.add('ngr-multiple');
                    this._multiDom.classList.remove('ngr-single');
                }
            }
        };
        FloorControl.prototype._setupMultiple = function () {
            var _this = this;
            this._multiDom = document.createElement('div');
            this._container.style.borderRadius = '0 0 4px 4px';
            this._container.style.background = 'transparent';
            this._multiDom.classList.add('ngr-view-change');
            this._container.appendChild(this._multiDom);
            this._multiDom.addEventListener('click', function () {
                if (!_this._mapView)
                    return;
                var viewType = _this._mapView.getViewType() === 'multiple' ? 'single' : 'multiple';
                _this._mapView.setViewType(viewType);
            });
        };
        FloorControl.prototype._setupCustom = function (activeColor) {
            var style = document.createElement('style');
            var arr = StyleUtils.parseColor(activeColor);
            style.textContent = "\n            .ngr-floor-active {\n                color: " + activeColor + ";\n                border-color: " + activeColor + ";\n                background: rgba(" + arr[0] * 255 + ", " + arr[1] * 255 + ", " + arr[2] * 255 + ", 0.1);\n            }\n            .ngr-floor-active::before {\n                border-left-color: " + activeColor + ";\n            }\n            .ngr-floor-active::after {\n                border-right-color: " + activeColor + ";\n            }\n        ";
            document.head.appendChild(style);
        };
        FloorControl.prototype.setLocationManager = function (locationMng) {
            this._locationMng = locationMng;
        };
        FloorControl.prototype.removeLocationManager = function () {
            delete this._locationMng;
        };
        FloorControl.prototype.addTo = function (mapView) {
            _super.prototype.addTo.call(this, mapView);
            mapView.on('loadFloors', this._onGetFloors);
            mapView.on('changeFloor', this._onChangeFloor);
            mapView.on('changeViewType', this._onChangeViewType);
            this._onChangeViewType();
        };
        FloorControl.prototype.remove = function () {
            if (this._mapView) {
                this._mapView.off('loadFloors', this._onGetFloors);
                this._mapView.off('changeFloor', this._onChangeFloor);
                this._mapView.off('changeViewType', this._onChangeViewType);
            }
            _super.prototype.remove.call(this);
        };
        FloorControl.prototype._onChangeFloor = function (floorId) {
            return __awaiter(this, void 0, void 0, function () {
                var children, i, liDom, index, i, liDom;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(Date.now() - this._initTime < 500)) return [3, 2];
                            return [4, sleep(500)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            children = this._floorList.children;
                            if (!this._isShow) {
                                for (i = 0; i < this._floors.length; i += 1) {
                                    if (this._floors[i].flId === floorId) {
                                        liDom = children[0];
                                        liDom.textContent = this._floors[i].floorAddress;
                                        liDom.dataset.flId = floorId;
                                        return [2];
                                    }
                                }
                            }
                            index = 0;
                            for (i = 0; i < children.length; i += 1) {
                                liDom = children[i];
                                liDom.classList.remove('ngr-floor-active');
                                if (liDom.dataset.flId === floorId) {
                                    index = i;
                                    liDom.classList.add('ngr-floor-active');
                                }
                            }
                            this._animateScrollByIndex(index);
                            return [2];
                    }
                });
            });
        };
        FloorControl.prototype.show = function () {
            this._isShow = true;
            this._createFloorItem(this._floors);
            this._mapView &&
                this._mapView.currentFloor &&
                this._onChangeFloor(this._mapView.currentFloor);
            if (this._multiDom) {
                this._multiDom.style.display = '';
            }
        };
        FloorControl.prototype.hide = function () {
            var _this = this;
            if (this._mapView == null || this._mapView == undefined) {
                return;
            }
            this._isShow = false;
            var curFloor = this._mapView.currentFloor;
            if (curFloor == null || curFloor == undefined) {
                curFloor = this._mapView.getDefaultFloor();
            }
            var filterRes = this._floors.filter(function (item) {
                return _this._mapView && item.flId === curFloor;
            });
            this._createFloorItem(filterRes);
            if (this._multiDom) {
                this._multiDom.style.display = 'none';
            }
        };
        FloorControl.prototype.setOnlyDisplayCurFloor = function (bOnlyDisplayCurFloor) {
        };
        FloorControl.prototype._animateScrollByIndex = function (index) {
            var _this = this;
            if (this._floorList.children.length === 0)
                return;
            if (this._animator) {
                this._animator.stop();
                delete this._animator;
                this._animator = null;
                this._floorList.scrollTop = this.m_lastAnimEnd;
            }
            if (this._itemHeight === 0) {
                var floorItem = this._floorList.children[0];
                this._itemHeight = floorItem.getBoundingClientRect().height;
            }
            var start = this._floorList.scrollTop;
            var end = this._itemHeight * (index - 1);
            this.m_lastAnimEnd = end;
            end = end < 0 ? 0 : end;
            if (start === end)
                return;
            this._animator = new Animator().ofNumber(start, end, this._options.duration);
            this._animator.on('update', function (e) {
                _this._floorList.scrollTop = e.num;
            }).on('complete', function () {
                delete _this._animator;
                _this._animator = null;
            }).start();
        };
        FloorControl.prototype._onGetFloors = function (floors) {
            this._floors = Array.from(floors);
            this._floors.sort(function (a, b) { return b.altitude - a.altitude; });
            this._createFloorItem(this._floors);
            this._initTime = Date.now();
            if (this._isShow == false) {
                this.hide();
            }
        };
        FloorControl.prototype._createFloorItem = function (floors) {
            var _this = this;
            this._floorList.innerHTML = '';
            var _loop_1 = function (i) {
                var liDom = document.createElement('li');
                liDom.classList.add('ngr-floor-item');
                this_1._mapView &&
                    this_1._mapView.currentFloor === floors[i].flId &&
                    liDom.classList.add('ngr-floor-active');
                liDom.classList.add('ngr-click-active');
                liDom.textContent = floors[i].floorAddress === 'F0' ? '鍏ㄩ櫌' : floors[i].floorAddress;
                liDom.dataset.flId = floors[i].flId;
                liDom.addEventListener('click', function () {
                    if (_this.m_delayClock) {
                        clearTimeout(_this.m_delayClock);
                        _this.m_delayClock = null;
                    }
                    var locationMgr = _this._locationMng;
                    var mapView = _this._mapView;
                    var tempLiDom = liDom;
                    _this.m_delayClock = setTimeout(function () {
                        if (locationMgr) {
                            locationMgr.setAutoChangeFloor(false);
                        }
                        if (mapView) {
                            console.log('鐐瑰嚮浜嗘ゼ灞傛帶浠�');
                            mapView.OnClick2d3d();
                            tempLiDom.dataset.flId && mapView.setCurrentFloor(tempLiDom.dataset.flId);
                        }
                    }, 350);
                });
                this_1._floorList.appendChild(liDom);
            };
            var this_1 = this;
            for (var i = 0; i < floors.length; i += 1) {
                _loop_1(i);
            }
        };
        return FloorControl;
    }(Control));

    var defaultOptions$9 = {
        position: 'top-left',
    };
    var CompassControl = (function (_super) {
        __extends$1(CompassControl, _super);
        function CompassControl(options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, 'compass', __assign$1(__assign$1({}, defaultOptions$9), options)) || this;
            bindAll([
                '_onRotate',
            ], _this);
            _this._container.classList.add('ngr-compass-control');
            if (_this._options.imgUrl) {
                _this._container.style.backgroundImage = "url(" + _this._options.imgUrl + ")";
            }
            _this._container.addEventListener('click', function () {
                if (!_this._mapView || _this._options.isIgnoreRest)
                    return;
                var duration = Math.abs(_this._mapView.getRotate() || 0) / 100 * 1000;
                _this._mapView.easeTo({ rotate: 0, duration: duration });
            });
            return _this;
        }
        CompassControl.prototype.addTo = function (mapView) {
            _super.prototype.addTo.call(this, mapView);
            mapView.on('rotate', this._onRotate);
            mapView.once('init', this._onRotate);
        };
        CompassControl.prototype.remove = function () {
            if (!this._mapView)
                return;
            this._mapView.off('rotate', this._onRotate);
            _super.prototype.remove.call(this);
        };
        CompassControl.prototype._onRotate = function () {
            if (!this._mapView)
                return;
            var rotate = this._mapView.getRotate();
            this._container.style.transform = "rotateZ(" + -rotate + "deg)";
        };
        return CompassControl;
    }(Control));

    var defaultOptions$8 = {
        position: 'bottom-left',
    };
    var ViewControl = (function (_super) {
        __extends$1(ViewControl, _super);
        function ViewControl(options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, 'view', __assign$1(__assign$1({}, defaultOptions$8), options)) || this;
            _this._is3D = false;
            bindAll([
                '_onPitchEnd',
                '_onClick',
            ], _this);
            _this._container.classList.add('ngr-view-control');
            _this._container.classList.add('ngr-click-active');
            _this._container.classList.add('ngr-view-3d');
            _this._container.addEventListener('click', _this._onClick);
            return _this;
        }
        ViewControl.prototype.addTo = function (mapView) {
            _super.prototype.addTo.call(this, mapView);
            mapView.on('pitchEnd', this._onPitchEnd);
            mapView.once('init', this._onPitchEnd);
            this._onPitchEnd();
        };
        ViewControl.prototype.remove = function () {
            if (this._mapView) {
                this._mapView.off('pitchEnd', this._onPitchEnd);
            }
            this._container.removeEventListener('click', this._onClick);
            _super.prototype.remove.call(this);
        };
        ViewControl.prototype._onClick = function () {
            if (!this._mapView)
                return;
            console.log('OnClick 2d3d btn');
            this._mapView.OnClick2d3d();
            var bOnly2d = this._mapView.getPitch() < 1;
            if (bOnly2d) {
                this._mapView.easeTo({ pitch: 60 });
                this._mapView.setOnly2d(false);
                this._mapView.Reload3dRenderInfo();
                this._container.classList.remove('ngr-view-2d');
                this._container.classList.add('ngr-view-3d');
                this.setDisplayStyle(true);
            }
            else {
                this._container.classList.remove('ngr-view-3d');
                this._container.classList.add('ngr-view-2d');
                this._mapView.easeTo({ pitch: 0 });
                this._mapView.setOnly2d(true);
                this._mapView.Reload3dRenderInfo();
                this.setDisplayStyle(false);
            }
        };
        ViewControl.prototype.setDisplayStyle = function (b3dBtn) {
            if (b3dBtn == false) {
                this._is3D = false;
                if (this._options.img3D) {
                    this._container.style.backgroundImage = "url(" + this._options.img3D + ")";
                }
                else {
                    this._container.textContent = '3D';
                }
            }
            else {
                this._is3D = true;
                if (this._options.img2D) {
                    this._container.style.backgroundImage = "url(" + this._options.img2D + ")";
                }
                else {
                    this._container.textContent = '2D';
                }
            }
        };
        ViewControl.prototype._onPitchEnd = function () {
            if (!this._mapView)
                return;
            var bOnly2d = this._mapView.getPitch() < 1;
            if (bOnly2d) {
                if (this._options.img3D) {
                    this._container.style.backgroundImage = "url(" + this._options.img3D + ")";
                }
                else {
                    this._container.textContent = '3D';
                }
            }
            else {
                if (this._options.img2D) {
                    this._container.style.backgroundImage = "url(" + this._options.img2D + ")";
                }
                else {
                    this._container.textContent = '2D';
                }
            }
            return;
        };
        return ViewControl;
    }(Control));

    var defaultOptions$7 = {
        maxWidth: 100,
        isShowLogo: true,
        showScaleTime: 800,
        position: 'bottom-left',
    };
    var ScaleControl = (function (_super) {
        __extends$1(ScaleControl, _super);
        function ScaleControl(options) {
            if (options === void 0) { options = {}; }
            var _this = this;
            var opts = __assign$1(__assign$1({}, defaultOptions$7), options);
            _this = _super.call(this, 'scale', opts) || this;
            bindAll([
                '_onMove',
            ], _this);
            _this._container.classList.add('ngr-scale-control');
            _this._scale = document.createElement('div');
            _this._scale.classList.add('ngr-scale');
            _this._container.appendChild(_this._scale);
            if (_this._options.isShowLogo) {
                _this._logoDom = document.createElement('div');
                _this._logoDom.className = 'ngr-logo';
                if (_this._options.logoUrl) {
                    _this._logoDom.style.backgroundImage = "url(" + _this._options.logoUrl + ")";
                }
                _this._container.appendChild(_this._logoDom);
            }
            return _this;
        }
        ScaleControl.prototype.addTo = function (mapView) {
            _super.prototype.addTo.call(this, mapView);
            mapView.on('move', this._onMove);
            mapView.once('init', this._onMove);
            this._onMove();
        };
        ScaleControl.prototype._onMove = function () {
            var _this = this;
            this._toggleLogo(false);
            this._calculateScale();
            if (this._options.isShowLogo) {
                this._showLogoTimer && clearTimeout(this._showLogoTimer);
                this._showLogoTimer = window.setTimeout(function () {
                    _this._toggleLogo(true);
                }, this._options.showScaleTime);
            }
        };
        ScaleControl.prototype._calculateScale = function () {
            if (!this._mapView)
                return;
            var camera = this._mapView.getCamera();
            if (!camera)
                return;
            var onePixelToWorld = camera.getOnePixelToWorld();
            var maxMeter = this._options.maxWidth * onePixelToWorld;
            var meter = ScaleControl.getRoundNum(maxMeter);
            var scaleWidth = meter / maxMeter * this._options.maxWidth;
            this._scale.textContent = meter + "m";
            this._scale.style.width = scaleWidth + "px";
        };
        ScaleControl.prototype._toggleLogo = function (isShowLogo) {
            if (this._logoDom) {
                this._logoDom.style.display = isShowLogo ? '' : 'none';
            }
            this._scale.style.display = isShowLogo ? 'none' : '';
        };
        ScaleControl.getRoundNum = function (num) {
            var pow10 = Math.pow(10, (("" + Math.floor(num)).length - 1));
            var d = num / pow10;
            if (d >= 10) {
                d = 10;
            }
            else if (d >= 5) {
                d = 5;
            }
            else if (d >= 3) {
                d = 3;
            }
            else if (d >= 2) {
                d = 2;
            }
            else {
                d = 1;
            }
            return pow10 * d;
        };
        return ScaleControl;
    }(Control));

    var defaultOptions$6 = {
        position: 'bottom-left',
        duration: 500,
    };
    var LocateControl = (function (_super) {
        __extends$1(LocateControl, _super);
        function LocateControl(options) {
            var _this = _super.call(this, 'location', __assign$1(__assign$1({}, defaultOptions$6), options)) || this;
            _this._locateStatus = 'normal';
            bindAll([
                '_onClick',
                '_onLocationSuccess',
                '_onMove',
            ], _this);
            _this._container.classList.add('ngr-locate-control');
            _this._container.classList.add('ngr-click-active');
            if (_this._options.normalImg) {
                _this._container.style.backgroundImage = "url(" + _this._options.normalImg + ")";
            }
            _this._container.addEventListener('click', _this._onClick);
            return _this;
        }
        LocateControl.prototype._onClick = function () {
            return __awaiter(this, void 0, void 0, function () {
                var locationPosition, floorId, coordinate;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._locationMng || !this._mapView) {
                                console.error('LocationManager is required');
                                return [2];
                            }
                            if (!this._locationMng.hasPosition())
                                return [2];
                            this._locationMng.setAutoChangeFloor(true);
                            locationPosition = this._locationMng.getPosition();
                            if (!locationPosition)
                                return [2];
                            floorId = locationPosition.floorId, coordinate = locationPosition.coordinate;
                            if (!(floorId !== this._mapView.currentFloor)) return [3, 2];
                            return [4, this._mapView.setCurrentFloor(floorId)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            switch (this._locateStatus) {
                                case 'normal':
                                    this._mapView.easeTo({
                                        center: coordinate,
                                        duration: this._options.duration,
                                    });
                                    this._locateStatus = 'center';
                                    this._container.style.backgroundImage = '';
                                    if (this._options.centerImg) {
                                        this._container.style.backgroundImage = "url(" + this._options.centerImg + ")";
                                    }
                                    else {
                                        this._container.classList.remove('ngr-locate-3d');
                                        this._container.classList.add('ngr-locate-center');
                                    }
                                    break;
                                case 'center':
                                    this._mapView.easeTo({
                                        rotate: (this._locationMng.getRotate()),
                                        pitch: 60,
                                    });
                                    this._locateStatus = '3d';
                                    this._container.style.backgroundImage = '';
                                    if (this._options.img3D) {
                                        this._container.style.backgroundImage = "url(" + this._options.img3D + ")";
                                    }
                                    else {
                                        this._container.classList.remove('ngr-locate-center');
                                        this._container.classList.add('ngr-locate-3d');
                                    }
                                    break;
                                case '3d':
                                    this._mapView.easeTo({
                                        rotate: 0,
                                        pitch: 0,
                                    });
                                    this._locateStatus = 'normal';
                                    this._container.style.backgroundImage = '';
                                    if (this._options.activeImg) {
                                        this._container.style.backgroundImage = "url(" + this._options.activeImg + ")";
                                    }
                                    else {
                                        this._container.classList.remove('ngr-locate-3d');
                                        this._container.classList.remove('ngr-locate-center');
                                    }
                                    break;
                            }
                            return [2];
                    }
                });
            });
        };
        LocateControl.prototype._onLocationSuccess = function () {
            this._container.style.backgroundImage = '';
            if (this._options.activeImg) {
                this._container.style.backgroundImage = "url(" + this._options.activeImg + ")";
            }
            else {
                this._container.classList.add('ngr-locate-success');
            }
        };
        LocateControl.prototype._onMove = function () {
            this._locateStatus = 'normal';
            this._container.classList.remove('ngr-locate-3d');
            this._container.classList.remove('ngr-locate-center');
        };
        LocateControl.prototype.addTo = function (mapView) {
            _super.prototype.addTo.call(this, mapView);
            mapView.on('touchstart', this._onMove);
        };
        LocateControl.prototype.remove = function () {
            if (this._mapView) {
                this._mapView.off('touchstart', this._onMove);
            }
            if (this._locationMng) {
                this._locationMng.off('locationSuccess', this._onLocationSuccess);
            }
            _super.prototype.remove.call(this);
        };
        LocateControl.prototype.setLocationManager = function (locationMng) {
            this._locationMng = locationMng;
            this._locationMng.on('locationSuccess', this._onLocationSuccess);
        };
        return LocateControl;
    }(Control));

    var defaultOptions$5 = {
        position: 'top-right',
    };
    var FullscreenControl = (function (_super) {
        __extends$1(FullscreenControl, _super);
        function FullscreenControl(options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, 'fullscreen', __assign$1(__assign$1({}, defaultOptions$5), options)) || this;
            bindAll([
                '_onFullscreenchange',
                '_onClick',
            ], _this);
            _this._container.classList.add('ngr-fullscreen-control');
            _this._container.classList.add('ngr-click-active');
            document.addEventListener('fullscreenchange', _this._onFullscreenchange);
            document.addEventListener('webkitfullscreenchange', _this._onFullscreenchange);
            document.addEventListener('mozfullscreenchange', _this._onFullscreenchange);
            _this._container.addEventListener('click', _this._onClick);
            _this._onFullscreenchange();
            return _this;
        }
        FullscreenControl.prototype._onClick = function () {
            if (!this._mapView)
                return;
            var isFullscreen = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
            if (isFullscreen) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                }
                else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
            else {
                var container = this._mapView.getContainer();
                if (!container)
                    return;
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                }
                else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                }
                else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                }
                else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
            }
        };
        FullscreenControl.prototype._onFullscreenchange = function () {
            var isFullscreen = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
            if (isFullscreen) {
                if (this._options.notFullUrl) {
                    this._container.style.backgroundImage = "url(" + this._options.notFullUrl + ")";
                }
                else {
                    this._container.classList.add('ngr-not-full');
                    this._container.classList.remove('ngr-full');
                }
            }
            else {
                if (this._options.fullUrl) {
                    this._container.style.backgroundImage = "url(" + this._options.fullUrl + ")";
                }
                else {
                    this._container.classList.remove('ngr-not-full');
                    this._container.classList.add('ngr-full');
                }
            }
        };
        FullscreenControl.prototype.remove = function () {
            _super.prototype.remove.call(this);
            this._container.removeEventListener('click', this._onClick);
            document.removeEventListener('fullscreenchange', this._onFullscreenchange);
            document.removeEventListener('webkitfullscreenchange', this._onFullscreenchange);
            document.removeEventListener('mozfullscreenchange', this._onFullscreenchange);
        };
        return FullscreenControl;
    }(Control));

    var defaultOptions$4 = {
        anchor: 'center',
    };
    var MarkerAnchor = {
        top: 'translate(-50%, 0)',
        center: 'translate(-50%, -50%)',
        bottom: 'translate(-50%, -100%)',
        'top-left': 'translate(0, 0)',
        'top-right': 'translate(-100%, 0)',
        'bottom-left': 'translate(0, -100%)',
        'bottom-right': 'translate(-100%, -100%)',
        left: 'translate(0, -50%)',
        right: 'translate(-100%, -50%)',
    };
    var Marker = (function (_super) {
        __extends$1(Marker, _super);
        function Marker(dom, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this._rotate = 0;
            _this._alwaysShow = false;
            _this._isShow = true;
            bindAll([
                '_update',
                '_updateStyle',
                '_dragstart',
                '_drag',
                '_dragend',
            ], _this);
            _this._options = __assign$1(__assign$1({}, defaultOptions$4), options);
            _this._container = document.createElement('div');
            _this._setupContainer();
            _this._dom = dom;
            _this._container.appendChild(_this._dom);
            return _this;
        }
        Marker.prototype.setProperties = function (properties) {
            this._properties = properties;
        };
        Marker.prototype.getProperties = function () {
            return this._properties;
        };
        Marker.prototype._setupContainer = function () {
            this._container.classList.add('ngr-marker');
            if (!this._options.draggable) {
                this._container.addEventListener('touchstart', Marker.touchHandle);
                this._container.addEventListener('touchend', Marker.touchHandle);
                this._container.addEventListener('touchmove', Marker.touchHandle);
            }
        };
        Marker.touchHandle = function (e) {
            e.stopPropagation();
        };
        Marker.prototype._dragstart = function (e) {
            var originEvent = e.getOriginEvent();
            var target = originEvent.target;
            if (!this._mapView || !this._container.contains(target))
                return;
            var check;
            var startPoint = e.getScreen();
            if (originEvent instanceof MouseEvent) {
                check = originEvent.which === 1;
            }
            else {
                check = originEvent.touches.length === 1;
            }
            if (!check)
                return;
            this._startPoint = startPoint;
            this._mapView.gestureManager.disableDrag();
            this._mapView.on('mousemove', this._drag);
            this._mapView.on('mouseup', this._dragend);
            this._mapView.on('mouseleave', this._dragend);
            this._mapView.on('touchmove', this._drag);
            this._mapView.on('touchend', this._dragend);
            this.fire('dragstart', e);
        };
        Marker.prototype._drag = function (e) {
            if (!this._mapView || !this._startPoint || !this._screen)
                return;
            var point = new Point(e.getScreen().x, e.getScreen().y);
            var delta = point.clone().subtract(this._startPoint);
            this._screen.add(delta);
            this._updateStyle();
            this._startPoint = point;
            this.fire('drag', e);
        };
        Marker.prototype._dragend = function (e) {
            if (!this._mapView || !this._startPoint || !this._screen)
                return;
            var camera = this._mapView.getCamera();
            if (!camera)
                return;
            this._mapView.gestureManager.enableDrag();
            this._coordinate = camera.screenToWorldCoordinate(this._screen.x, this._screen.y);
            this._mapView.off('mousemove', this._drag);
            this._mapView.off('mouseup', this._dragend);
            this._mapView.off('mouseleave', this._dragend);
            this._mapView.off('touchmove', this._drag);
            this._mapView.off('touchend', this._dragend);
            this.fire('dragend', e);
        };
        Marker.prototype.setAlwaysShow = function (alwaysShow) {
            this._alwaysShow = alwaysShow;
            this._update();
        };
        Marker.prototype.getAlwaysShow = function () {
            return this._alwaysShow;
        };
        Marker.prototype.addTo = function (mapView) {
            this._mapView = mapView;
            this._mapView.on('move', this._update);
            this._mapView.on('changeFloor', this._update);
            if (this._options.rotateWidthMap) {
                this._mapView.on('rotate', this._updateStyle);
            }
            if (this._options.pitchWidthMap) {
                this._mapView.on('pitch', this._updateStyle);
            }
            if (this._options.draggable) {
                this._mapView.on('mousedown', this._dragstart);
                this._mapView.on('touchstart', this._dragstart);
            }
            this._update();
        };
        Marker.prototype._updateStyle = function () {
            if (!this._screen || !this._mapView)
                return;
            var _a = this._screen, x = _a.x, y = _a.y;
            var pitch = 0;
            if (this._options.pitchWidthMap) {
                pitch = this._mapView.getPitch() || 0;
            }
            var rotate = this._rotate;
            if (this._options.rotateWidthMap) {
                rotate = this._rotate - (this._mapView.getRotate() || 0);
            }
            this._container.style.transform = MarkerAnchor[this._options.anchor] + " translate(" + x + "px, " + y + "px) rotateX(" + pitch + "deg) rotateZ(" + rotate + "deg)";
        };
        Marker.prototype.setRotate = function (rotate, isUpdateStyle) {
            if (isUpdateStyle === void 0) { isUpdateStyle = true; }
            this._rotate = rotate;
            isUpdateStyle && this._updateStyle();
        };
        Marker.prototype.getContainer = function () {
            return this._container;
        };
        Marker.prototype._addDom = function () {
            if (!this._mapView)
                return;
            this._mapView.getCanvasContainer().appendChild(this._container);
        };
        Marker.prototype.setPosition = function (floorId, coordinate) {
            this._floorId = floorId;
            this._coordinate = new Point(coordinate.x, coordinate.y);
            this._update();
        };
        Marker.prototype._checkNeedUpdate = function (floorId, coordinate) {
            var floorCheck = !this._floorId || this._floorId !== floorId;
            var coordCheck = !equalCoordinate(this._coordinate, coordinate);
            return floorCheck || coordCheck;
        };
        Marker.prototype._update = function () {
            if (!this._mapView || !this._coordinate || !this._floorId || !this._isShow) {
                this._container.remove();
                return;
            }
            var bInNaviMode = false;
            if (this._mapView && this._mapView.m_navi && this._mapView.m_navi.IsInNaviMode()) {
                bInNaviMode = true;
            }
            if ((bInNaviMode == true && this._mapView.getViewType() == 'multiple')
                || this._mapView.currentFloor === this._floorId
                || this._alwaysShow) {
                !this._container.parentElement && this._addDom();
                var engine = this._mapView.getEngine();
                if (!engine)
                    return;
                var camera = engine.getCamera();
                var bNeedZHeight = false;
                if (this._mapView.getViewType() == 'multiple') {
                    bNeedZHeight = true;
                }
                var zHeight = this._mapView.getFloorHeight(this._floorId);
                if (bNeedZHeight == true) {
                    this._screen = camera.worldToScreenCoordinate2(this._coordinate.x, this._coordinate.y, zHeight);
                }
                else {
                    this._screen = camera.worldToScreenCoordinate(this._coordinate.x, this._coordinate.y);
                }
                this._updateStyle();
            }
            else {
                this._container.remove();
            }
        };
        Marker.prototype.show = function () {
            if (this._isShow)
                return;
            this._isShow = true;
            this._update();
        };
        Marker.prototype.hide = function () {
            if (!this._isShow)
                return;
            this._isShow = false;
            this._update();
        };
        Marker.prototype.updateDom = function (dom) {
            this._dom.remove();
            this._container.appendChild(dom);
            this._dom = dom;
        };
        Marker.prototype.getDom = function () {
            return this._dom;
        };
        Marker.prototype.getPosition = function () {
            if (this._floorId && this._coordinate) {
                return {
                    floorId: this._floorId,
                    coordinate: this._coordinate && this._coordinate.clone(),
                };
            }
            return {
                floorId: '',
                coordinate: new Point(0, 0),
            };
        };
        Marker.prototype.remove = function () {
            this._container.remove();
            if (this._mapView) {
                this._mapView.off('move', this._update);
                this._mapView.off('changeFloor', this._update);
                this._mapView.off('pitch', this._updateStyle);
                this._mapView.off('rotate', this._updateStyle);
                this._mapView.off('mousedown', this._dragstart);
                this._mapView.off('touchstart', this._dragstart);
                delete this._mapView;
            }
        };
        return Marker;
    }(NCore$1));

    var CanvasMarker = (function (_super) {
        __extends$1(CanvasMarker, _super);
        function CanvasMarker(options) {
            var _this = _super.call(this) || this;
            bindAll([
                '_dragstart',
                '_drag',
                '_dragend',
                '_onclick',
                '_frameUpdate',
                'click',
                '_click'
            ], _this);
            _this._options = options;
            _this._layer = new SymbolLayer(CanvasMarker.getLayoutFromOptions(options));
            if (_this._options.draggable) {
                _this._layer.on('mousedown', _this._dragstart);
                _this._layer.on('touchstart', _this._dragstart);
            }
            else {
                _this._layer.on('click', _this._click);
            }
            return _this;
        }
        CanvasMarker.prototype.setProperties = function (properties) {
            this._properties = properties;
        };
        CanvasMarker.prototype.getProperties = function () {
            return this._properties;
        };
        CanvasMarker.prototype.getLayer = function () {
            return this._layer;
        };
        CanvasMarker.prototype.setIgnoreMultiFade = function (flag) {
            this._layer.setIgnoreMultiFade(flag);
        };
        CanvasMarker.prototype.getIgnoreMultiFade = function () {
            return this._layer.getIgnoreMultiFade();
        };
        CanvasMarker.prototype.setLayout = function (options) {
            this._options = options;
            this._layer.setLayout(CanvasMarker.getLayoutFromOptions(options));
        };
        CanvasMarker.prototype.setAlwaysShow = function (alwaysShow) {
            this._layer.setAlwaysShow(alwaysShow);
            this._mapView && this._mapView.updateLayer(this._layer);
        };
        CanvasMarker.prototype.getAlwaysShow = function () {
            return this._layer.getAlwaysShow();
        };
        CanvasMarker.prototype.setPosition = function (floorId, coordinate) {
            this._layer.setFloorId(floorId);
            this._coordinate = new Point(coordinate.x, coordinate.y);
            this._layer.setFeatures([{
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [coordinate.x, coordinate.y],
                    },
                    properties: {},
                    featureid: '',
                }]);
            this._mapView && this._mapView.updateLayer(this._layer);
        };
        CanvasMarker.prototype._checkIsNeedUpdate = function (floorId, coordinate) {
            var oldFloor = this._layer.getFloorId();
            var floorCheck = !oldFloor || oldFloor !== floorId;
            var coordCheck = !equalCoordinate(this._coordinate, coordinate);
            return floorCheck || coordCheck;
        };
        CanvasMarker.prototype.getPosition = function () {
            var floorId = this._layer.getFloorId();
            if (floorId && this._coordinate) {
                return {
                    floorId: floorId,
                    coordinate: this._coordinate && this._coordinate.clone(),
                };
            }
            return {
                floorId: '',
                coordinate: new Point(0, 0),
            };
        };
        CanvasMarker.prototype.addTo = function (mapView) {
            if (this._mapView)
                return;
            this._mapView = mapView;
            this._mapView.addLayer(this._layer);
        };
        CanvasMarker.prototype.remove = function () {
            this._layer.off('mousedown', this._dragstart);
            if (!this._mapView)
                return;
            this._mapView.removeLayer(this._layer);
            delete this._mapView;
        };
        CanvasMarker.prototype._click = function (e) {
            console.log('鐐瑰嚮浜� canvas marker');
            this.fire('click', e.e);
        };
        CanvasMarker.prototype._dragstart = function (_a) {
            var e = _a.e;
            e.cancel();
            var originEvent = e.getOriginEvent();
            if (!this._mapView)
                return;
            var check;
            if (originEvent instanceof MouseEvent) {
                check = originEvent.which === 1;
            }
            else {
                check = originEvent.touches.length === 1;
            }
            if (!check)
                return;
            this._startWorld = e.getWorld();
            this._mapView.gestureManager.disableDrag();
            this._mapView.on('mousemove', this._drag);
            this._mapView.on('mouseup', this._dragend);
            this._mapView.on('mouseleave', this._dragend);
            this._mapView.on('touchmove', this._drag);
            this._mapView.on('touchend', this._dragend);
            this.fire('dragstart', e);
            this._startFrameUpdate();
        };
        CanvasMarker.prototype._drag = function (e) {
            this._dragEvent = e;
        };
        CanvasMarker.prototype._dragend = function (e) {
            this._stopFrameUpdate();
            if (!this._mapView || !this._startWorld)
                return;
            this._mapView.gestureManager.enableDrag();
            delete this._startWorld;
            this._mapView.off('mousemove', this._drag);
            this._mapView.off('mouseup', this._dragend);
            this._mapView.off('mouseleave', this._dragend);
            this._mapView.off('touchmove', this._drag);
            this._mapView.off('touchend', this._dragend);
            this.fire('dragend', e);
        };
        CanvasMarker.prototype._startFrameUpdate = function () {
            if (this._updateTimer)
                return;
            this._frameUpdate();
        };
        CanvasMarker.prototype._frameUpdate = function () {
            if (this._startWorld && this._dragEvent) {
                var delta = this._dragEvent.world.clone().subtract(this._startWorld);
                var floorId = this._layer.getFloorId();
                if (this._coordinate && floorId) {
                    this.setPosition(floorId, this._coordinate.clone().add(delta));
                }
                this._startWorld = this._dragEvent.world;
                this.fire('drag', this._dragEvent);
            }
            this._updateTimer = requestAnimationFrame(this._frameUpdate);
        };
        CanvasMarker.prototype._stopFrameUpdate = function () {
            if (this._updateTimer) {
                cancelAnimationFrame(this._updateTimer);
                delete this._updateTimer;
            }
            delete this._dragEvent;
        };
        CanvasMarker.getLayoutFromOptions = function (options) {
            var layout = __assign$1({}, options);
            delete layout.draggable;
            return layout;
        };
        return CanvasMarker;
    }(NCore$1));

    var LiftMarker = (function (_super) {
        __extends$1(LiftMarker, _super);
        function LiftMarker(dom, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, dom, options) || this;
            _this.m_liftPos = new Point3(0, 0, 0);
            return _this;
        }
        LiftMarker.prototype.setPosition2 = function (pos) {
            this.m_liftPos = pos;
            this._update();
        };
        LiftMarker.prototype.forceUpdate = function () {
            this._update();
        };
        LiftMarker.prototype._update = function () {
            {
                !this._container.parentElement && this._addDom();
                var engine = this._mapView.getEngine();
                if (!engine)
                    return;
                var camera = engine.getCamera();
                this._screen = camera.worldToScreenCoordinate2(this.m_liftPos.x, this.m_liftPos.y, this.m_liftPos.z);
                this._updateStyle();
            }
        };
        LiftMarker.prototype.setIconUrl = function (iconUrl) {
            this.m_iconUrl = iconUrl;
            var img = document.createElement('img');
            img.setAttribute('src', iconUrl);
            this._container.appendChild(img);
        };
        LiftMarker.prototype._updateStyle = function () {
            var engine = this._mapView.getEngine();
            if (!engine)
                return;
            var camera = engine.getCamera();
            this._screen = camera.worldToScreenCoordinate2(this.m_liftPos.x, this.m_liftPos.y, this.m_liftPos.z);
            _super.prototype._updateStyle.call(this);
        };
        LiftMarker.prototype.addTo = function (mapView) {
            this._mapView = mapView;
            this._mapView.on('move', this._update);
            this._mapView.on('changeFloor', this._update);
            if (this._options.rotateWidthMap) {
                this._mapView.on('rotate', this._updateStyle);
            }
            if (this._options.pitchWidthMap) {
                this._mapView.on('pitch', this._updateStyle);
            }
            if (this._options.draggable) {
                this._mapView.on('mousedown', this._dragstart);
                this._mapView.on('touchstart', this._dragstart);
            }
            this._update();
        };
        return LiftMarker;
    }(Marker));

    var LineBuffer = (function (_super) {
        __extends$1(LineBuffer, _super);
        function LineBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this.indicesNum = 0;
            _this._texture = _this._gl.createTexture();
            _this._indicesBuffer = _this._gl.createBuffer();
            _this._normalsBuffer = _this._gl.createBuffer();
            _this._verticesBuffer = _this._gl.createBuffer();
            _this._deviationBuffer = _this._gl.createBuffer();
            _this._texCoordsBuffer = _this._gl.createBuffer();
            return _this;
        }
        LineBuffer.prototype.clear = function () {
            if (this._indicesBuffer) {
                this._gl.deleteBuffer(this._indicesBuffer);
                this._indicesBuffer = null;
            }
            if (this._normalsBuffer) {
                this._gl.deleteBuffer(this._normalsBuffer);
                this._normalsBuffer = null;
            }
            if (this._verticesBuffer) {
                this._gl.deleteBuffer(this._verticesBuffer);
                this._verticesBuffer = null;
            }
            if (this._deviationBuffer) {
                this._gl.deleteBuffer(this._deviationBuffer);
                this._deviationBuffer = null;
            }
            if (this._texCoordsBuffer) {
                this._gl.deleteBuffer(this._texCoordsBuffer);
                this._texCoordsBuffer = null;
            }
        };
        LineBuffer.prototype.update = function (data) {
            var vertices = data.vertices, normals = data.normals, indices = data.indices, texture = data.texture, texCoords = data.texCoords, deviation = data.deviation;
            this._texture = texture;
            this._initArrayBuffer(this._texCoordsBuffer, texCoords);
            this._initIndexBuffer(this._indicesBuffer, indices);
            this._initArrayBuffer(this._verticesBuffer, vertices);
            this._initArrayBuffer(this._normalsBuffer, normals);
            this._initArrayBuffer(this._deviationBuffer, deviation);
            this.indicesNum = indices.length;
        };
        LineBuffer.prototype.bind = function (params) {
            var a_position = params.a_position, a_normal = params.a_normal, a_texCoord = params.a_texCoord, a_deviation = params.a_deviation;
            this._vertexAttribPointer(a_position, this._verticesBuffer, 2);
            this._vertexAttribPointer(a_normal, this._normalsBuffer, 2);
            this._vertexAttribPointer(a_deviation, this._deviationBuffer, 3);
            this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
            this._vertexAttribPointer(a_texCoord, this._texCoordsBuffer, 2);
            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        };
        return LineBuffer;
    }(AbstractBuffer));

    var LineLayer = (function (_super) {
        __extends$1(LineLayer, _super);
        function LineLayer(layout) {
            var _this = _super.call(this, 'Line', __assign$1(__assign$1({}, LineLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._geometryRenderList = [];
            _this._loadPromiseSet = new Set();
            _this.m_bGray = false;
            return _this;
        }
        LineLayer.prototype.clear = function () {
            LogMgr$1.log('LineLayer.ts clear 1');
            this._features.length = 0;
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                this._geometryRenderList[i];
            }
            this._geometryRenderList.length = 0;
        };
        LineLayer.prototype.SetGray = function (bGray) {
            this.m_bGray = bGray;
        };
        LineLayer.prototype._updateRenderList = function (data) {
            if (!this._engine)
                return;
            this._geometryRenderList.length = 0;
            var textureMng = this._engine.getTextureMng();
            var info = data.info;
            for (var i = 0; i < info.length; i += 1) {
                var buffer = new LineBuffer(this._engine.getGl());
                var texture = textureMng.getEmptyTexture(), imgSize = [0, 0];
                var iconUrl = info[i].iconUrl;
                if (iconUrl) {
                    var item = textureMng.getTexture(iconUrl, LineLayer.TEXTURE_PARAMS);
                    if (item) {
                        texture = item.texture;
                        imgSize = [item.width, item.height];
                    }
                }
                buffer.update({
                    vertices: info[i].vertices,
                    texCoords: info[i].texCoords,
                    normals: info[i].normals,
                    texture: texture,
                    deviation: info[i].deviation,
                    indices: info[i].indices,
                });
                this._geometryRenderList.push({
                    buffer: buffer,
                    lineColor: info[i].color,
                    base: info[i].base,
                    opacity: info[i].opacity,
                    useTexture: Boolean(iconUrl),
                    lineWidth: info[i].width,
                    imgSize: imgSize,
                    bGray: this.m_bGray,
                });
            }
        };
        LineLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        LineLayer.prototype.queryFeaturesByWorld = function (x, y) {
            if (!this._engine)
                return [];
            var onePixelToWorld = this._engine.getCamera().getOnePixelToWorld();
            return linesContain(this._layout, this._features, { x: x, y: y }, onePixelToWorld);
        };
        LineLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        LineLayer.prototype._update = function () {
            var _this = this;
            if (!this._engine)
                return;
            for (var i = 0; i < this._features.length; i += 1) {
                this._calcPolyline(this._features[i]);
            }
            var bucketMng = this._engine.getBucketMng();
            var bOnly2d = this._engine.getMapView().getOnly2d();
            var bTextureEnable = this._engine.getMapView().getTextureEnable();
            var data = {
                id: this.id,
                type: 'line',
                features: this._features,
                layout: this._layout,
                offset: this._engine.getOffset(),
                taskId: this._getTaskId(),
                sync: this.getSync(),
                hideCategoryIdArray: [],
                hideColorIdArray: [],
                bOnly2d: bOnly2d,
                bCutFeature: false,
                chartletTable: [],
                bTextureEnable: bTextureEnable,
            };
            if (this._loadPromiseSet.size === 0) {
                bucketMng.update(data);
            }
            else {
                new Promise(function (resolve) {
                    Promise.all(_this._loadPromiseSet).then(resolve).catch(resolve);
                }).then(function () {
                    bucketMng.update(data);
                });
            }
        };
        LineLayer.prototype._calcPolyline = function (feature) {
            var _this = this;
            if (!this._engine)
                return;
            var textureMng = this._engine.getTextureMng();
            var lineImage = StyleUtils.getStyle(this._layout, 'lineImage', feature.properties);
            if (lineImage) {
                var tempTexture = textureMng.getTexture(lineImage, LineLayer.TEXTURE_PARAMS);
                if (!tempTexture) {
                    var promise_1 = textureMng.loadTexture(lineImage, LineLayer.TEXTURE_PARAMS);
                    this._loadPromiseSet.add(promise_1);
                    promise_1.then(function () { return _this._loadPromiseSet.delete(promise_1); });
                }
            }
        };
        LineLayer.TEXTURE_PARAMS = { xRepeat: true, yRepeat: true };
        LineLayer.DEFAULT_LAYOUT = {
            visible: true,
            lineWidth: 10,
            opacity: 1,
            base: 0,
            lineColor: '#666666',
        };
        return LineLayer;
    }(AbstractLayer));

    var TrackBuffer = (function (_super) {
        __extends$1(TrackBuffer, _super);
        function TrackBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this.indicesNum = 0;
            _this._verticesBuffer = _this._gl.createBuffer();
            _this._indicesBuffer = _this._gl.createBuffer();
            return _this;
        }
        TrackBuffer.prototype.clear = function () {
            if (this._verticesBuffer) {
                this._gl.deleteBuffer(this._verticesBuffer);
                this._verticesBuffer = null;
            }
            if (this._indicesBuffer) {
                this._gl.deleteBuffer(this._indicesBuffer);
                this._indicesBuffer = null;
            }
        };
        TrackBuffer.prototype.update = function (data) {
            var vertices = data.vertices, indices = data.indices;
            this.indicesNum = indices.length;
            this._initArrayBuffer(this._verticesBuffer, vertices);
            this._initIndexBuffer(this._indicesBuffer, indices);
        };
        TrackBuffer.prototype.bind = function (a_position) {
            this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
            this._vertexAttribPointer(a_position, this._verticesBuffer, 2);
        };
        return TrackBuffer;
    }(AbstractBuffer));

    var TrackLayer = (function (_super) {
        __extends$1(TrackLayer, _super);
        function TrackLayer(layout) {
            var _this = _super.call(this, 'Track', __assign$1(__assign$1({}, TrackLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._geometryRenderList = [];
            return _this;
        }
        TrackLayer.prototype.clear = function () {
            this._features.length = 0;
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                this._geometryRenderList[i];
            }
            this._geometryRenderList.length = 0;
        };
        TrackLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        TrackLayer.prototype.queryFeaturesByWorld = function (x, y) {
            if (!this._engine)
                return [];
            var onePixelToWorld = this._engine.getCamera().getOnePixelToWorld();
            return linesContain(this._layout, this._features, { x: x, y: y }, onePixelToWorld);
        };
        TrackLayer.prototype._updateRenderList = function (e) {
            if (!this._engine)
                return;
            this._geometryRenderList.length = 0;
            var info = e.info;
            for (var i = 0; i < info.length; i += 1) {
                var buffer = new TrackBuffer(this._engine.getGl());
                buffer.update({
                    vertices: info[i].vertices,
                    indices: info[i].indices,
                });
                this._geometryRenderList.push({
                    buffer: buffer,
                    color: info[i].color,
                    base: info[i].base,
                    opacity: info[i].opacity,
                });
            }
        };
        TrackLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        TrackLayer.prototype._update = function () {
            if (!this._engine)
                return;
            var bOnly2d = this._engine.getMapView().getOnly2d();
            var bTextureEnable = this._engine.getMapView().getTextureEnable();
            var data = {
                id: this.id,
                features: this._features,
                layout: this._layout,
                type: 'track',
                offset: this._engine.getOffset(),
                taskId: this._getTaskId(),
                sync: this.getSync(),
                hideCategoryIdArray: [],
                hideColorIdArray: [],
                bOnly2d: bOnly2d,
                bCutFeature: false,
                chartletTable: [],
                bTextureEnable: bTextureEnable,
            };
            var bucketMng = this._engine.getBucketMng();
            bucketMng.update(data);
        };
        TrackLayer.GEOMETRY_KEYS = ['color', 'base'];
        TrackLayer.DEFAULT_LAYOUT = {
            visible: true,
            base: 0,
            opacity: 1,
            color: '#333333',
        };
        return TrackLayer;
    }(AbstractLayer));

    var ModelBuffer = (function (_super) {
        __extends$1(ModelBuffer, _super);
        function ModelBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this.verticesNum = 0;
            _this._verticesBuffer = gl.createBuffer();
            _this._normalsBuffer = gl.createBuffer();
            _this._texture = gl.createTexture();
            _this._texCoordsBuffer = gl.createBuffer();
            return _this;
        }
        ModelBuffer.prototype.clear = function () {
            if (this._verticesBuffer) {
                this._gl.deleteBuffer(this._verticesBuffer);
                this._verticesBuffer = null;
            }
            if (this._normalsBuffer) {
                this._gl.deleteBuffer(this._normalsBuffer);
                this._normalsBuffer = null;
            }
            if (this._texCoordsBuffer) {
                this._gl.deleteBuffer(this._texCoordsBuffer);
                this._texCoordsBuffer = null;
            }
        };
        ModelBuffer.prototype.update = function (data) {
            var vertices = data.vertices, normals = data.normals, texCoords = data.texCoords, map = data.map, texture = data.texture;
            this.verticesNum = vertices.length / 3;
            this._initArrayBuffer(this._verticesBuffer, vertices);
            this._initArrayBuffer(this._normalsBuffer, normals);
            this._initArrayBuffer(this._texCoordsBuffer, texCoords);
            if (map) {
                this._texture = this._gl.createTexture();
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
                this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, map);
            }
            else {
                this._texture = texture;
            }
        };
        ModelBuffer.prototype.bind = function (a_position, a_texCoord, a_normal) {
            this._vertexAttribPointer(a_position, this._verticesBuffer, 3);
            this._vertexAttribPointer(a_texCoord, this._texCoordsBuffer, 2);
            this._vertexAttribPointer(a_normal, this._normalsBuffer, 3);
            this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
        };
        return ModelBuffer;
    }(AbstractBuffer));

    var OBJLoader = (function () {
        function OBJLoader(url) {
            var _this = this;
            this._mtlPromiseSet = new Set();
            this._materialMap = new Map();
            this._vertices = [];
            this._normals = [];
            this._texCoords = [];
            this._faces = new Map();
            this._drawInfoList = [];
            var arr = url.split('/');
            this._path = arr.slice(0, -1).join('/');
            bindAll([
                '_generateDrawInfo',
            ], this);
            var curTime = Date.now();
            LogMgr$1.log('寮€濮嬩笅杞芥ā鍨嬶紙鍖呮嫭瑙ｆ瀽妯″瀷鏂囦欢.obj,mtl锛�: ' + url);
            this._loadPromise = this._parseObj(url);
            this._loadPromise.then(function () {
                delete _this._loadPromise;
                LogMgr$1.log('妯″瀷鍔犺浇缁撴潫: ' + url);
                var curTime2 = Date.now();
                LogMgr$1.log('鑺辫垂鏃堕棿: ' + (curTime2 - curTime));
            });
        }
        OBJLoader.prototype.getDrawInfoList = function () {
            return this._drawInfoList;
        };
        OBJLoader.prototype._parseObj = function (url) {
            return __awaiter(this, void 0, void 0, function () {
                var curTime1, str, arr, curMtl, i, trimStr, promise, curTime2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            curTime1 = Date.now();
                            LogMgr$1.log('妯″瀷宸蹭笅杞藉畬鎴愶紝寮€濮嬭В鏋� .obj 鏂囦欢骞剁敓鎴愭覆鏌撶敤鏁版嵁: ' + url);
                            return [4, new HttpClient().get(url)];
                        case 1:
                            str = _a.sent();
                            arr = str.split('\n');
                            for (i = 0; i < arr.length; i += 1) {
                                trimStr = arr[i].trim();
                                if (/^mtllib /.test(trimStr)) {
                                    promise = this._parseMtl(this._path + "/" + trimStr.split(' ')[1]);
                                    this._mtlPromiseSet.add(promise);
                                }
                                if (/^usemtl /.test(trimStr)) {
                                    curMtl = trimStr.split(' ')[1];
                                }
                                this._parseLineData(trimStr, curMtl);
                            }
                            return [4, Promise.all(this._mtlPromiseSet)];
                        case 2:
                            _a.sent();
                            this._generateDrawInfo();
                            curTime2 = Date.now();
                            LogMgr$1.log('妯″瀷娓叉煋鏁版嵁鐢熸垚瀹屾垚: ' + url);
                            LogMgr$1.log('鑺辫垂鏃堕棿: ' + (curTime2 - curTime1));
                            return [2];
                    }
                });
            });
        };
        OBJLoader.prototype._parseMtl = function (url) {
            return __awaiter(this, void 0, void 0, function () {
                var str, arr, itemName, _loop_1, this_1, i;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, new HttpClient().get(url)];
                        case 1:
                            str = _a.sent();
                            arr = str.split('\n');
                            itemName = 'material';
                            _loop_1 = function (i) {
                                var itemStr, itemMaterial, tempArr, color, url_1, img_1;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            itemStr = arr[i].trim();
                                            itemMaterial = this_1._materialMap.get(itemName);
                                            if (/^newmtl /.test(itemStr)) {
                                                itemName = itemStr.split(' ')[1];
                                            }
                                            if (/^Kd /.test(itemStr)) {
                                                tempArr = itemStr.split(' ');
                                                color = [Number(tempArr[1]), Number(tempArr[2]), Number(tempArr[3]), 1];
                                                if (itemMaterial) {
                                                    itemMaterial.color = color;
                                                }
                                                else {
                                                    this_1._materialMap.set(itemName, {
                                                        color: color,
                                                    });
                                                }
                                            }
                                            if (!/^map_Kd /.test(itemStr)) return [3, 2];
                                            url_1 = itemStr.split(' ')[1];
                                            img_1 = new Image();
                                            img_1.src = this_1._path + "/" + url_1;
                                            img_1.crossOrigin = 'anonymous';
                                            return [4, new Promise(function (resolve, reject) {
                                                    img_1.onload = function () {
                                                        resolve();
                                                    };
                                                    img_1.onerror = function () {
                                                        reject();
                                                    };
                                                })];
                                        case 1:
                                            _a.sent();
                                            if (itemMaterial) {
                                                itemMaterial.map = img_1;
                                            }
                                            else {
                                                this_1._materialMap.set(itemName, {
                                                    color: [0, 0, 0, 1],
                                                    map: img_1,
                                                });
                                            }
                                            _a.label = 2;
                                        case 2: return [2];
                                    }
                                });
                            };
                            this_1 = this;
                            i = 0;
                            _a.label = 2;
                        case 2:
                            if (!(i < arr.length)) return [3, 5];
                            return [5, _loop_1(i)];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4:
                            i += 1;
                            return [3, 2];
                        case 5: return [2];
                    }
                });
            });
        };
        OBJLoader.prototype._generateDrawInfo = function () {
            var _this = this;
            this._faces.forEach(function (value, key) {
                var material = _this._materialMap.get(key);
                if (!material)
                    return;
                var vertices = [];
                var normals = [];
                var texCoords = [];
                for (var i = 0; i < value.length; i += 1) {
                    var data = _this._parseFace(value[i]);
                    vertices.push.apply(vertices, data.vertices);
                    normals.push.apply(normals, data.normals);
                    texCoords.push.apply(texCoords, data.texCoords);
                }
                _this._drawInfoList.push({
                    vertices: vertices,
                    normals: normals,
                    texCoords: texCoords,
                    color: material.color,
                    map: material.map,
                });
            });
        };
        OBJLoader.prototype._parseLineData = function (itemStr, curMtl) {
            if (/^v /.test(itemStr)) {
                var m = itemStr.split(' ');
                var v = [Number(m[m.length - 3]), Number(m[m.length - 2]), Number(m[m.length - 1])];
                this._vertices.push(v);
            }
            if (/^vn /.test(itemStr)) {
                var m = itemStr.split(' ');
                var vn = [Number(m[m.length - 3]), Number(m[m.length - 2]), Number(m[m.length - 1])];
                this._normals.push(vn);
            }
            if (/^vt /.test(itemStr)) {
                var m = itemStr.split(' ');
                var vt = [Number(m[m.length - 2]), Number(m[m.length - 1])];
                this._texCoords.push(vt);
            }
            if (/^f /.test(itemStr) && curMtl) {
                var m = itemStr.split(' ');
                var resultArr = [];
                for (var i = 1; i < m.length; i += 1) {
                    if (m[i]) {
                        var _a = m[i].split('/'), v = _a[0], vt = _a[1], vn = _a[2];
                        var itemArr = [];
                        var vNum = Number(v);
                        if (vNum < 0) {
                            vNum = this._vertices.length + vNum;
                        }
                        else {
                            vNum -= 1;
                        }
                        itemArr.push(vNum);
                        var vtNum = -1;
                        if (vt) {
                            vtNum = Number(vt);
                            if (vtNum < 0) {
                                vtNum = this._texCoords.length + vtNum;
                            }
                            else {
                                vtNum -= 1;
                            }
                        }
                        itemArr.push(vtNum);
                        var vnNum = -1;
                        if (vn) {
                            vnNum = Number(vn);
                            if (vnNum < 0) {
                                vnNum = this._texCoords.length + vnNum;
                            }
                            else {
                                vnNum -= 1;
                            }
                        }
                        itemArr.push(vnNum);
                        resultArr.push(itemArr);
                    }
                }
                var arr = this._faces.get(curMtl);
                if (arr) {
                    arr.push(resultArr);
                }
                else {
                    this._faces.set(curMtl, [resultArr]);
                }
            }
        };
        OBJLoader.prototype._parseFace = function (arr) {
            var vertices = [];
            var texCoords = [];
            var normals = [];
            for (var i = 0; i < arr.length; i += 1) {
                var _a = arr[i], v = _a[0], vt = _a[1], vn = _a[2];
                vertices.push.apply(vertices, this._vertices[v]);
                if (!this._normals[vn]) {
                    normals.push(1, 1, 1);
                }
                else {
                    normals.push.apply(normals, this._normals[vn]);
                }
                if (!this._texCoords[vt]) {
                    texCoords.push(0, 0, 0);
                }
                else {
                    texCoords.push.apply(texCoords, this._texCoords[vt]);
                }
            }
            return { vertices: vertices, normals: normals, texCoords: texCoords };
        };
        OBJLoader.prototype.loaded = function () {
            return !Boolean(this._loadPromise);
        };
        OBJLoader.prototype.getLoadPromise = function () {
            return this._loadPromise;
        };
        return OBJLoader;
    }());

    var AAALoader = (function (_super) {
        __extends$1(AAALoader, _super);
        function AAALoader(url) {
            return _super.call(this, url) || this;
        }
        AAALoader.prototype.Uint8ArrayToString = function (data) {
            var dataString = '';
            for (var i = 0; i < data.length; i++) {
                dataString += String.fromCharCode(data[i]);
            }
            return dataString;
        };
        AAALoader.prototype.hex2float = function (num) {
            var sign = (num & 0x80000000) ? -1 : 1;
            var exponent = ((num >> 23) & 0xff) - 127;
            var mantissa = 1 + ((num & 0x7fffff) / 0x7fffff);
            return sign * mantissa * Math.pow(2, exponent);
        };
        AAALoader.prototype._parseObj = function (url) {
            return __awaiter(this, void 0, void 0, function () {
                var curTime1, buffer, curOffset, mtlLength, strMtl, i, mtlPath, vertexCount, i, int32_v1, v1_float, int32_v2, v2_float, int32_v3, v3_float, v, vertexCoordCount, i, int32_v1, v1_float, int32_v2, v2_float, v, normalCount, i, int32_v1, v1_float, int32_v2, v2_float, int32_v3, v3_float, v, faceCount, i, strMaterialLength, strMtl_1, i_1, faceMtlPath, faceCount_1, j, int32_v1, int32_v2, int32_v3, int32_v4, int32_v5, int32_v6, int32_v7, int32_v8, int32_v9, itemArr, resultArr, arr, promise, curTime2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            curTime1 = Date.now();
                            LogMgr$1.log('妯″瀷宸蹭笅杞藉畬鎴愶紝寮€濮嬭В鏋� .obj 鏂囦欢骞剁敓鎴愭覆鏌撶敤鏁版嵁: ' + url);
                            return [4, new HttpClient().get(url, { responseType: "arraybuffer" })];
                        case 1:
                            buffer = _a.sent();
                            buffer = new Uint8Array(buffer);
                            LogMgr$1.log('鏀跺埌.aaa鏂囦欢锛岄暱搴︼細' + buffer.length);
                            curOffset = 0;
                            mtlLength = Number(buffer[0]) + Number(buffer[1]) * 255 + Number(buffer[2]) * 255 * 255 + Number(buffer[3]) * 255 * 255 * 255;
                            curOffset += 4;
                            strMtl = [];
                            for (i = 0; i < mtlLength; i++) {
                                strMtl.push(buffer[curOffset + i]);
                            }
                            mtlPath = this.Uint8ArrayToString(strMtl);
                            curOffset += mtlLength;
                            vertexCount = buffer[curOffset + 0] + buffer[curOffset + 1] * 256 + buffer[curOffset + 2] * 256 * 256 + buffer[curOffset + 3] * 256 * 256 * 256;
                            curOffset += 4;
                            for (i = 0; i < vertexCount; i += 3) {
                                int32_v1 = buffer[curOffset + i * 4 + 0]
                                    + buffer[curOffset + i * 4 + 1] * 256
                                    + buffer[curOffset + i * 4 + 2] * 256 * 256
                                    + buffer[curOffset + i * 4 + 3] * 256 * 256 * 256;
                                v1_float = this.hex2float(int32_v1);
                                int32_v2 = buffer[curOffset + i * 4 + 4]
                                    + buffer[curOffset + i * 4 + 5] * 256
                                    + buffer[curOffset + i * 4 + 6] * 256 * 256
                                    + buffer[curOffset + i * 4 + 7] * 256 * 256 * 256;
                                v2_float = this.hex2float(int32_v2);
                                int32_v3 = buffer[curOffset + i * 4 + 8]
                                    + buffer[curOffset + i * 4 + 9] * 256
                                    + buffer[curOffset + i * 4 + 10] * 256 * 256
                                    + buffer[curOffset + i * 4 + 11] * 256 * 256 * 256;
                                v3_float = this.hex2float(int32_v3);
                                v = [v1_float, v2_float, v3_float];
                                this._vertices.push(v);
                            }
                            curOffset += vertexCount * 4;
                            vertexCoordCount = buffer[curOffset + 0] + buffer[curOffset + 1] * 256 + buffer[curOffset + 2] * 256 * 256 + buffer[curOffset + 3] * 256 * 256 * 256;
                            curOffset += 4;
                            for (i = 0; i < vertexCoordCount; i += 2) {
                                int32_v1 = buffer[curOffset + i * 4 + 0]
                                    + buffer[curOffset + i * 4 + 1] * 256
                                    + buffer[curOffset + i * 4 + 2] * 256 * 256
                                    + buffer[curOffset + i * 4 + 3] * 256 * 256 * 256;
                                v1_float = this.hex2float(int32_v1);
                                int32_v2 = buffer[curOffset + i * 4 + 4]
                                    + buffer[curOffset + i * 4 + 5] * 256
                                    + buffer[curOffset + i * 4 + 6] * 256 * 256
                                    + buffer[curOffset + i * 4 + 7] * 256 * 256 * 256;
                                v2_float = this.hex2float(int32_v2);
                                v = [v1_float, v2_float];
                                this._texCoords.push(v);
                            }
                            curOffset += vertexCoordCount * 4;
                            normalCount = buffer[curOffset + 0] + buffer[curOffset + 1] * 256 + buffer[curOffset + 2] * 256 * 256 + buffer[curOffset + 3] * 256 * 256 * 256;
                            curOffset += 4;
                            for (i = 0; i < normalCount; i += 3) {
                                int32_v1 = buffer[curOffset + i * 4 + 0]
                                    + buffer[curOffset + i * 4 + 1] * 256
                                    + buffer[curOffset + i * 4 + 2] * 256 * 256
                                    + buffer[curOffset + i * 4 + 3] * 256 * 256 * 256;
                                v1_float = this.hex2float(int32_v1);
                                int32_v2 = buffer[curOffset + i * 4 + 4]
                                    + buffer[curOffset + i * 4 + 5] * 256
                                    + buffer[curOffset + i * 4 + 6] * 256 * 256
                                    + buffer[curOffset + i * 4 + 7] * 256 * 256 * 256;
                                v2_float = this.hex2float(int32_v2);
                                int32_v3 = buffer[curOffset + i * 4 + 4]
                                    + buffer[curOffset + i * 4 + 5] * 256
                                    + buffer[curOffset + i * 4 + 6] * 256 * 256
                                    + buffer[curOffset + i * 4 + 7] * 256 * 256 * 256;
                                v3_float = this.hex2float(int32_v3);
                                v = [v1_float, v2_float, v3_float];
                                this._normals.push(v);
                            }
                            curOffset += normalCount * 4;
                            faceCount = buffer[curOffset + 0] + buffer[curOffset + 1] * 256 + buffer[curOffset + 2] * 256 * 256 + buffer[curOffset + 3] * 256 * 256 * 256;
                            curOffset += 4;
                            for (i = 0; i < faceCount; i++) {
                                strMaterialLength = buffer[curOffset + 0] + buffer[curOffset + 1] * 256 + buffer[curOffset + 2] * 256 * 256 + buffer[curOffset + 3] * 256 * 256 * 256;
                                curOffset += 4;
                                strMtl_1 = [];
                                for (i_1 = 0; i_1 < strMaterialLength; i_1++) {
                                    strMtl_1.push(buffer[curOffset + i_1]);
                                }
                                faceMtlPath = this.Uint8ArrayToString(strMtl_1);
                                faceMtlPath = faceMtlPath.split(' ')[1];
                                curOffset += strMaterialLength;
                                faceCount_1 = buffer[curOffset + 0] + buffer[curOffset + 1] * 256 + buffer[curOffset + 2] * 256 * 256 + buffer[curOffset + 3] * 256 * 256 * 256;
                                curOffset += 4;
                                for (j = 0; j < faceCount_1; j += 9) {
                                    int32_v1 = buffer[curOffset + j * 4 + 0]
                                        + buffer[curOffset + j * 4 + 1] * 256
                                        + buffer[curOffset + j * 4 + 2] * 256 * 256
                                        + buffer[curOffset + j * 4 + 3] * 256 * 256 * 256;
                                    int32_v2 = buffer[curOffset + j * 4 + 4]
                                        + buffer[curOffset + j * 4 + 5] * 256
                                        + buffer[curOffset + j * 4 + 6] * 256 * 256
                                        + buffer[curOffset + j * 4 + 7] * 256 * 256 * 256;
                                    int32_v3 = buffer[curOffset + j * 4 + 8]
                                        + buffer[curOffset + j * 4 + 9] * 256
                                        + buffer[curOffset + j * 4 + 10] * 256 * 256
                                        + buffer[curOffset + j * 4 + 11] * 256 * 256 * 256;
                                    int32_v4 = buffer[curOffset + j * 4 + 12]
                                        + buffer[curOffset + j * 4 + 13] * 256
                                        + buffer[curOffset + j * 4 + 14] * 256 * 256
                                        + buffer[curOffset + j * 4 + 15] * 256 * 256 * 256;
                                    int32_v5 = buffer[curOffset + j * 4 + 16]
                                        + buffer[curOffset + j * 4 + 17] * 256
                                        + buffer[curOffset + j * 4 + 18] * 256 * 256
                                        + buffer[curOffset + j * 4 + 19] * 256 * 256 * 256;
                                    int32_v6 = buffer[curOffset + j * 4 + 20]
                                        + buffer[curOffset + j * 4 + 21] * 256
                                        + buffer[curOffset + j * 4 + 22] * 256 * 256
                                        + buffer[curOffset + j * 4 + 23] * 256 * 256 * 256;
                                    int32_v7 = buffer[curOffset + j * 4 + 24]
                                        + buffer[curOffset + j * 4 + 25] * 256
                                        + buffer[curOffset + j * 4 + 26] * 256 * 256
                                        + buffer[curOffset + j * 4 + 27] * 256 * 256 * 256;
                                    int32_v8 = buffer[curOffset + j * 4 + 28]
                                        + buffer[curOffset + j * 4 + 29] * 256
                                        + buffer[curOffset + j * 4 + 30] * 256 * 256
                                        + buffer[curOffset + j * 4 + 31] * 256 * 256 * 256;
                                    int32_v9 = buffer[curOffset + j * 4 + 32]
                                        + buffer[curOffset + j * 4 + 33] * 256
                                        + buffer[curOffset + j * 4 + 34] * 256 * 256
                                        + buffer[curOffset + j * 4 + 35] * 256 * 256 * 256;
                                    itemArr = [];
                                    resultArr = [];
                                    itemArr.push(this.ProcessVertexIndex(int32_v1));
                                    itemArr.push(this.ProcessTexCoordIndex(int32_v2));
                                    itemArr.push(this.ProcessNormalIndex(int32_v3));
                                    resultArr.push(itemArr);
                                    itemArr = [];
                                    itemArr.push(this.ProcessVertexIndex(int32_v4));
                                    itemArr.push(this.ProcessTexCoordIndex(int32_v5));
                                    itemArr.push(this.ProcessNormalIndex(int32_v6));
                                    resultArr.push(itemArr);
                                    itemArr = [];
                                    itemArr.push(this.ProcessVertexIndex(int32_v7));
                                    itemArr.push(this.ProcessTexCoordIndex(int32_v8));
                                    itemArr.push(this.ProcessNormalIndex(int32_v9));
                                    resultArr.push(itemArr);
                                    arr = this._faces.get(faceMtlPath);
                                    if (arr) {
                                        arr.push(resultArr);
                                    }
                                    else {
                                        this._faces.set(faceMtlPath, [resultArr]);
                                    }
                                }
                                curOffset += faceCount_1 * 4;
                            }
                            promise = this._parseMtl(this._path + "/" + mtlPath.split(' ')[1]);
                            this._mtlPromiseSet.add(promise);
                            return [4, Promise.all(this._mtlPromiseSet)];
                        case 2:
                            _a.sent();
                            LogMgr$1.log('妯″瀷宸蹭笅杞藉畬鎴愶紝寮€濮嬭В鏋� .obj 鏂囦欢骞剁敓鎴愭覆鏌撶敤鏁版嵁: ' + url);
                            this._generateDrawInfo();
                            curTime2 = Date.now();
                            LogMgr$1.log('妯″瀷娓叉煋鏁版嵁鐢熸垚瀹屾垚: ' + url);
                            LogMgr$1.log('鑺辫垂鏃堕棿: ' + (curTime2 - curTime1));
                            return [2];
                    }
                });
            });
        };
        AAALoader.prototype.ProcessVertexIndex = function (index) {
            if (index == 0xffffffff) {
                return -1;
            }
            var vNum = Number(index);
            if (vNum < 0) {
                vNum = this._vertices.length + vNum;
            }
            else {
                vNum -= 1;
            }
            return vNum;
        };
        AAALoader.prototype.ProcessTexCoordIndex = function (index) {
            if (index == 0xffffffff) {
                return -1;
            }
            var vtNum = -1;
            if (index) {
                vtNum = Number(index);
                if (vtNum < 0) {
                    vtNum = this._texCoords.length + vtNum;
                }
                else {
                    vtNum -= 1;
                }
            }
            return vtNum;
        };
        AAALoader.prototype.ProcessNormalIndex = function (index) {
            if (index == 0xffffffff) {
                return -1;
            }
            var vnNum = -1;
            if (index) {
                vnNum = Number(index);
                if (vnNum < 0) {
                    vnNum = this._texCoords.length + vnNum;
                }
                else {
                    vnNum -= 1;
                }
            }
            return vnNum;
        };
        return AAALoader;
    }(OBJLoader));

    var ModelLayer = (function (_super) {
        __extends$1(ModelLayer, _super);
        function ModelLayer(layout) {
            var _this = _super.call(this, 'Model', __assign$1(__assign$1({}, ModelLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._loadPromiseSet = new Set();
            _this._geometryRenderList = [];
            return _this;
        }
        ModelLayer.prototype.queryFeaturesByWorld = function (x, y) {
            if (!this._engine)
                return [];
            var onePixelToWorld = this._engine.getCamera().getOnePixelToWorld();
            return pointsContain(this._layout, this._features, { x: x, y: y }, onePixelToWorld);
        };
        ModelLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        ModelLayer.prototype._updateRenderList = function (e) {
            return __awaiter(this, void 0, void 0, function () {
                var info, i, loader, arr, itemArr, j, buffer, mapView;
                return __generator(this, function (_a) {
                    if (!this._engine)
                        return [2];
                    this._engine.getTextureMng();
                    this._geometryRenderList.length = 0;
                    info = e.info;
                    for (i = 0; i < info.length; i += 1) {
                        loader = ModelLayer.MODEL_LOADER_MAP.get(info[i].url);
                        if (loader) {
                            arr = loader.getDrawInfoList();
                            itemArr = [];
                            for (j = 0; j < arr.length; j += 1) {
                                buffer = new ModelBuffer(this._engine.getGl());
                                buffer.update(__assign$1(__assign$1({}, arr[j]), { texture: this._engine.getTextureMng().getEmptyTexture() }));
                                itemArr.push(__assign$1(__assign$1({}, info[i]), { buffer: buffer, useTexture: Boolean(arr[j].map) ? 1 : 0, color: arr[j].color, brightness: info[i].brightness, featureId: info[i].featureId, isExtra: info[i].isExtra }));
                                mapView = MapView$1.GetInstance();
                                if (mapView != null && mapView != undefined) {
                                    mapView.fire('ModelLoaded', info[i].featureId);
                                }
                            }
                            if (info[i].isExtra) {
                                ExtraMgr.GetInstance().AddExtraInfo(info[i].featureId, 1.0);
                            }
                            this._geometryRenderList.push(itemArr);
                        }
                    }
                    return [2];
                });
            });
        };
        ModelLayer.prototype.clear = function () {
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                var geoArray = this._geometryRenderList[i];
                for (var j = 0; j < geoArray.length; j++) {
                    geoArray[j];
                }
            }
            this._geometryRenderList.length = 0;
            this._features.length = 0;
        };
        ModelLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        ModelLayer.prototype._update = function () {
            var _this = this;
            if (!this._engine)
                return;
            for (var i = 0; i < this._features.length; i += 1) {
                this._calcPoint(this._features[i]);
            }
            var bOnly2d = this._engine.getMapView().getOnly2d();
            var bTextureEnable = this._engine.getMapView().getTextureEnable();
            var data = {
                id: this.id,
                type: 'model',
                layout: this._layout,
                features: this._features,
                offset: this._engine.getOffset(),
                taskId: this._getTaskId(),
                sync: this.getSync(),
                hideCategoryIdArray: [],
                hideColorIdArray: [],
                bOnly2d: bOnly2d,
                bCutFeature: false,
                chartletTable: [],
                bTextureEnable: bTextureEnable,
            };
            var bucketMng = this._engine.getBucketMng();
            if (this._loadPromiseSet.size === 0) {
                bucketMng.update(data);
            }
            else {
                new Promise(function (resolve) {
                    Promise.all(_this._loadPromiseSet).then(resolve).catch(resolve);
                }).then(function () {
                    bucketMng.update(data);
                });
            }
        };
        ModelLayer.prototype._calcPoint = function (feature) {
            var _this = this;
            var url = StyleUtils.getStyle(this._layout, 'url', feature.properties);
            if (!url)
                return;
            var loader = ModelLayer.MODEL_LOADER_MAP.get(url);
            if (!loader) {
                var postName = url.substr(url.length - 4, 4);
                if (postName == '.aaa') {
                    loader = new AAALoader(url);
                }
                else {
                    loader = new OBJLoader(url);
                }
                ModelLayer.MODEL_LOADER_MAP.set(url, loader);
            }
            if (!loader.loaded()) {
                var promise_1 = loader.getLoadPromise();
                promise_1.then(function () { return _this._loadPromiseSet.delete(promise_1); });
                this._loadPromiseSet.add(promise_1);
            }
        };
        ModelLayer.DEFAULT_LAYOUT = {
            visible: true,
            size: 1,
            base: 0,
            opacity: 1,
            rotateX: 0,
            rotateY: 0,
            rotateZ: 0,
        };
        ModelLayer.MODEL_LOADER_MAP = new Map();
        ModelLayer.TEXTURE_PARAMS = { xRepeat: true, yRepeat: true };
        return ModelLayer;
    }(AbstractLayer));

    var CircleBuffer$1 = (function (_super) {
        __extends$1(CircleBuffer, _super);
        function CircleBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this.verticesNum = 0;
            _this._normalsBuffer = _this._gl.createBuffer();
            return _this;
        }
        CircleBuffer.prototype.clear = function () {
            if (this._normalsBuffer) {
                this._gl.deleteBuffer(this._normalsBuffer);
                this._normalsBuffer = null;
            }
        };
        CircleBuffer.prototype.update = function (data) {
            var normals = data.normals;
            this.verticesNum = normals.length / 2;
            this._initArrayBuffer(this._normalsBuffer, normals);
        };
        CircleBuffer.prototype.bind = function (a_normal) {
            this._vertexAttribPointer(a_normal, this._normalsBuffer, 2);
        };
        return CircleBuffer;
    }(AbstractBuffer));

    var CircleLayer = (function (_super) {
        __extends$1(CircleLayer, _super);
        function CircleLayer(layout) {
            var _this = _super.call(this, 'Circle', __assign$1(__assign$1({}, CircleLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._geometryRenderList = [];
            return _this;
        }
        CircleLayer.prototype.queryFeaturesByWorld = function (x, y) {
            if (!this._engine)
                return [];
            var onePixelToWorld = this._engine.getCamera().getOnePixelToWorld();
            return pointsContain(this._layout, this._features, { x: x, y: y }, onePixelToWorld);
        };
        CircleLayer.prototype._updateRenderList = function (data) {
            var _a;
            this._geometryRenderList.length = 0;
            var info = data.info;
            (_a = this._geometryRenderList).push.apply(_a, info);
        };
        CircleLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        CircleLayer.prototype.onAdd = function (engine) {
            _super.prototype.onAdd.call(this, engine);
            var gl = engine.getGl();
            this._buffer = new CircleBuffer$1(gl);
            this._buffer.update({ normals: CircleLayer.getCircleNormals() });
        };
        CircleLayer.prototype.clear = function () {
            this._features.length = 0;
            this._geometryRenderList.length = 0;
        };
        CircleLayer.prototype.onRemove = function () {
            _super.prototype.onRemove.call(this);
            delete this._buffer;
        };
        CircleLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        CircleLayer.prototype.getBuffer = function () {
            return this._buffer;
        };
        CircleLayer.prototype._update = function () {
            if (!this._engine)
                return;
            var bOnly2d = this._engine.getMapView().getOnly2d();
            var bTextureEnable = this._engine.getMapView().getTextureEnable();
            var data = {
                type: 'circle',
                id: this.id,
                layout: this._layout,
                features: this._features,
                offset: this._engine.getOffset(),
                taskId: this._getTaskId(),
                sync: this.getSync(),
                hideCategoryIdArray: [],
                hideColorIdArray: [],
                bOnly2d: bOnly2d,
                bCutFeature: true,
                chartletTable: [],
                bTextureEnable: bTextureEnable,
            };
            var bucketMng = this._engine.getBucketMng();
            bucketMng.update(data);
        };
        CircleLayer.getCircleNormals = function () {
            if (!CircleLayer.CIRCLE_NORMALS) {
                CircleLayer.CIRCLE_NORMALS = [];
                var rotateV = new Vector2([0, 1]);
                var step = 16 / 180 * Math.PI;
                var max = Math.PI * 2 + step;
                for (var i = 0; i < max; i += step) {
                    var rotate = i > Math.PI * 2 ? Math.PI * 2 : i;
                    var item = rotateV.clone().rotate(rotate);
                    CircleLayer.CIRCLE_NORMALS.push(item.x, item.y);
                }
            }
            return CircleLayer.CIRCLE_NORMALS;
        };
        CircleLayer.DEFAULT_LAYOUT = {
            visible: true,
            radius: 5,
            color: '#333333',
            base: 0,
            opacity: 1,
        };
        return CircleLayer;
    }(AbstractLayer));

    var PictureBuffer = (function (_super) {
        __extends$1(PictureBuffer, _super);
        function PictureBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this._vertices = [];
            _this._verticesBuffer = _this._gl.createBuffer();
            _this._texCoordBuffer = _this._gl.createBuffer();
            return _this;
        }
        PictureBuffer.prototype.clear = function () {
            if (this._verticesBuffer) {
                this._gl.deleteBuffer(this._verticesBuffer);
                this._verticesBuffer = null;
            }
            if (this._texCoordBuffer) {
                this._gl.deleteBuffer(this._texCoordBuffer);
                this._texCoordBuffer = null;
            }
        };
        PictureBuffer.prototype.update = function (data) {
            var texCoords = data.texCoords, texture = data.texture, vertices = data.vertices;
            this._vertices = vertices;
            this._texture = texture;
            this._initArrayBuffer(this._verticesBuffer, vertices);
            this._initArrayBuffer(this._texCoordBuffer, texCoords);
        };
        PictureBuffer.prototype.getVertices = function () {
            return this._vertices;
        };
        Object.defineProperty(PictureBuffer.prototype, "verticesNum", {
            get: function () {
                return this._vertices.length / 2;
            },
            enumerable: false,
            configurable: true
        });
        PictureBuffer.prototype.bind = function (a_position, a_texCoord) {
            this._vertexAttribPointer(a_position, this._verticesBuffer, 2);
            this._vertexAttribPointer(a_texCoord, this._texCoordBuffer, 2);
            if (this._texture) {
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
            }
        };
        return PictureBuffer;
    }(AbstractBuffer));

    var PictureLayer = (function (_super) {
        __extends$1(PictureLayer, _super);
        function PictureLayer(layout) {
            var _this = _super.call(this, 'Picture', __assign$1(__assign$1({}, PictureLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._geometryRenderList = [];
            _this._loadPromiseSet = new Set();
            return _this;
        }
        PictureLayer.prototype.clear = function () {
            this._features.length = 0;
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                this._geometryRenderList[i];
            }
            this._geometryRenderList.length = 0;
        };
        PictureLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        PictureLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        PictureLayer.prototype.queryFeaturesByWorld = function (x, y) {
            if (!this._engine)
                return [];
            var result = [];
            var offset = this._engine.getOffset();
            for (var i = 0; i < this._geometryRenderList.length; i += 1) {
                var world = [x + offset[0], y + offset[1]];
                var _a = this._geometryRenderList[i], buffer = _a.buffer, rotate = _a.rotate, point = _a.point, index = _a.index;
                var rotatePoint = new Point(world[0] - point[0], world[1] - point[1]);
                rotatePoint.rotate(-rotate / 180 * Math.PI);
                world = [rotatePoint.x + point[0], rotatePoint.y + point[1]];
                var vertices = buffer.getVertices();
                var arr = [
                    [vertices[0], vertices[1]], [vertices[2], vertices[3]],
                    [vertices[6], vertices[7]], [vertices[4], vertices[5]],
                ];
                if (contain([arr], world)) {
                    result.push(__assign$1(__assign$1({}, this._features[index]), { index: index }));
                }
            }
            return result;
        };
        PictureLayer.prototype._updateRenderList = function (e) {
            if (!this._engine)
                return;
            this._geometryRenderList.length = 0;
            var textureMng = this._engine.getTextureMng();
            var info = e.info;
            for (var i = 0; i < info.length; i += 1) {
                var temp = textureMng.getTexture(info[i].iconUrl, PictureLayer.TEXTURE_PARAMS);
                var texture = textureMng.getEmptyTexture();
                if (temp) {
                    texture = temp.texture;
                }
                var buffer = new PictureBuffer(this._engine.getGl());
                buffer.update({
                    vertices: info[i].vertices,
                    texCoords: info[i].texCoords,
                    texture: texture,
                });
                this._geometryRenderList.push({
                    buffer: buffer,
                    base: info[i].base,
                    opacity: info[i].opacity,
                    point: info[i].point,
                    rotate: info[i].rotate,
                    index: info[i].index,
                });
            }
        };
        PictureLayer.prototype._update = function () {
            var _this = this;
            if (!this._engine)
                return;
            var list = [];
            var _loop_1 = function (i) {
                this_1._calcPoint(this_1._features[i], function (imgSize) {
                    list.push(__assign$1(__assign$1({}, _this._features[i]), { index: i, imgSize: imgSize }));
                });
            };
            var this_1 = this;
            for (var i = 0; i < this._features.length; i += 1) {
                _loop_1(i);
            }
            var bOnly2d = this._engine.getMapView().getOnly2d();
            var bTextureEnable = this._engine.getMapView().getTextureEnable();
            var data = {
                id: this.id,
                layout: this._layout,
                type: 'picture',
                features: list,
                offset: this._engine.getOffset(),
                taskId: this._getTaskId(),
                sync: this.getSync(),
                hideCategoryIdArray: [],
                hideColorIdArray: [],
                bOnly2d: bOnly2d,
                bCutFeature: false,
                chartletTable: [],
                bTextureEnable: bTextureEnable,
            };
            var bucketMng = this._engine.getBucketMng();
            if (this._loadPromiseSet.size === 0) {
                bucketMng.update(data);
            }
            else {
                new Promise(function (resolve) {
                    Promise.all(_this._loadPromiseSet).then(resolve).catch(resolve);
                }).then(function () {
                    bucketMng.update(data);
                });
            }
        };
        PictureLayer.prototype._calcPoint = function (feature, cb) {
            return __awaiter(this, void 0, void 0, function () {
                var textureMng, iconImage, imgSize, tempTexture, promise_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._engine)
                                return [2];
                            textureMng = this._engine.getTextureMng();
                            iconImage = StyleUtils.getStyle(this._layout, 'iconImage', feature.properties);
                            if (!iconImage)
                                return [2];
                            imgSize = [0, 0];
                            tempTexture = textureMng.getTexture(iconImage, PictureLayer.TEXTURE_PARAMS);
                            if (!!tempTexture) return [3, 2];
                            promise_1 = textureMng.loadTexture(iconImage, PictureLayer.TEXTURE_PARAMS);
                            promise_1.then(function () { return _this._loadPromiseSet.delete(promise_1); });
                            this._loadPromiseSet.add(promise_1);
                            return [4, promise_1];
                        case 1:
                            tempTexture = _a.sent();
                            _a.label = 2;
                        case 2:
                            imgSize = [tempTexture.width, tempTexture.height];
                            cb(imgSize);
                            return [2];
                    }
                });
            });
        };
        PictureLayer.DEFAULT_LAYOUT = {
            visible: true,
            size: 1,
            rotate: 0,
            base: 0,
            opacity: 1,
            anchor: 'center',
        };
        PictureLayer.TEXTURE_PARAMS = { xRepeat: false, yRepeat: false };
        return PictureLayer;
    }(AbstractLayer));

    var CircleBuffer = (function (_super) {
        __extends$1(CircleBuffer, _super);
        function CircleBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this.verticesNum = 0;
            _this._normalsBuffer = _this._gl.createBuffer();
            return _this;
        }
        CircleBuffer.prototype.clear = function () {
            if (this._normalsBuffer) {
                this._gl.deleteBuffer(this._normalsBuffer);
                this._normalsBuffer = null;
            }
        };
        CircleBuffer.prototype.update = function (data) {
            var normals = data.normals;
            this.verticesNum = normals.length / 2;
            this._initArrayBuffer(this._normalsBuffer, normals);
        };
        CircleBuffer.prototype.bind = function (a_normal) {
            this._vertexAttribPointer(a_normal, this._normalsBuffer, 2);
        };
        return CircleBuffer;
    }(AbstractBuffer));

    var HeatmapLayer = (function (_super) {
        __extends$1(HeatmapLayer, _super);
        function HeatmapLayer(layout) {
            var _this = _super.call(this, 'Heatmap', __assign$1(__assign$1({}, HeatmapLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._geometryRenderList = [];
            return _this;
        }
        HeatmapLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        HeatmapLayer.prototype.queryFeaturesByWorld = function (x, y) {
            if (!this._engine)
                return [];
            var onePixelToWorld = this._engine.getCamera().getOnePixelToWorld();
            return pointsContain(this._layout, this._features, { x: x, y: y }, onePixelToWorld);
        };
        HeatmapLayer.prototype.getBuffer = function () {
            return this._buffer;
        };
        HeatmapLayer.prototype.onAdd = function (engine) {
            _super.prototype.onAdd.call(this, engine);
            this._buffer = new CircleBuffer(engine.getGl());
            var normals = HeatmapLayer.getCircleNormals();
            this._buffer.update({ normals: normals });
        };
        HeatmapLayer.prototype.clear = function () {
            this._features.length = 0;
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                this._geometryRenderList[i];
            }
            this._geometryRenderList.length = 0;
        };
        HeatmapLayer.prototype.onRemove = function () {
            _super.prototype.onRemove.call(this);
            delete this._buffer;
        };
        HeatmapLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        HeatmapLayer.prototype._updateRenderList = function (e) {
            var _a;
            this._geometryRenderList.length = 0;
            var info = e.info;
            (_a = this._geometryRenderList).push.apply(_a, info);
        };
        HeatmapLayer.prototype._update = function () {
            if (!this._engine)
                return;
            var bOnly2d = this._engine.getMapView().getOnly2d();
            var bTextureEnable = this._engine.getMapView().getTextureEnable();
            var data = {
                id: this.id,
                features: this._features,
                type: 'heatmap',
                offset: this._engine.getOffset(),
                layout: this._layout,
                taskId: this._getTaskId(),
                sync: this.getSync(),
                hideCategoryIdArray: [],
                hideColorIdArray: [],
                bOnly2d: bOnly2d,
                bCutFeature: false,
                chartletTable: [],
                bTextureEnable: bTextureEnable,
            };
            var bucketMng = this._engine.getBucketMng();
            bucketMng.update(data);
        };
        HeatmapLayer.prototype.getBase = function () {
            return this._layout.base;
        };
        HeatmapLayer.getCircleNormals = function () {
            if (!HeatmapLayer.CIRCLE_NORMALS) {
                HeatmapLayer.CIRCLE_NORMALS = [0, 0];
                var rotateV = new Vector2([0, 1]);
                var step = 16 / 180 * Math.PI;
                var max = Math.PI * 2 + step;
                for (var i = 0; i < max; i += step) {
                    var rotate = i > Math.PI * 2 ? Math.PI * 2 : i;
                    var item = rotateV.clone().rotate(rotate);
                    HeatmapLayer.CIRCLE_NORMALS.push(item.x, item.y);
                }
            }
            return HeatmapLayer.CIRCLE_NORMALS;
        };
        HeatmapLayer.DEFAULT_LAYOUT = {
            visible: true,
            base: 0,
            opacity: 1,
            radius: 30,
        };
        return HeatmapLayer;
    }(AbstractLayer));

    var ConnectionBuffer = (function (_super) {
        __extends$1(ConnectionBuffer, _super);
        function ConnectionBuffer(gl) {
            var _this = _super.call(this, gl) || this;
            _this.verticesNum = 0;
            _this._verticesBuffer = _this._gl.createBuffer();
            _this._normalsBuffer = _this._gl.createBuffer();
            _this._texCoordsBuffer = _this._gl.createBuffer();
            _this._texture = _this._gl.createTexture();
            _this._tubeTexture = _this._gl.createTexture();
            return _this;
        }
        ConnectionBuffer.prototype.clear = function () {
            if (this._verticesBuffer) {
                this._gl.deleteBuffer(this._verticesBuffer);
                this._verticesBuffer = null;
            }
            if (this._normalsBuffer) {
                this._gl.deleteBuffer(this._normalsBuffer);
                this._normalsBuffer = null;
            }
            if (this._texCoordsBuffer) {
                this._gl.deleteBuffer(this._texCoordsBuffer);
                this._texCoordsBuffer = null;
            }
        };
        ConnectionBuffer.prototype.update = function (data) {
            var vertices = data.vertices, normals = data.normals, texCoords = data.texCoords, texture = data.texture, tubeTexture = data.tubeTexture;
            this.verticesNum = vertices.length / 3;
            this._initArrayBuffer(this._verticesBuffer, vertices);
            this._initArrayBuffer(this._normalsBuffer, normals);
            this._initArrayBuffer(this._texCoordsBuffer, texCoords);
            this._texture = texture;
            this._tubeTexture = tubeTexture;
        };
        ConnectionBuffer.prototype.bind = function (params, glShader) {
            var a_position = params.a_position, a_normal = params.a_normal, a_texCoord = params.a_texCoord;
            var u_sampler0 = glShader.getUniformLocation('u_sampler');
            var u_sampler1 = glShader.getUniformLocation('u_sampler2');
            this._gl.activeTexture(this._gl.TEXTURE0);
            this._gl.bindTexture(this._gl.TEXTURE_2D, this._texture);
            this._gl.uniform1i(u_sampler0, 0);
            this._gl.activeTexture(this._gl.TEXTURE1);
            this._gl.bindTexture(this._gl.TEXTURE_2D, this._tubeTexture);
            this._gl.uniform1i(u_sampler1, 1);
            this._vertexAttribPointer(a_position, this._verticesBuffer, 3);
            this._vertexAttribPointer(a_normal, this._normalsBuffer, 2);
            this._vertexAttribPointer(a_texCoord, this._texCoordsBuffer, 2);
            this._gl.activeTexture(this._gl.TEXTURE0);
        };
        return ConnectionBuffer;
    }(AbstractBuffer));

    var ConnectionLayer = (function (_super) {
        __extends$1(ConnectionLayer, _super);
        function ConnectionLayer(layout) {
            var _this = _super.call(this, 'Connection', __assign$1(__assign$1({}, ConnectionLayer.DEFAULT_LAYOUT), layout)) || this;
            _this._geometryRenderList = [];
            _this._loadPromiseSet = new Set();
            return _this;
        }
        ConnectionLayer.prototype.clear = function () {
            for (var i = 0; i < this._geometryRenderList.length; i++) {
                this._geometryRenderList[i];
            }
            this._geometryRenderList.length = 0;
        };
        ConnectionLayer.prototype._updateRenderList = function (data) {
            if (!this._engine)
                return;
            this._geometryRenderList.length = 0;
            var textureMng = this._engine.getTextureMng();
            var info = data.info;
            for (var i = 0; i < info.length; i += 1) {
                var buffer = new ConnectionBuffer(this._engine.getGl());
                var texture = textureMng.getEmptyTexture();
                var imgSize = [0, 0];
                var tubeTexture = textureMng.getEmptyTexture();
                var tubeUrl = info[i].tubeUrl;
                if (tubeUrl) {
                    var item = textureMng.getTexture(tubeUrl, ConnectionLayer.TEXTURE_PARAMS);
                    if (item) {
                        tubeTexture = item.texture;
                        imgSize = [item.width, item.height];
                    }
                }
                var iconUrl = info[i].iconUrl;
                if (iconUrl) {
                    var item = textureMng.getTexture(iconUrl, ConnectionLayer.TEXTURE_PARAMS);
                    if (item) {
                        texture = item.texture;
                        imgSize = [item.width, item.height];
                    }
                }
                buffer.update({
                    vertices: info[i].vertices,
                    texCoords: info[i].texCoords,
                    normals: info[i].normals,
                    texture: texture,
                    tubeTexture: tubeTexture,
                });
                this._geometryRenderList.push({
                    buffer: buffer,
                    color: info[i].color,
                    base: info[i].base,
                    opacity: info[i].opacity,
                    useTexture: Boolean(iconUrl),
                    width: info[i].width,
                    imgSize: imgSize,
                });
            }
        };
        ConnectionLayer.prototype.setLayout = function (layout) {
            this._layout = __assign$1(__assign$1({}, this._layout), layout);
            this._features.length !== 0 && this._update();
        };
        ConnectionLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        ConnectionLayer.prototype.queryFeaturesByWorld = function (x, y) {
            if (!this._engine)
                return [];
            var onePixelToWorld = this._engine.getCamera().getOnePixelToWorld();
            return linesContain(this._layout, this._features, { x: x, y: y }, onePixelToWorld);
        };
        ConnectionLayer.prototype._update = function () {
            var _this = this;
            if (!this._engine)
                return;
            for (var i = 0; i < this._features.length; i += 1) {
                this._calcPolyline(this._features[i]);
            }
            var bucketMng = this._engine.getBucketMng();
            var bOnly2d = this._engine.getMapView().getOnly2d();
            var bTextureEnable = this._engine.getMapView().getTextureEnable();
            var data = {
                id: this.id,
                type: 'connection',
                features: this._features,
                layout: this._layout,
                offset: this._engine.getOffset(),
                taskId: this._getTaskId(),
                sync: this.getSync(),
                hideCategoryIdArray: [],
                hideColorIdArray: [],
                bOnly2d: bOnly2d,
                bCutFeature: true,
                chartletTable: [],
                bTextureEnable: bTextureEnable,
            };
            if (this._loadPromiseSet.size === 0) {
                bucketMng.update(data);
            }
            else {
                new Promise(function (resolve) {
                    Promise.all(_this._loadPromiseSet).then(resolve).catch(resolve);
                }).then(function () {
                    bucketMng.update(data);
                });
            }
        };
        ConnectionLayer.prototype._calcPolyline = function (feature) {
            var _this = this;
            if (!this._engine)
                return;
            var textureMng = this._engine.getTextureMng();
            var icon = StyleUtils.getStyle(this._layout, 'icon', feature.properties);
            if (icon) {
                var tempTexture = textureMng.getTexture(icon, ConnectionLayer.TEXTURE_PARAMS);
                if (!tempTexture) {
                    var promise_1 = textureMng.loadTexture(icon, ConnectionLayer.TEXTURE_PARAMS);
                    this._loadPromiseSet.add(promise_1);
                    promise_1.then(function () { return _this._loadPromiseSet.delete(promise_1); });
                }
            }
        };
        ConnectionLayer.DEFAULT_LAYOUT = {
            visible: true,
            opacity: 1,
            base: 0,
            width: 10,
            color: '#666666',
        };
        ConnectionLayer.TEXTURE_PARAMS = { xRepeat: true, yRepeat: true };
        return ConnectionLayer;
    }(AbstractLayer));

    function edge(a, b) {
        if (a.y > b.y) {
            var t = a;
            a = b;
            b = t;
        }
        return {
            x0: a.x,
            y0: a.y,
            x1: b.x,
            y1: b.y,
            dx: b.x - a.x,
            dy: b.y - a.y
        };
    }
    function scanSpans(e0, e1, yMin, yMax) {
        var y0 = Math.max(yMin, Math.floor(e1.y0));
        var y1 = Math.min(yMax, Math.ceil(e1.y1));
        if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?
            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
            var t = e0;
            e0 = e1;
            e1 = t;
        }
        var m0 = e0.dx / e0.dy;
        var m1 = e1.dx / e1.dy;
        var d0 = Number(e0.dx > 0);
        var d1 = Number(e1.dx < 0);
        var result = [];
        for (var y = y0; y < y1; y += 1) {
            var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
            x0 = Math.ceil(x0);
            var x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
            x1 = Math.floor(x1);
            if (y >= 0 && y <= yMax) {
                for (var x = x1; x < x0; x += 1) {
                    var wx = (x % yMax + yMax) % yMax;
                    var w = Math.floor(x / yMax);
                    result.push({ x: wx, y: y, w: w });
                }
            }
        }
        return result;
    }
    function scanTriangle(a, b, c, yMin, yMax) {
        var ab = edge(a, b), bc = edge(b, c), ca = edge(c, a);
        var t;
        if (ab.dy > bc.dy) {
            t = ab;
            ab = bc;
            bc = t;
        }
        if (ab.dy > ca.dy) {
            t = ab;
            ab = ca;
            ca = t;
        }
        if (bc.dy > ca.dy) {
            t = bc;
            bc = ca;
            ca = t;
        }
        var result = [];
        if (ab.dy) {
            result.push.apply(result, scanSpans(ca, ab, yMin, yMax));
        }
        if (bc.dy) {
            result.push.apply(result, scanSpans(ca, bc, yMin, yMax));
        }
        return result;
    }
    function tileCover(z, bounds, origin, ratio) {
        var tiles = Math.pow(2, z);
        var result = [];
        var keySet = new Set();
        var zoomedBounds = bounds.map(function (coord) { return new Point(coord.x, coord.y).multiply(tiles); });
        var arr1 = scanTriangle(zoomedBounds[0], zoomedBounds[1], zoomedBounds[2], 0, tiles);
        var arr2 = scanTriangle(zoomedBounds[2], zoomedBounds[3], zoomedBounds[0], 0, tiles);
        var arr = arr1.concat(arr2);
        for (var i = 0; i < arr.length; i += 1) {
            var key = arr[i].x + "-" + arr[i].y;
            var p0 = new Point(origin.x - arr[i].w, origin.y).multiply(tiles);
            var point = new Point(arr[i].x, arr[i].y).subtract(p0);
            if (!keySet.has(key)) {
                result.push({
                    x: arr[i].x,
                    y: arr[i].y,
                    w: arr[i].w,
                    z: z,
                    point: new Point(point.x, -point.y).multiply(ratio),
                });
                keySet.add(key);
            }
        }
        return result;
    }

    var TileLayer = (function () {
        function TileLayer(options) {
            this._id = IdGenerator.getId();
            this._tileZoom = 0;
            this._pixelRatio = 1;
            this._originRatio = 1;
            this._geometryRenderList = [];
            this._originCenter = new Point(0, 0);
            this._options = __assign$1(__assign$1({}, options), { tileSize: options.tileSize || 256 });
        }
        TileLayer.prototype.getOriginCenter = function () {
            return this._originCenter.clone();
        };
        TileLayer.prototype.getOriginRatio = function () {
            return this._originRatio;
        };
        TileLayer.prototype.onAdd = function (engine) {
            if (this._engine)
                return;
            this._engine = engine;
            this.loadTile();
        };
        TileLayer.prototype.onRemove = function () {
            delete this._engine;
        };
        TileLayer.prototype.getGeometryRenderList = function () {
            return this._geometryRenderList;
        };
        TileLayer.prototype.loadTile = function () {
            if (!this._engine)
                return;
            this._geometryRenderList.length = 0;
            var tiles = this._coverTile();
            for (var i = 0; i < tiles.length; i += 1) {
                this._calcTileItem(tiles[i]);
            }
        };
        TileLayer.prototype._coverTile = function () {
            var _this = this;
            if (!this._engine)
                return [];
            var camera = this._engine.getCamera();
            this._tileZoom = Math.round(camera.getZoom()) + Math.log2(512 / this._options.tileSize);
            LogMgr$1.log('_coverTile tileZoom: ' + this._tileZoom);
            this._tileZoom = Math.min(18, this._tileZoom);
            this._originCenter = camera.getCenter();
            this._originRatio = camera.getOnePixelToWorld();
            var zoomRatio = camera.getPixelRatioByZoom(this._tileZoom - 1) / this._originRatio;
            this._pixelRatio = camera.getTileRatio() * zoomRatio;
            var world1 = camera.screenToWorldCoordinate(0, 0);
            var world2 = camera.screenToWorldCoordinate(camera.getWidth(), 0);
            var world3 = camera.screenToWorldCoordinate(camera.getWidth(), camera.getHeight());
            var world4 = camera.screenToWorldCoordinate(0, camera.getHeight());
            var bounds = [
                TileLayer.transform(world1),
                TileLayer.transform(world2),
                TileLayer.transform(world3),
                TileLayer.transform(world4),
            ];
            var p0 = TileLayer.transform(camera.getCenter());
            var ratio = this._pixelRatio * this._options.tileSize;
            var result = tileCover(this._tileZoom, bounds, p0, ratio);
            sort(result, function (a, b) {
                var dis1 = a.point.distanceTo(_this._originCenter);
                var dis2 = b.point.distanceTo(_this._originCenter);
                return dis2 - dis1;
            });
            return result;
        };
        TileLayer.prototype._calcTileItem = function (item) {
            return __awaiter(this, void 0, void 0, function () {
                var point, textureMng, url, texture, width, height, geometry, buffer;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._engine)
                                return [2];
                            point = item.point;
                            textureMng = this._engine.getTextureMng();
                            url = TileLayer.transformUrl(this._options.url, item);
                            url += ('&time=' + new Date().valueOf());
                            texture = textureMng.getTexture(url, TileLayer.TEXTURE_PARAMS);
                            if (!!texture) return [3, 2];
                            return [4, textureMng.loadTexture(url, TileLayer.TEXTURE_PARAMS)];
                        case 1:
                            texture = _a.sent();
                            _a.label = 2;
                        case 2:
                            width = texture.width, height = texture.height;
                            width *= this._pixelRatio;
                            height *= this._pixelRatio;
                            geometry = createPointGeometry([point.x, point.y], width, height, 'top-left');
                            buffer = new PictureBuffer(this._engine.getGl());
                            buffer.update(__assign$1(__assign$1({}, geometry), { texture: texture.texture }));
                            this._geometryRenderList.push({ buffer: buffer, opacity: 1 });
                            this._engine.render();
                            return [2];
                    }
                });
            });
        };
        Object.defineProperty(TileLayer.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        TileLayer.transformUrl = function (url, tile) {
            if (url == null || url == undefined) {
                return '';
            }
            var x = tile.x, y = tile.y, z = tile.z;
            if (url === 'http://p3.map.gtimg.com/maptilesv2') {
                y = Math.pow(2, z) - 1 - y;
                var png = z.toString() + '/' + Math.floor(x / 16.0).toString() + '/' + Math.floor(y / 16.0).toString() + '/' + x.toString() + '_' + y.toString() + '.png';
                return 'http://p3.map.gtimg.com/maptilesv2/' + png + '?version=20130701';
            }
            return url.replace(/{x}/, x.toString()).replace(/{y}/, y.toString()).replace(/{z}/, z.toString());
        };
        TileLayer.transform = function (point) {
            var x = TileLayer.RECIPROCAL * point.x + 0.5;
            var y = -TileLayer.RECIPROCAL * point.y + 0.5;
            return new Point(x, y);
        };
        TileLayer.unTransform = function (point) {
            var x = (point.x - 0.5) / TileLayer.RECIPROCAL;
            var y = (point.y - 0.5) / -TileLayer.RECIPROCAL;
            return new Point(x, y);
        };
        TileLayer.RECIPROCAL = 1 / (Math.PI * 2 * 6378137);
        TileLayer.TEXTURE_PARAMS = { xRepeat: false, yRepeat: false };
        return TileLayer;
    }());

    var DataSource = (function () {
        function DataSource(options) {
            this._options = options;
            if (window.indexedDB && this._options.useCache) {
                var name = 'palmap-road-net';
                this._dbMng = new DBManager(name, {
                    tableNames: [
                        { name: 'road-net', keyPath: 'bdId' },
                    ],
                });
            }
        }
        DataSource.prototype.requestRoadNet = function (bdId) {
            return __awaiter(this, void 0, void 0, function () {
                var res_1, res;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._dbMng) return [3, 2];
                            return [4, this._dbMng.select('road-net', bdId)];
                        case 1:
                            res_1 = _a.sent();
                            if (res_1) {
                                requestAnimationFrame(function () { return _this._requestRoadNet(bdId, true); });
                                return [2, res_1.data];
                            }
                            _a.label = 2;
                        case 2: return [4, this._requestRoadNet(bdId, false)];
                        case 3:
                            res = _a.sent();
                            return [2, res];
                    }
                });
            });
        };
        DataSource.prototype._requestRoadNet = function (bdId, isUpdate) {
            return __awaiter(this, void 0, void 0, function () {
                var url, res;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = this._options.server + "/path/" + bdId;
                            return [4, new HttpClient().get(url)];
                        case 1:
                            res = _a.sent();
                            if (this._dbMng) {
                                isUpdate ?
                                    this._dbMng.update('road-net', { bdId: bdId, data: res }) :
                                    this._dbMng.insert('road-net', { bdId: bdId, data: res });
                            }
                            return [2, res];
                    }
                });
            });
        };
        return DataSource;
    }());

    var Worker$1 = createWorker$1("(function () {\n    'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __spreadArrays() {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    }\n\n    var Point = (function () {\r\n        function Point(x, y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n        Point.prototype.set = function (x, y) {\r\n            this.x = x;\r\n            this.y = y;\r\n            return this;\r\n        };\r\n        Point.prototype.add = function (point) {\r\n            this.x += point.x;\r\n            this.y += point.y;\r\n            return this;\r\n        };\r\n        Point.prototype.subtract = function (point) {\r\n            this.x -= point.x;\r\n            this.y -= point.y;\r\n            return this;\r\n        };\r\n        Point.prototype.divide = function (num) {\r\n            this.x /= num;\r\n            this.y /= num;\r\n            return this;\r\n        };\r\n        Point.prototype.equal = function (point) {\r\n            return this.x === point.x && this.y === point.y;\r\n        };\r\n        Point.prototype.clone = function () {\r\n            return new Point(this.x, this.y);\r\n        };\r\n        Point.prototype.distanceTo = function (point) {\r\n            return Math.sqrt(Math.pow((this.x - point.x), 2) + Math.pow((this.y - point.y), 2));\r\n        };\r\n        Point.prototype.rotate = function (angle) {\r\n            var cos = Math.cos(angle);\r\n            var sin = Math.sin(angle);\r\n            var x = cos * this.x - sin * this.y;\r\n            var y = sin * this.x + cos * this.y;\r\n            this.x = x;\r\n            this.y = y;\r\n            return this;\r\n        };\r\n        Point.prototype.multiply = function (num) {\r\n            this.x *= num;\r\n            this.y *= num;\r\n            return this;\r\n        };\r\n        Point.prototype.getLength = function () {\r\n            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\r\n        };\r\n        Point.prototype.floor = function () {\r\n            this.x = Math.floor(this.x);\r\n            this.y = Math.floor(this.y);\r\n            return this;\r\n        };\r\n        Point.prototype.ceil = function () {\r\n            this.x = Math.ceil(this.x);\r\n            this.y = Math.ceil(this.y);\r\n            return this;\r\n        };\r\n        Point.prototype.round = function () {\r\n            this.x = Math.round(this.x);\r\n            this.y = Math.round(this.y);\r\n            return this;\r\n        };\r\n        return Point;\r\n    }());\n\n    var Vector2 = (function () {\r\n        function Vector2(start, end) {\r\n            if (end) {\r\n                this.x = end[0] - start[0];\r\n                this.y = end[1] - start[1];\r\n            }\r\n            else {\r\n                this.x = start[0];\r\n                this.y = start[1];\r\n            }\r\n        }\r\n        Vector2.prototype.unit = function () {\r\n            var length = this.getLength();\r\n            if (length === 0) {\r\n                return new Vector2([0, 0]);\r\n            }\r\n            var x = this.x / length;\r\n            var y = this.y / length;\r\n            return new Vector2([0, 0], [x, y]);\r\n        };\r\n        Vector2.prototype.normal = function () {\r\n            return new Vector2([0, 0], [-this.y, this.x]);\r\n        };\r\n        Vector2.prototype.add = function (other) {\r\n            this.x += other.x;\r\n            this.y += other.y;\r\n            return this;\r\n        };\r\n        Vector2.prototype.subtract = function (other) {\r\n            this.x -= other.x;\r\n            this.y -= other.y;\r\n            return this;\r\n        };\r\n        Vector2.prototype.rotate = function (angle) {\r\n            var cos = Math.cos(angle);\r\n            var sin = Math.sin(angle);\r\n            var x = cos * this.x - sin * this.y;\r\n            var y = sin * this.x + cos * this.y;\r\n            this.x = x;\r\n            this.y = y;\r\n            return this;\r\n        };\r\n        Vector2.prototype.multiply = function (num) {\r\n            this.x *= num;\r\n            this.y *= num;\r\n            return this;\r\n        };\r\n        Vector2.prototype.dot = function (other) {\r\n            return this.x * other.x + this.y * other.y;\r\n        };\r\n        Vector2.prototype.angleTo = function (other) {\r\n            var m1 = this.getLength();\r\n            var m2 = other.getLength();\r\n            var m = m1 * m2;\r\n            if (m === 0)\r\n                return 0;\r\n            var num = (this.x * other.x + this.y * other.y) / m;\r\n            if (num > 1) {\r\n                num = 1;\r\n            }\r\n            else if (num < -1) {\r\n                num = -1;\r\n            }\r\n            var angle = Math.acos(num) / Math.PI * 180;\r\n            var cross = this.cross(other) < 0 ? 1 : -1;\r\n            return cross * angle;\r\n        };\r\n        Vector2.prototype.cross = function (other) {\r\n            return this.x * other.y - other.x * this.y;\r\n        };\r\n        Vector2.prototype.clone = function () {\r\n            return new Vector2([0, 0], [this.x, this.y]);\r\n        };\r\n        Vector2.prototype.multiplyMat4 = function (matrix) {\r\n            var m = matrix.getValue();\r\n            var x = m[0] * this.x + m[4] * this.y + m[12];\r\n            var y = m[1] * this.x + m[5] * this.y + m[13];\r\n            return new Vector2([x, y]);\r\n        };\r\n        Vector2.prototype.getLength = function () {\r\n            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));\r\n        };\r\n        return Vector2;\r\n    }());\n\n    var EPSILON = 1e-6;\r\n    function contain(polygon, point) {\r\n        var px = point[0], py = point[1];\r\n        var flag = false;\r\n        for (var m = 0; m < polygon.length; m += 1) {\r\n            var face = polygon[m];\r\n            for (var i = 0, l = face.length, j = l - 1; i < l; j = i, i++) {\r\n                var sx = face[i][0];\r\n                var sy = face[i][1];\r\n                var tx = face[j][0];\r\n                var ty = face[j][1];\r\n                if ((sx === px && sy === py) || (tx === px && ty === py)) {\r\n                    return true;\r\n                }\r\n                if ((sy < py && ty >= py) || (sy >= py && ty < py)) {\r\n                    var x = sx + (py - sy) * (tx - sx) / (ty - sy);\r\n                    if (Math.abs(x - px) <= EPSILON) {\r\n                        return true;\r\n                    }\r\n                    if (x > px) {\r\n                        flag = !flag;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return flag;\r\n    }\n\n    var Line = (function () {\r\n        function Line(start, end) {\r\n            this._start = new Point(start[0], start[1]);\r\n            this._end = new Point(end[0], end[1]);\r\n        }\r\n        Line.prototype.getVector2 = function () {\r\n            var x = this._end.x - this._start.x;\r\n            var y = this._end.y - this._start.y;\r\n            return new Vector2([x, y]);\r\n        };\r\n        Line.prototype.getLength = function () {\r\n            return this._start.distanceTo(this._end);\r\n        };\r\n        Line.prototype.getClosest = function (coordinate) {\r\n            var x0 = coordinate.x, y0 = coordinate.y;\r\n            var point = new Point(x0, y0);\r\n            var vector = this.getVector2();\r\n            var m = vector.x, n = vector.y;\r\n            var _a = this._start, x1 = _a.x, y1 = _a.y;\r\n            var _b = this._end, x2 = _b.x, y2 = _b.y;\r\n            if (this.getLength() === 0) {\r\n                var distance = point.distanceTo(this._start);\r\n                return { distance: distance, coordinate: { x: x1, y: y1 } };\r\n            }\r\n            var y = (m * n * x0 - m * n * x1 + n * n * y0 + m * m * y1) / (n * n + m * m);\r\n            var x;\r\n            if (Math.abs(m) <= EPSILON) {\r\n                x = (n * x1 + m * y - m * y1) / n;\r\n            }\r\n            else {\r\n                x = (m * x0 - n * y + n * y0) / m;\r\n            }\r\n            if (this._checkIsInSegment(x, y)) {\r\n                var resultPoint = new Point(x, y);\r\n                var distance = resultPoint.distanceTo(point);\r\n                return { distance: distance, coordinate: { x: x, y: y } };\r\n            }\r\n            else {\r\n                var distance1 = point.distanceTo(this._start);\r\n                var distance2 = point.distanceTo(this._end);\r\n                if (distance1 < distance2) {\r\n                    return { distance: distance1, coordinate: { x: x1, y: y1 } };\r\n                }\r\n                else {\r\n                    return { distance: distance2, coordinate: { x: x2, y: y2 } };\r\n                }\r\n            }\r\n        };\r\n        Line.prototype.getStart = function () {\r\n            return this._start;\r\n        };\r\n        Line.prototype.getEnd = function () {\r\n            return this._end;\r\n        };\r\n        Line.prototype._checkIsInSegment = function (x, y) {\r\n            return (x - this._start.x) * (x - this._end.x) <= EPSILON &&\r\n                (y - this._start.y) * (y - this._end.y) <= EPSILON;\r\n        };\r\n        return Line;\r\n    }());\n\n    var IdGenerator = (function () {\r\n        function IdGenerator() {\r\n        }\r\n        IdGenerator.getId = function (prefix) {\r\n            if (prefix === void 0) { prefix = 'nag'; }\r\n            IdGenerator.id += 1;\r\n            return prefix + \"-\" + IdGenerator.id;\r\n        };\r\n        IdGenerator.id = 0;\r\n        return IdGenerator;\r\n    }());\n\n    var Vertex = (function () {\r\n        function Vertex(data, loader) {\r\n            this._g = 0;\r\n            this._h = 0;\r\n            this._altitude = data.altitude;\r\n            this._doorId = data.doorId;\r\n            this._escalatorId = data.escalatorId;\r\n            this._facility = data.facility;\r\n            this._floorId = data.floorId;\r\n            this._nodeId = data.nodeId;\r\n            this._shape = data.shape;\r\n            var coordinates = data.shape.coordinates;\r\n            this._point = new Point(coordinates[0], coordinates[1]);\r\n            this._loader = loader;\r\n        }\r\n        Object.defineProperty(Vertex.prototype, \"id\", {\r\n            get: function () {\r\n                return this._nodeId;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Vertex.prototype.getData = function () {\r\n            return {\r\n                altitude: this._altitude,\r\n                doorId: this._doorId,\r\n                escalatorId: this._escalatorId,\r\n                facility: this._facility,\r\n                floorId: this._floorId,\r\n                nodeId: this._nodeId,\r\n                shape: this._shape,\r\n            };\r\n        };\r\n        Vertex.prototype.getAltitude = function () {\r\n            return this._altitude;\r\n        };\r\n        Vertex.prototype.getDoorId = function () {\r\n            return this._doorId;\r\n        };\r\n        Vertex.prototype.getEscalatorId = function () {\r\n            return this._escalatorId;\r\n        };\r\n        Vertex.prototype.getFacility = function () {\r\n            return this._facility;\r\n        };\r\n        Vertex.prototype.getFloorId = function () {\r\n            return this._floorId;\r\n        };\r\n        Vertex.prototype.getNodeId = function () {\r\n            return this._nodeId;\r\n        };\r\n        Vertex.prototype.getCoordinates = function () {\r\n            return this._shape.coordinates;\r\n        };\r\n        Vertex.prototype.setParent = function (node) {\r\n            this._parent = node;\r\n        };\r\n        Vertex.prototype.setG = function (g) {\r\n            this._g = g;\r\n        };\r\n        Vertex.prototype.getG = function () {\r\n            return this._g;\r\n        };\r\n        Vertex.prototype.setH = function (h) {\r\n            this._h = h;\r\n        };\r\n        Vertex.prototype.getH = function () {\r\n            return this._h;\r\n        };\r\n        Vertex.prototype.getParent = function () {\r\n            return this._parent;\r\n        };\r\n        Vertex.prototype.getPoint = function () {\r\n            return this._point;\r\n        };\r\n        Vertex.prototype.equal = function (other) {\r\n            return this._point.equal(other._point) && this._floorId === other._floorId;\r\n        };\r\n        Vertex.prototype.distanceTo = function (other) {\r\n            return this._point.distanceTo(other._point);\r\n        };\r\n        Vertex.prototype.getPaths = function () {\r\n            return this._loader.getPathsByFloor(this._floorId)[this._nodeId] || [];\r\n        };\r\n        Vertex.prototype.getConnections = function () {\r\n            return this._loader.getConnectionsByFloor(this._floorId)[this._nodeId] || [];\r\n        };\r\n        Vertex.prototype.findPath = function (target) {\r\n            var paths = this._loader.getPathsByFloor(this._floorId)[this._nodeId];\r\n            if (!paths)\r\n                return;\r\n            for (var i = 0; i < paths.length; i += 1) {\r\n                if (paths[i].getTo().equal(target)) {\r\n                    return paths[i];\r\n                }\r\n            }\r\n        };\r\n        Vertex.prototype.findConnection = function (target) {\r\n            var connections = this._loader.getConnectionsByFloor(this._floorId)[this._nodeId];\r\n            if (!connections)\r\n                return;\r\n            for (var i = 0; i < connections.length; i += 1) {\r\n                if (connections[i].getTo().equal(target)) {\r\n                    return connections[i];\r\n                }\r\n            }\r\n        };\r\n        Vertex.prototype.clone = function () {\r\n            return new Vertex({\r\n                altitude: this._altitude,\r\n                doorId: this._doorId,\r\n                escalatorId: this._escalatorId,\r\n                facility: this._facility,\r\n                floorId: this._floorId,\r\n                nodeId: IdGenerator.getId(),\r\n                shape: {\r\n                    type: 'Point',\r\n                    coordinates: [this._point.x, this._point.y],\r\n                },\r\n            }, this._loader);\r\n        };\r\n        Vertex.prototype.setCoordinate = function (coordinate) {\r\n            this._shape.coordinates = [coordinate.x, coordinate.y];\r\n            this._point = new Point(coordinate.x, coordinate.y);\r\n            return this;\r\n        };\r\n        Vertex.deepEach = function (node, cb) {\r\n            cb(node);\r\n            var parent = node.getParent();\r\n            if (parent) {\r\n                Vertex.deepEach(parent, cb);\r\n            }\r\n        };\r\n        return Vertex;\r\n    }());\n\n    var Path = (function () {\r\n        function Path(data, loader) {\r\n            this._lines = [];\r\n            this._loader = loader;\r\n            this._altitude = data.altitude;\r\n            this._attribute = data.attribute;\r\n            this._direction = data.direction;\r\n            this._floorId = data.floorId;\r\n            this._from = new Vertex(data.from, loader);\r\n            this._shape = __assign({}, data.shape);\r\n            this._to = new Vertex(data.to, loader);\r\n            var coordinates = data.shape.coordinates;\r\n            this._weight = 0;\r\n            for (var i = 0; i < coordinates.length - 1; i += 1) {\r\n                var line = new Line(coordinates[i], coordinates[i + 1]);\r\n                this._weight += line.getLength();\r\n                this._lines.push(line);\r\n            }\r\n            this._floorAddress = data.floorId.slice(-3);\r\n        }\r\n        Path.prototype.getFloorAddress = function () {\r\n            return this._floorAddress;\r\n        };\r\n        Path.prototype.getAltitude = function () {\r\n            return this._altitude;\r\n        };\r\n        Path.prototype.getAttribute = function () {\r\n            return this._attribute;\r\n        };\r\n        Path.prototype.getDirection = function () {\r\n            return this._direction;\r\n        };\r\n        Path.prototype.getFloorId = function () {\r\n            return this._floorId;\r\n        };\r\n        Path.prototype.getFrom = function () {\r\n            return this._from;\r\n        };\r\n        Path.prototype.getTo = function () {\r\n            return this._to;\r\n        };\r\n        Path.prototype.splitPath = function (to, index) {\r\n            this._to = to;\r\n            var coordinates = this._shape.coordinates;\r\n            var result = [];\r\n            for (var i = 0; i < index + 1; i += 1) {\r\n                result.push(coordinates[i]);\r\n            }\r\n            result.push(to.getCoordinates());\r\n            this._shape = { type: 'LineString', coordinates: result };\r\n            this._lines.length = 0;\r\n            this._weight = 0;\r\n            for (var i = 0; i < result.length - 1; i += 1) {\r\n                var line = new Line(result[i], result[i + 1]);\r\n                this._weight += line.getLength();\r\n                this._lines.push(line);\r\n            }\r\n        };\r\n        Path.prototype.getClosest = function (coordinate) {\r\n            var lineClosest = this._lines[0].getClosest(coordinate);\r\n            var result = __assign(__assign({}, lineClosest), { index: 0 });\r\n            for (var i = 1; i < this._lines.length; i += 1) {\r\n                var itemResult = this._lines[i].getClosest(coordinate);\r\n                if (itemResult.distance < result.distance) {\r\n                    result = __assign(__assign({}, itemResult), { index: i });\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        Path.prototype.equalFrom = function (coordinate) {\r\n            var start = this._from.getCoordinates();\r\n            return start[0] === coordinate.x && start[1] === coordinate.y;\r\n        };\r\n        Path.prototype.equalTo = function (coordinate) {\r\n            var to = this._to.getCoordinates();\r\n            return to[0] === coordinate.x && to[1] === coordinate.y;\r\n        };\r\n        Path.prototype.getWeight = function () {\r\n            return this._weight;\r\n        };\r\n        Path.prototype.getCoordinates = function () {\r\n            return this._shape.coordinates;\r\n        };\r\n        Path.prototype.toLineJson = function () {\r\n            var coordinates = this._shape.coordinates;\r\n            var result = [];\r\n            var baseVector = new Vector2([0, 1]);\r\n            for (var i = 0, len = coordinates.length - 1; i < len; i += 1) {\r\n                var vector = new Vector2(coordinates[i], coordinates[i + 1]);\r\n                result.push({\r\n                    geometry: [coordinates[i], coordinates[i + 1]],\r\n                    angle: vector.angleTo(baseVector),\r\n                    length: vector.getLength(),\r\n                    floor: this._floorId,\r\n                });\r\n            }\r\n            return result;\r\n        };\r\n        Path.prototype.reverse = function () {\r\n            return new Path({\r\n                altitude: this._altitude,\r\n                attribute: this._attribute,\r\n                direction: this._direction,\r\n                floorId: this._floorId,\r\n                from: this._to.getData(),\r\n                shape: {\r\n                    type: 'LineString',\r\n                    coordinates: Array.from(this.getCoordinates()).reverse(),\r\n                },\r\n                to: this._from.getData(),\r\n            }, this._loader);\r\n        };\r\n        return Path;\r\n    }());\n\n    var TYPE_CATEGORY = {\r\n        1: {\r\n            category: 25136,\r\n            name: '鐢垫',\r\n        },\r\n        2: {\r\n            category: 25135,\r\n            name: '鎵舵',\r\n        },\r\n        3: {\r\n            category: 25135,\r\n            name: '鍙屽悜鎵舵',\r\n        },\r\n        4: {\r\n            category: 25134,\r\n            name: '妤兼',\r\n        },\r\n        5: {\r\n            category: 25137,\r\n            name: '寤虹瓚鐗╁嚭鍙�',\r\n        },\r\n        6: {\r\n            category: 25147,\r\n            name: '鍧￠亾',\r\n        },\r\n        7: {\r\n            category: 25147,\r\n            name: '鍧￠亾',\r\n        }\r\n    };\r\n    var STRATEGY_TYPE = {\r\n        elevator: [1],\r\n        escalator: [2, 3],\r\n        stair: [4],\r\n        ramp: [6, 7],\r\n        shortest: [1, 2, 3, 4, 6, 7],\r\n    };\n\n    var Connection = (function () {\r\n        function Connection(data, loader) {\r\n            this._direction = data.direction;\r\n            this._from = new Vertex(data.from, loader);\r\n            this._fromEscalatorId = data.fromEscalatorId;\r\n            this._fromFloorId = data.fromFloorId;\r\n            this._to = new Vertex(data.to, loader);\r\n            this._toEscalatorId = data.toEscalatorId;\r\n            this._toFloorId = data.toFloorId;\r\n            this._type = data.type;\r\n            this._category = TYPE_CATEGORY[data.type].category;\r\n            this._loader = loader;\r\n        }\r\n        Connection.prototype.getFrom = function () {\r\n            return this._from;\r\n        };\r\n        Connection.prototype.getTo = function () {\r\n            return this._to;\r\n        };\r\n        Connection.prototype.getCategory = function () {\r\n            return this._category;\r\n        };\r\n        Connection.prototype.getType = function () {\r\n            return this._type;\r\n        };\r\n        Connection.prototype.reverse = function () {\r\n            return new Connection({\r\n                direction: this._direction,\r\n                from: this._to.getData(),\r\n                fromEscalatorId: this._toEscalatorId,\r\n                fromFloorId: this._toFloorId,\r\n                to: this._from.getData(),\r\n                toEscalatorId: this._fromEscalatorId,\r\n                toFloorId: this._fromFloorId,\r\n                type: this._type,\r\n            }, this._loader);\r\n        };\r\n        return Connection;\r\n    }());\n\n    function containLine(polygon, points) {\r\n        for (var i = 0; i < points.length; i += 1) {\r\n            var isContain = contain(polygon, points[i]);\r\n            if (!isContain)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\n\n    var Loader = (function () {\r\n        function Loader(data) {\r\n            this._connections = {};\r\n            this._paths = {};\r\n            this._vertexes = {};\r\n            this._recommendType = null;\r\n            this._data = data;\r\n            var roads = data.roads;\r\n            for (var i = 0; i < roads.length; i += 1) {\r\n                var _a = roads[i], vertexes = _a.vertexes, floorId = _a.floorId;\r\n                var itemArr = this._vertexes[floorId];\r\n                if (!itemArr) {\r\n                    itemArr = [];\r\n                    this._vertexes[floorId] = itemArr;\r\n                }\r\n                for (var j = 0; j < vertexes.length; j += 1) {\r\n                    var vertex = new Vertex(vertexes[j], this);\r\n                    itemArr.unshift(vertex);\r\n                }\r\n            }\r\n        }\r\n        Loader.prototype.setRecommendType = function (type) {\r\n            if (type) {\r\n                this._recommendType = new Set(type);\r\n            }\r\n            else {\r\n                this._recommendType = null;\r\n            }\r\n            this._connections = {};\r\n            this._initConnections();\r\n        };\r\n        Loader.prototype._initConnections = function () {\r\n            var connections = this._data.connections;\r\n            for (var i = 0; i < connections.length; i += 1) {\r\n                var _a = connections[i], fromFloorId = _a.fromFloorId, from = _a.from, to = _a.to, direction = _a.direction, toFloorId = _a.toFloorId, type = _a.type;\r\n                if (from && to && this._checkType(type)) {\r\n                    var connection = new Connection(connections[i], this);\r\n                    if (!this._connections[fromFloorId]) {\r\n                        this._connections[fromFloorId] = {};\r\n                    }\r\n                    var item = this._connections[fromFloorId][from.nodeId];\r\n                    if (!item) {\r\n                        item = [connection];\r\n                        this._connections[fromFloorId][from.nodeId] = item;\r\n                    }\r\n                    else {\r\n                        item.push(connection);\r\n                    }\r\n                    if (direction === 'TWOWAY') {\r\n                        var reverseConn = connection.reverse();\r\n                        if (!this._connections[toFloorId]) {\r\n                            this._connections[toFloorId] = {};\r\n                        }\r\n                        var item_1 = this._connections[toFloorId][to.nodeId];\r\n                        if (!item_1) {\r\n                            item_1 = [reverseConn];\r\n                            this._connections[toFloorId][to.nodeId] = item_1;\r\n                        }\r\n                        else {\r\n                            item_1.push(reverseConn);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Loader.prototype._checkType = function (type) {\r\n            return !this._recommendType || this._recommendType.has(type);\r\n        };\r\n        Loader.prototype._initPaths = function () {\r\n            var roads = this._data.roads;\r\n            for (var i = 0; i < roads.length; i += 1) {\r\n                var _a = roads[i], floorId = _a.floorId, paths = _a.paths;\r\n                if (!this._paths[floorId]) {\r\n                    this._paths[floorId] = {};\r\n                }\r\n                for (var j = 0; j < paths.length; j += 1) {\r\n                    var _b = paths[j], from = _b.from, to = _b.to, direction = _b.direction;\r\n                    var path = new Path(paths[j], this);\r\n                    if (!this._paths[floorId][from.nodeId]) {\r\n                        this._paths[floorId][from.nodeId] = [path];\r\n                    }\r\n                    else {\r\n                        this._paths[floorId][from.nodeId].push(path);\r\n                    }\r\n                    if (direction === 'TWOWAY') {\r\n                        var reversePath = path.reverse();\r\n                        if (!this._paths[floorId][to.nodeId]) {\r\n                            this._paths[floorId][to.nodeId] = [reversePath];\r\n                        }\r\n                        else {\r\n                            this._paths[floorId][to.nodeId].push(reversePath);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        Loader.prototype.getClosestVertex = function (position, area) {\r\n            var paths = this.getPathsByFloor(position.floorId);\r\n            if (!paths)\r\n                return;\r\n            if (area) {\r\n                var _a = this._getAreaPath(paths, area, position.coordinate), path_1 = _a.path, closestResult_1 = _a.closestResult;\r\n                if (path_1 && closestResult_1) {\r\n                    return this._genVertexByPath(path_1, closestResult_1, paths);\r\n                }\r\n                else {\r\n                    var vertex = this._getVertexByDoorIds(position.floorId, area.doorIds);\r\n                    if (vertex)\r\n                        return vertex;\r\n                }\r\n            }\r\n            var closestResult = this._getClosestResult(paths, position.coordinate);\r\n            if (!closestResult)\r\n                return;\r\n            var path = paths[closestResult.id][closestResult.index];\r\n            var pathClosestResult = {\r\n                coordinate: closestResult.coordinate,\r\n                index: closestResult.childIndex,\r\n                distance: closestResult.distance,\r\n            };\r\n            return this._genVertexByPath(path, pathClosestResult, paths);\r\n        };\r\n        Loader.prototype._getVertexByDoorIds = function (floorId, doorIds) {\r\n            var doorSet = new Set(doorIds);\r\n            var arr = this._vertexes[floorId] || [];\r\n            for (var i = 0; i < arr.length; i += 1) {\r\n                if (doorSet.has(arr[i].getDoorId() || '')) {\r\n                    return arr[i];\r\n                }\r\n            }\r\n        };\r\n        Loader.prototype._genVertexByPath = function (path, result, paths) {\r\n            var vertex;\r\n            if (path.equalFrom(result.coordinate)) {\r\n                vertex = path.getFrom();\r\n            }\r\n            else if (path.equalTo(result.coordinate)) {\r\n                vertex = path.getTo();\r\n            }\r\n            else {\r\n                vertex = path.getFrom().clone().setCoordinate(result.coordinate);\r\n                var newPaths = [];\r\n                var arr = paths[path.getTo().getNodeId()];\r\n                for (var i = 0; i < arr.length; i += 1) {\r\n                    if (arr[i].getTo().equal(path.getFrom())) {\r\n                        var num = arr[i].getCoordinates().length - result.index - 2;\r\n                        arr[i].splitPath(vertex, num);\r\n                        newPaths.push(arr[i].reverse());\r\n                    }\r\n                }\r\n                path.splitPath(vertex, result.index);\r\n                newPaths.push(path.reverse());\r\n                paths[vertex.getNodeId()] = newPaths;\r\n            }\r\n            return vertex;\r\n        };\r\n        Loader.prototype._getAreaPath = function (paths, area, point) {\r\n            var resultPath, closestResult;\r\n            for (var key in paths) {\r\n                var arr = paths[key];\r\n                for (var i = 0; i < arr.length; i += 1) {\r\n                    var points = arr[i].getCoordinates();\r\n                    if (containLine(area.coordinates, points)) {\r\n                        var itemResult = arr[i].getClosest(point);\r\n                        if (!closestResult || itemResult.distance < closestResult.distance) {\r\n                            resultPath = arr[i];\r\n                            closestResult = itemResult;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return { path: resultPath, closestResult: closestResult };\r\n        };\r\n        Loader.prototype._getClosestResult = function (paths, point) {\r\n            var closestResult;\r\n            for (var key in paths) {\r\n                var arr = paths[key];\r\n                var pathClosestResult = arr[0].getClosest(point);\r\n                var index = 0;\r\n                for (var i = 1; i < arr.length; i += 1) {\r\n                    var item = arr[i].getClosest(point);\r\n                    if (item.distance < pathClosestResult.distance) {\r\n                        pathClosestResult = item;\r\n                        index = i;\r\n                    }\r\n                }\r\n                if (!closestResult || pathClosestResult.distance < closestResult.distance) {\r\n                    closestResult = {\r\n                        id: key,\r\n                        distance: pathClosestResult.distance,\r\n                        coordinate: pathClosestResult.coordinate,\r\n                        index: index,\r\n                        childIndex: pathClosestResult.index,\r\n                    };\r\n                }\r\n            }\r\n            return closestResult;\r\n        };\r\n        Loader.prototype.reset = function () {\r\n            this._paths = {};\r\n            this._initPaths();\r\n        };\r\n        Loader.prototype.getPathsByFloor = function (floorId) {\r\n            return this._paths[floorId] || {};\r\n        };\r\n        Loader.prototype.getConnectionsByFloor = function (floorId) {\r\n            return this._connections[floorId] || {};\r\n        };\r\n        return Loader;\r\n    }());\n\n    var G = (function () {\r\n        function G() {\r\n        }\r\n        G.prototype.G = function (current, path, isSameFloor) {\r\n            var lastPath;\r\n            var parent = current.getParent();\r\n            if (parent) {\r\n                lastPath = parent.findPath(current) || parent.findConnection(current);\r\n            }\r\n            if (path instanceof Path) {\r\n                return path.getWeight() + G.calcTurnCost(lastPath, path);\r\n            }\r\n            else if (path instanceof Connection) {\r\n                var connHeightDiff = Math.abs(path.getFrom().getAltitude() - path.getTo().getAltitude());\r\n                switch (path.getType()) {\r\n                    case 1: {\r\n                        if (lastPath instanceof Connection) {\r\n                            return (connHeightDiff - G.BASIC_FLOOR_HEIGHT) * G.COST_CONN_CONTINUOUS_ELEVATOR;\r\n                        }\r\n                        else {\r\n                            return connHeightDiff <= G.BASIC_FLOOR_HEIGHT ?\r\n                                (connHeightDiff / G.BASIC_FLOOR_HEIGHT) * G.COST_CONN_ELEVATOR :\r\n                                G.COST_CONN_ELEVATOR + ((connHeightDiff / G.BASIC_FLOOR_HEIGHT) - 1) * G.COST_CONN_CONTINUOUS_ELEVATOR;\r\n                        }\r\n                    }\r\n                    case 4: {\r\n                        return (connHeightDiff / G.BASIC_FLOOR_HEIGHT) * G.COST_CONN_STAIR;\r\n                    }\r\n                    default: {\r\n                        return (connHeightDiff / G.BASIC_FLOOR_HEIGHT) * G.COST_CONN_OTHER;\r\n                    }\r\n                }\r\n            }\r\n            return 0;\r\n        };\r\n        G.calcTurnCost = function (lastPath, path) {\r\n            var coordinates = [];\r\n            if (lastPath instanceof Path) {\r\n                var coords = lastPath.getCoordinates();\r\n                coordinates.push(coords[coords.length - 2]);\r\n            }\r\n            coordinates.push.apply(coordinates, path.getCoordinates());\r\n            if (coordinates.length < 3)\r\n                return 0;\r\n            var total = 0;\r\n            for (var i = 0; i < coordinates.length - 2; i += 1) {\r\n                var _a = coordinates[i], x1 = _a[0], y1 = _a[1];\r\n                var _b = coordinates[i + 1], x2 = _b[0], y2 = _b[1];\r\n                var _c = coordinates[i + 2], x3 = _c[0], y3 = _c[1];\r\n                var slope1 = (y2 - y1) / (x2 - x1);\r\n                var slope2 = (y3 - y2) / (x3 - x2);\r\n                var arctan1 = Math.atan(slope1);\r\n                var acrtan2 = Math.atan(slope2);\r\n                total += Math.abs(acrtan2 - arctan1) * 0.5;\r\n            }\r\n            return total;\r\n        };\r\n        G.COST_CONN_ELEVATOR = 90;\r\n        G.COST_CONN_CONTINUOUS_ELEVATOR = 20;\r\n        G.COST_CONN_STAIR = 170;\r\n        G.COST_CONN_OTHER = 60;\r\n        G.COST_CONN_UNREACH = 1000;\r\n        G.BASIC_FLOOR_HEIGHT = 5;\r\n        return G;\r\n    }());\n\n    var H = (function () {\r\n        function H() {\r\n        }\r\n        H.prototype.H = function (current, end) {\r\n            var altitudeDelta = Math.abs(current.getAltitude() - end.getAltitude());\r\n            return altitudeDelta + current.distanceTo(end);\r\n        };\r\n        return H;\r\n    }());\n\n    var ArraySet = (function () {\r\n        function ArraySet(values) {\r\n            this._idMap = new Map();\r\n            this._list = [];\r\n            if (values) {\r\n                this._list = values;\r\n                for (var i = 0; i < values.length; i += 1) {\r\n                    this._idMap.set(values[i].id, i);\r\n                }\r\n            }\r\n        }\r\n        ArraySet.prototype.set = function (item) {\r\n            var index = this._idMap.get(item.id);\r\n            if (typeof index === 'number') {\r\n                this._list[index] = item;\r\n            }\r\n            else {\r\n                this._list.push(item);\r\n                this._idMap.set(item.id, this._list.length - 1);\r\n            }\r\n        };\r\n        ArraySet.prototype.delete = function (item) {\r\n            var id = item.id;\r\n            var index = this._idMap.get(id);\r\n            if (typeof index === 'number') {\r\n                this._list.splice(index, 1);\r\n                this._idMap.delete(id);\r\n                this._updateIndex(index);\r\n            }\r\n        };\r\n        ArraySet.prototype._updateIndex = function (startIndex) {\r\n            for (var i = startIndex; i < this._list.length; i += 1) {\r\n                this._idMap.set(this._list[i].id, i);\r\n            }\r\n        };\r\n        ArraySet.prototype.size = function () {\r\n            return this._list.length;\r\n        };\r\n        ArraySet.prototype.has = function (item) {\r\n            return this._idMap.has(item.id);\r\n        };\r\n        ArraySet.prototype.getValues = function () {\r\n            return this._list;\r\n        };\r\n        ArraySet.prototype.getById = function (id) {\r\n            var index = this._idMap.get(id);\r\n            if (typeof index === 'number') {\r\n                return this._list[index];\r\n            }\r\n        };\r\n        ArraySet.prototype.clear = function () {\r\n            this._idMap.clear();\r\n            this._list.length = 0;\r\n        };\r\n        ArraySet.prototype.shift = function () {\r\n            var item = this._list.shift();\r\n            if (item) {\r\n                this._idMap.delete(item.id);\r\n                this._updateIndex(0);\r\n            }\r\n            return item;\r\n        };\r\n        ArraySet.prototype.pop = function () {\r\n            var item = this._list.pop();\r\n            if (item) {\r\n                this._idMap.delete(item.id);\r\n            }\r\n            return item;\r\n        };\r\n        ArraySet.prototype.valuesConcat = function (set) {\r\n            return this._list.concat(set._list);\r\n        };\r\n        ArraySet.prototype.get = function (index) {\r\n            return this._list[index];\r\n        };\r\n        return ArraySet;\r\n    }());\n\n    var RoadEngine = (function () {\r\n        function RoadEngine(data, options) {\r\n            this._options = options;\r\n            this._loader = new Loader(data);\r\n            this._g = new G();\r\n            this._h = new H();\r\n        }\r\n        RoadEngine.prototype.calculate = function (start, startShop, end, endShop, strategies) {\r\n            this._loader.reset();\r\n            var startPolygon = RoadEngine.getContainPolygon(startShop, start.coordinate);\r\n            var startVertex = this._loader.getClosestVertex(start, startPolygon);\r\n            var endPolygon = RoadEngine.getContainPolygon(endShop, end.coordinate);\r\n            var endVertex = this._loader.getClosestVertex(end, endPolygon);\r\n            if (!startVertex || !endVertex)\r\n                return [];\r\n            var result = [];\r\n            for (var i = 0; i < strategies.length; i += 1) {\r\n                var types = STRATEGY_TYPE[strategies[i]];\r\n                this._loader.setRecommendType(types);\r\n                var res = this._aStar(startVertex, endVertex);\r\n                if (res) {\r\n                    result.push({\r\n                        strategy: strategies[i],\r\n                        route: {\r\n                            type: 'FeatureCollection',\r\n                            features: this._normalizeResult(res),\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        RoadEngine.prototype._aStar = function (start, end) {\r\n            var openList = new ArraySet([start]);\r\n            var closeList = new ArraySet();\r\n            ret: while (openList.size() !== 0) {\r\n                var current = RoadEngine.getLowerGAndHVertex(openList.getValues());\r\n                openList.delete(current);\r\n                closeList.set(current);\r\n                if (current.equal(end)) {\r\n                    break;\r\n                }\r\n                var paths = __spreadArrays(current.getPaths(), current.getConnections());\r\n                for (var i = 0; i < paths.length; i += 1) {\r\n                    var vertex_1 = paths[i].getTo();\r\n                    if (vertex_1.equal(end)) {\r\n                        vertex_1.setParent(current);\r\n                        closeList.set(vertex_1);\r\n                        break ret;\r\n                    }\r\n                    if (!closeList.has(vertex_1)) {\r\n                        var g = this._g.G(current, paths[i], start.getFloorId() === end.getFloorId()) + current.getG();\r\n                        var h = this._h.H(vertex_1, end);\r\n                        if (!openList.has(vertex_1)) {\r\n                            vertex_1.setG(g);\r\n                            vertex_1.setH(h);\r\n                            vertex_1.setParent(current);\r\n                            openList.set(vertex_1);\r\n                        }\r\n                        else {\r\n                            vertex_1 = openList.getById(vertex_1.getNodeId());\r\n                            if (g + h < vertex_1.getG() + vertex_1.getH()) {\r\n                                vertex_1.setG(g);\r\n                                vertex_1.setH(h);\r\n                                vertex_1.setParent(current);\r\n                                openList.delete(vertex_1);\r\n                                openList.set(vertex_1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            var vertices = closeList.getValues();\r\n            var vertex = vertices[vertices.length - 1];\r\n            if (vertex && vertex.equal(end)) {\r\n                return RoadEngine.genLineString(vertex);\r\n            }\r\n            return null;\r\n        };\r\n        RoadEngine.prototype._isCanConcat = function (angleDelta, length) {\r\n            var _a = this._options, maxAngleDiff = _a.maxAngleDiff, minLineLength = _a.minLineLength;\r\n            return angleDelta < maxAngleDiff || length < minLineLength;\r\n        };\r\n        RoadEngine.prototype._normalizeResult = function (features) {\r\n            if (features.length === 0)\r\n                return [];\r\n            var angle = features[0].angle;\r\n            var result = [{\r\n                    type: 'Feature',\r\n                    geometry: {\r\n                        type: 'LineString',\r\n                        coordinates: features[0].geometry,\r\n                    },\r\n                    properties: features[0].properties,\r\n                }];\r\n            for (var i = 1; i < features.length; i += 1) {\r\n                var angleDelta = Math.abs(features[i].angle - angle);\r\n                var last = result[result.length - 1];\r\n                var _a = features[i], properties = _a.properties, length = _a.length;\r\n                if (properties.floor === last.properties.floor && this._isCanConcat(angleDelta, length)) {\r\n                    last.geometry.coordinates[1] = features[i].geometry[1];\r\n                    last.properties = __assign(__assign({}, last.properties), properties);\r\n                    var _b = last.geometry.coordinates, start = _b[0], end = _b[1];\r\n                    angle = new Vector2(start, end).angleTo(new Vector2([0, 1]));\r\n                }\r\n                else {\r\n                    angle = features[i].angle;\r\n                    result.push({\r\n                        type: 'Feature',\r\n                        geometry: {\r\n                            type: 'LineString',\r\n                            coordinates: features[i].geometry,\r\n                        },\r\n                        properties: properties,\r\n                    });\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        RoadEngine.genLineString = function (endVertex) {\r\n            var result = [];\r\n            var lastVertex;\r\n            Vertex.deepEach(endVertex, function (vertex) {\r\n                var parent = vertex.getParent();\r\n                if (parent) {\r\n                    var path = parent.findPath(vertex);\r\n                    var grandpa = parent.getParent();\r\n                    var conn = (grandpa && grandpa.findConnection(parent))\r\n                        || (lastVertex && vertex.findConnection(lastVertex));\r\n                    if (path) {\r\n                        var arr = path.toLineJson();\r\n                        var itemResult = [];\r\n                        for (var i = 0; i < arr.length; i += 1) {\r\n                            var properties = {\r\n                                floor: arr[i].floor,\r\n                                altitude: path.getAltitude(),\r\n                                floorAddress: path.getFloorAddress(),\r\n                                pathType: '',\r\n                            };\r\n                            if (conn) {\r\n                                properties.category = conn.getCategory();\r\n                            }\r\n                            itemResult.push(__assign(__assign({}, arr[i]), { properties: properties }));\r\n                        }\r\n                        result.unshift.apply(result, itemResult);\r\n                    }\r\n                }\r\n                lastVertex = vertex;\r\n            });\r\n            return result;\r\n        };\r\n        RoadEngine.getLowerGAndHVertex = function (list) {\r\n            var min = list[0].getG() + list[0].getH();\r\n            var index = 0;\r\n            for (var i = 1; i < list.length; i += 1) {\r\n                var item = list[i].getG() + list[i].getH();\r\n                if (item < min) {\r\n                    min = item;\r\n                    index = i;\r\n                }\r\n            }\r\n            return list[index];\r\n        };\r\n        RoadEngine.getContainPolygon = function (shop, coordinate) {\r\n            for (var i = shop.length - 1; i >= 0; i -= 1) {\r\n                var _a = shop[i], geometry = _a.geometry, properties = _a.properties;\r\n                if (geometry.type === 'Polygon') {\r\n                    var isContain = contain(geometry.coordinates, [coordinate.x, coordinate.y]);\r\n                    if (isContain) {\r\n                        return {\r\n                            coordinates: geometry.coordinates,\r\n                            doorIds: (properties || {}).doorIds || [],\r\n                        };\r\n                    }\r\n                }\r\n                else if (geometry.type === 'MultiPolygon') {\r\n                    for (var j = 0; j < geometry.coordinates.length; j += 1) {\r\n                        var isContain = contain(geometry.coordinates[j], [coordinate.x, coordinate.y]);\r\n                        if (isContain) {\r\n                            return {\r\n                                coordinates: geometry.coordinates[j],\r\n                                doorIds: (properties || {}).doorIds || [],\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        return RoadEngine;\r\n    }());\n\n    var engine;\r\n    onmessage = function (_a) {\r\n        var data = _a.data;\r\n        if (data.type === 'init') {\r\n            var t = data;\r\n            if (!engine) {\r\n                engine = new RoadEngine(t.roadData, t.options);\r\n            }\r\n        }\r\n        else if (data.type === 'calculate') {\r\n            var t = data;\r\n            var result = [];\r\n            if (engine) {\r\n                result = engine.calculate(t.start, t.startShop, t.end, t.endShop, t.strategies);\r\n            }\r\n            postMessage(result);\r\n        }\r\n    };\n\n})();\n");

    var defaultOptions$3 = {
        server: 'https://pmap.ipalmap.com/pathplan/pathDemo/navi',
        useCache: true,
    };
    var RoadCalculate = (function () {
        function RoadCalculate(mapView, options) {
            var _this = this;
            this._worker = new Worker$1();
            this._mapView = mapView;
            this._options = __assign$1(__assign$1({}, defaultOptions$3), options);
            this._res = new DataSource({
                server: this._options.server,
                useCache: this._options.useCache,
            });
            this._loadPromise = this._init();
            this._loadPromise.then(function () { return delete _this._loadPromise; });
            this._worker.addEventListener('message', function (_a) {
                var data = _a.data;
                if (_this._dataResolve) {
                    _this._dataResolve(data);
                    delete _this._dataResolve;
                    delete _this._dataPromise;
                }
            });
        }
        RoadCalculate.prototype._init = function () {
            return __awaiter(this, void 0, void 0, function () {
                var roadNetData, data;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this._res.requestRoadNet(this._options.bdId)];
                        case 1:
                            roadNetData = _a.sent();
                            this._roadNetData = roadNetData;
                            data = {
                                type: 'init',
                                roadData: roadNetData,
                                options: {
                                    maxAngleDiff: 3,
                                    minLineLength: 0.3,
                                },
                            };
                            this._worker.postMessage(data);
                            return [2];
                    }
                });
            });
        };
        RoadCalculate.prototype.getData = function () {
            return this._roadNetData;
        };
        RoadCalculate.prototype.getLoadedPromise = function () {
            return this._loadPromise;
        };
        RoadCalculate.prototype.loaded = function () {
            return !this._loadPromise;
        };
        RoadCalculate.prototype.calculate = function (startPosition, endPosition, strategies) {
            return __awaiter(this, void 0, Promise, function () {
                var startShop, endShop, data;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, this._mapView.getPlanarGraph(startPosition.floorId)];
                        case 1:
                            startShop = (_a.sent()).shop;
                            return [4, this._mapView.getPlanarGraph(endPosition.floorId)];
                        case 2:
                            endShop = (_a.sent()).shop;
                            data = {
                                type: 'calculate',
                                start: startPosition,
                                end: endPosition,
                                strategies: strategies,
                                startShop: startShop,
                                endShop: endShop,
                            };
                            if (!this._dataPromise) return [3, 4];
                            return [4, this._dataPromise];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4: return [2, this._calculate(data)];
                    }
                });
            });
        };
        RoadCalculate.prototype._calculate = function (data) {
            var _this = this;
            this._worker.postMessage(data);
            this._dataPromise = new Promise(function (resolve) {
                _this._dataResolve = resolve;
            });
            return this._dataPromise;
        };
        return RoadCalculate;
    }());

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var fetchJsonp = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      {
        factory(exports, module);
      }
    })(commonjsGlobal, function (exports, module) {

      var defaultOptions = {
        timeout: 5000,
        jsonpCallback: 'callback',
        jsonpCallbackFunction: null
      };

      function generateCallbackFunction() {
        return 'jsonp_' + Date.now() + '_' + Math.ceil(Math.random() * 100000);
      }

      function clearFunction(functionName) {
        // IE8 throws an exception when you try to delete a property on window
        // http://stackoverflow.com/a/1824228/751089
        try {
          delete window[functionName];
        } catch (e) {
          window[functionName] = undefined;
        }
      }

      function removeScript(scriptId) {
        var script = document.getElementById(scriptId);
        if (script) {
          document.getElementsByTagName('head')[0].removeChild(script);
        }
      }

      function fetchJsonp(_url) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // to avoid param reassign
        var url = _url;
        var timeout = options.timeout || defaultOptions.timeout;
        var jsonpCallback = options.jsonpCallback || defaultOptions.jsonpCallback;

        var timeoutId = undefined;

        return new Promise(function (resolve, reject) {
          var callbackFunction = options.jsonpCallbackFunction || generateCallbackFunction();
          var scriptId = jsonpCallback + '_' + callbackFunction;

          window[callbackFunction] = function (response) {
            resolve({
              ok: true,
              // keep consistent with fetch API
              json: function json() {
                return Promise.resolve(response);
              }
            });

            if (timeoutId) clearTimeout(timeoutId);

            removeScript(scriptId);

            clearFunction(callbackFunction);
          };

          // Check if the user set their own params, and if not add a ? to start a list of params
          url += url.indexOf('?') === -1 ? '?' : '&';

          var jsonpScript = document.createElement('script');
          jsonpScript.setAttribute('src', '' + url + jsonpCallback + '=' + callbackFunction);
          if (options.charset) {
            jsonpScript.setAttribute('charset', options.charset);
          }
          if (options.nonce) {
            jsonpScript.setAttribute('nonce', options.nonce);
          }
          if (options.referrerPolicy) {
            jsonpScript.setAttribute('referrerPolicy', options.referrerPolicy);
          }
          jsonpScript.id = scriptId;
          document.getElementsByTagName('head')[0].appendChild(jsonpScript);

          timeoutId = setTimeout(function () {
            reject(new Error('JSONP request to ' + _url + ' timed out'));

            clearFunction(callbackFunction);
            removeScript(scriptId);
            window[callbackFunction] = function () {
              clearFunction(callbackFunction);
            };
          }, timeout);

          // Caught if got 404/500
          jsonpScript.onerror = function () {
            reject(new Error('JSONP request to ' + _url + ' failed'));

            clearFunction(callbackFunction);
            removeScript(scriptId);
            if (timeoutId) clearTimeout(timeoutId);
          };
        });
      }

      // export as global function
      /*
      let local;
      if (typeof global !== 'undefined') {
        local = global;
      } else if (typeof self !== 'undefined') {
        local = self;
      } else {
        try {
          local = Function('return this')();
        } catch (e) {
          throw new Error('polyfill failed because global object is unavailable in this environment');
        }
      }
      local.fetchJsonp = fetchJsonp;
      */

      module.exports = fetchJsonp;
    });
    });

    var NaviHttpClient = (function (_super) {
        __extends$1(NaviHttpClient, _super);
        function NaviHttpClient(server) {
            if (server === void 0) { server = ''; }
            return _super.call(this, server) || this;
        }
        NaviHttpClient.prototype._packagePromise = function (xhr) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                xhr.onload = function () {
                    var resContentType = xhr.getResponseHeader('Content-Type') || '';
                    if (xhr.readyState === 4) {
                        var jsonObj = { data: null,
                            txtTip: '',
                            serverStatus: 200 };
                        var status = xhr.status;
                        if (status === 200) {
                            if (/application\/json/.test(resContentType) &&
                                typeof xhr.response === 'string') {
                                jsonObj.data = JSON.parse(xhr.response);
                                jsonObj.txtTip = '';
                                jsonObj.txtTip = jsonObj.data.message;
                                jsonObj.serverStatus = 200;
                                var code = jsonObj.data.code;
                                if (code == 0 || code == 200) ;
                                else {
                                    jsonObj.serverStatus = code;
                                }
                                resolve(jsonObj);
                            }
                            else {
                                resolve(xhr.response);
                            }
                        }
                        else if (status === 400) {
                            if (/application\/json/.test(resContentType) &&
                                typeof xhr.response === 'string') {
                                jsonObj.data = JSON.parse(xhr.response);
                                jsonObj.txtTip = '褰撳墠璧风粓鐐规棤娉曚负鎮ㄨ鍒掕矾寰�';
                                jsonObj.txtTip = jsonObj.data.message;
                                jsonObj.serverStatus = 400;
                                resolve(jsonObj);
                            }
                            else {
                                resolve(xhr.response);
                            }
                        }
                        else if (status === 500) {
                            if (/application\/json/.test(resContentType) &&
                                typeof xhr.response === 'string') {
                                jsonObj.data = JSON.parse(xhr.response);
                                jsonObj.txtTip = '璺畻寮曟搸缁存姢涓紝璇风◢鍚庡啀璇�';
                                jsonObj.txtTip = jsonObj.data.message;
                                jsonObj.serverStatus = 500;
                                resolve(jsonObj);
                            }
                            else {
                                resolve(xhr.response);
                            }
                        }
                        else {
                            if (/application\/json/.test(resContentType) &&
                                typeof xhr.response === 'string') {
                                resolve(JSON.parse(xhr.response));
                            }
                            else {
                                resolve(xhr.response);
                            }
                        }
                    }
                    else {
                        reject(xhr.response);
                    }
                    delete _this._xhr;
                };
                xhr.onerror = function (err) {
                    reject(err);
                    delete _this._xhr;
                };
                xhr.ontimeout = function () {
                    reject(new Error('褰撳墠缃戠粶寮傚父锛岃妫€鏌ョ綉缁滃悗閲嶈瘯'));
                    delete _this._xhr;
                };
                xhr.onabort = function () {
                    reject(new Error('褰撳墠缃戠粶娉㈠姩锛岃绋嶅悗閲嶈瘯'));
                    delete _this._xhr;
                };
            });
        };
        return NaviHttpClient;
    }(HttpClient));

    var defaultOptions$2 = {
        isFillet: false,
        filletNumber: 4,
        filletDistance: 3,
        multilineOpacity: 0.8,
        defaultFloorGap: 2,
        recommendRouteType: 'escalator',
    };
    var NaviManager = (function () {
        function NaviManager(mapView, options) {
            this._routesArray = [];
            this._isShowMultiline = true;
            this._floorOrder = [];
            this._forcedStrategies = [];
            this._isForcedStrategiesAllFloor = false;
            this._routesCache = new Map();
            this._routesEmptyCache = [];
            this._client = new NaviHttpClient();
            this._mapView = mapView;
            this._options = __assign$1(__assign$1({}, defaultOptions$2), options);
            bindAll([
                '_onChangeFloor',
                '_onChangeViewType',
            ], this);
            this._mapView.on('changeFloor', this._onChangeFloor);
            this._mapView.on('changeViewType', this._onChangeViewType);
            if (this._options.offline) {
                this._roadCalc = new RoadCalculate(this._mapView, {
                    bdId: this._mapView.getBdId(),
                });
            }
            if (this._options.grayImage) {
                this._grayLayer = new LineLayer({
                    lineImage: this._options.grayImage,
                    lineWidth: this._options.lineWidth,
                    base: this._options.lineHeight,
                });
                this._grayLayer.SetGray(true);
                this._grayLayer.setSync(false);
            }
        }
        NaviManager.prototype._onChangeViewType = function () {
            if (this._mapView.getViewType() === 'single') {
                this._removeConnectionLayers();
            }
            else {
                this._addConnectionLayers();
                this.hasNavi() && this._mapView.highlightFloor(this._floorOrder);
            }
            this._removeLineLayers();
            this._addLineLayers(this._mapView.currentFloor);
            this._removeMultiLineLayers();
            if (this._isShowMultiline) {
                this._addMultiLineLayers(this._mapView.currentFloor);
            }
        };
        NaviManager.prototype.getFloorOrder = function () {
            return this._floorOrder;
        };
        NaviManager.prototype._onChangeFloor = function (floorId) {
            if (!this._activeRoute || this._mapView.getViewType() === 'multiple')
                return;
            this._removeLineLayers();
            this._addLineLayers(floorId);
            this._removeMultiLineLayers();
            if (this._isShowMultiline) {
                this._addMultiLineLayers(floorId);
            }
        };
        NaviManager.prototype.getNaviBounds = function (mode) {
            if (mode === void 0) { mode = false; }
            if (mode && !this._outdoorRoute)
                return;
            if (!mode && !this._activeRoute)
                return;
            var features = mode ? this._outdoorRoute : this._activeRoute;
            var minX, minY, maxX, maxY;
            for (var i = 0; i < features.length; i += 1) {
                var _a = features[i], coordinates = _a.geometry.coordinates, properties = _a.properties;
                if (properties.floor === this._mapView.currentFloor) {
                    for (var j = 0; j < coordinates.length; j += 1) {
                        var _b = coordinates[j], x = _b[0], y = _b[1];
                        minX = minX ? (x < minX ? x : minX) : x;
                        minY = minY ? (y < minY ? y : minY) : y;
                        maxX = maxX ? (x > maxX ? x : maxX) : x;
                        maxY = maxY ? (y > maxY ? y : maxY) : y;
                    }
                }
            }
            if (minX && minY && maxX && maxY) {
                var bounds = {
                    topLeft: { x: minX, y: maxY },
                    bottomRight: { x: maxX, y: minY },
                };
                return bounds;
            }
        };
        NaviManager.prototype.renderNaviByJson = function (json, startPosition, endPosition) {
            var jsonObj = json;
            if (typeof json === 'string') {
                jsonObj = JSON.parse(json);
            }
            this._routesArray = jsonObj;
            startPosition.floorId; startPosition.coordinate;
            endPosition.floorId; endPosition.coordinate;
            var _a = this._options; _a.server; var strategies = _a.strategies; _a.isFillet; _a.filletDistance; _a.filletNumber;
            this._activeRouteType ? [this._activeRouteType] : strategies;
            LogMgr$1.log('NaviManager.ts renderNavi 185 ' + this._routesArray);
            this.setActiveRoute(this._routesArray[0].strategy);
        };
        NaviManager.prototype.renderNavi = function (startPosition, endPosition) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._routesCache.clear();
                            this._routesEmptyCache.length = 0;
                            this._startPosition = startPosition;
                            this._endPosition = endPosition;
                            return [4, this._renderNavi(startPosition, endPosition)];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        NaviManager.prototype._renderNavi = function (startPosition, endPosition) {
            return __awaiter(this, void 0, void 0, function () {
                var startFloor, startCoord, endFloor, endCoord, _a, server, isFillet, filletDistance, filletNumber, strates, serverStatus, tip, data, res;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (startPosition == null || startPosition == undefined
                                || endPosition == null || endPosition == undefined) {
                                return [2];
                            }
                            startFloor = startPosition.floorId, startCoord = startPosition.coordinate;
                            endFloor = endPosition.floorId, endCoord = endPosition.coordinate;
                            _a = this._options, server = _a.server, isFillet = _a.isFillet, filletDistance = _a.filletDistance, filletNumber = _a.filletNumber;
                            strates = this._activeRouteType ? [this._activeRouteType] : [this._options.defaultStrategy];
                            if (this._forcedStrategies.length > 0) {
                                if (startFloor === endFloor && !this._isForcedStrategiesAllFloor) {
                                    strates = ['shortest'];
                                }
                                else {
                                    strates = this._forcedStrategies;
                                }
                            }
                            serverStatus = 200;
                            tip = '';
                            if (!(this._roadCalc && this._roadCalc.loaded())) return [3, 2];
                            return [4, this._roadCalc.calculate(startPosition, endPosition, strates)];
                        case 1:
                            data = _b.sent();
                            return [3, 4];
                        case 2:
                            this._client.cancel();
                            return [4, this._client.post(server, {
                                    json: {
                                        from_floor: startFloor,
                                        from_x: startCoord.x,
                                        from_y: startCoord.y,
                                        to_floor: endFloor,
                                        to_x: endCoord.x,
                                        to_y: endCoord.y,
                                        strategies: strates,
                                        isFillet: isFillet,
                                        filletDistance: filletDistance,
                                        filletNumber: filletNumber,
                                        limitLength: this._options.startLimitLength,
                                    },
                                })];
                        case 3:
                            res = _b.sent();
                            serverStatus = res.serverStatus;
                            tip = res.txtTip;
                            if (res.data && res.data.data) {
                                data = res.data.data;
                            }
                            _b.label = 4;
                        case 4:
                            if (serverStatus != 200) {
                                this._routesEmptyCache.push(strates[0]);
                                this._removeLineLayers();
                                this._removeMultiLineLayers();
                                this._floorOrder.length = 0;
                                throw new Error(tip);
                            }
                            else if (!data || data.length === 0) {
                                this._routesEmptyCache.push(strates[0]);
                                this._removeLineLayers();
                                this._removeMultiLineLayers();
                                this._floorOrder.length = 0;
                                throw new Error('renderNavi: 瑙勫垝璺嚎澶辫触锛�');
                            }
                            this._routesCache.set(strates[0], data[0]);
                            this._routesArray = data;
                            this.renderNaviByJson(data, startPosition, endPosition);
                            this.setActiveRoute(this._routesArray[0].strategy);
                            return [2];
                    }
                });
            });
        };
        NaviManager.prototype.setForcedStrategies = function (strategies, isForced) {
            this._forcedStrategies = strategies;
            if (isForced !== undefined) {
                this._isForcedStrategiesAllFloor = isForced;
            }
        };
        NaviManager.prototype.clearForcedStrategies = function () {
            this._forcedStrategies = [];
        };
        NaviManager.prototype.resetStartEnd = function (startPosition, endPosition) {
            this._routesCache.clear();
            this._routesEmptyCache.length = 0;
            this._startPosition = startPosition;
            this._endPosition = endPosition;
        };
        NaviManager.prototype._lngLatToMercator = function (_a, isArray) {
            var lng = _a[0], lat = _a[1];
            if (isArray === void 0) { isArray = false; }
            var x = Number(lng) * 20037508.34 / 180;
            var y = Math.log(Math.tan((90 + Number(lat)) * Math.PI / 360)) / (Math.PI / 180);
            y = y * 20037508.34 / 180;
            return isArray ? [x, y] : { x: x, y: y };
        };
        NaviManager.prototype.renderOutDoorNavi = function (origin, destination, floorId) {
            if (floorId === void 0) { floorId = this._mapView.currentFloor; }
            return __awaiter(this, void 0, void 0, function () {
                var result, polyline, distance, duration, steps, diff, total, stepLength, removeStep, pathIndex, lastStep, features, i, data;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, fetchJsonp("https://apis.map.qq.com/ws/direction/v1/driving?output=jsonp&from=" + origin.join(',') + "&to=" + destination.join(',') + "&key=DVRBZ-RTPKP-KBKDH-VHFG3-TDOH6-ZYFAX")
                                .then(function (response) {
                                LogMgr$1.log('zhengli renderOutDoorNavi 1');
                                return response.json();
                            })];
                        case 1:
                            result = _a.sent();
                            if (result.status !== 0)
                                throw new Error('renderOutDoorNavi: 瑙勫垝瀹ゅ璺嚎澶辫触锛�');
                            polyline = result.result.routes[0].polyline, distance = result.result.routes[0].distance, duration = result.result.routes[0].duration, steps = [
                                this._lngLatToMercator([polyline[1], polyline[0]]),
                            ], diff = 0, total = 5000, stepLength = 0, removeStep = 0, pathIndex = 0, lastStep = [], features = [];
                            for (i = 2; i < polyline.length; i += 2) {
                                polyline[i] = Number(Number(polyline[i - 2] + polyline[i] / 1000000).toFixed(6));
                                polyline[i + 1] = Number(Number(polyline[i - 1] + polyline[i + 1] / 1000000).toFixed(6));
                                steps.push(this._lngLatToMercator([polyline[i + 1], polyline[i]], true));
                            }
                            diff = steps.length - total;
                            stepLength = steps.length;
                            lastStep = steps.pop();
                            if (steps.length > total) {
                                if (diff > 0) {
                                    if (2 * diff < steps.length) {
                                        removeStep = Math.floor(stepLength / (diff + 1));
                                        while (diff > 0 && pathIndex < steps.length) {
                                            pathIndex += removeStep;
                                            steps.splice(pathIndex, 1);
                                            --pathIndex;
                                            --diff;
                                        }
                                    }
                                    else {
                                        removeStep = Math.floor(stepLength / (stepLength - diff - 1));
                                        while (diff > 0 && pathIndex + removeStep + 1 < steps.length) {
                                            steps.splice(pathIndex, removeStep);
                                            ++pathIndex;
                                            diff -= removeStep;
                                        }
                                    }
                                }
                            }
                            steps.push(lastStep);
                            steps.reduce(function (preStep, curStep, index) {
                                if (!index)
                                    return curStep;
                                features.push({
                                    direction: 1,
                                    featureId: 'outdoor-' + index,
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: [preStep, curStep]
                                    },
                                    properties: {
                                        altitude: 1,
                                        belong: 'outdoor',
                                        category: null,
                                        endIndex: null,
                                        escalator: null,
                                        filletFlag: null,
                                        floor: floorId,
                                        floorAddress: 'F1',
                                        hasTransitPoint: false,
                                        name: '瀹ゅ',
                                        pathType: null,
                                        startIndex: null,
                                    },
                                    type: null,
                                });
                                return curStep;
                            });
                            data = {
                                route: {
                                    features: features,
                                    type: 'FeatureCollection'
                                },
                                strategy: 'shortest'
                            };
                            this._routesArray = [data];
                            this.setOutDoorActiveRoute(this._routesArray[0].strategy);
                            return [2, { distance: Number(distance), duration: Number(duration) }];
                    }
                });
            });
        };
        NaviManager.prototype.setOutDoorActiveRoute = function (routeType) {
            var res = this._routesArray.find(function (item) { return item.strategy === routeType; });
            if (!res) {
                console.error(routeType + " is not exit");
                return;
            }
            this._activeRouteType = routeType;
            this._outdoorRoute = res.route.features;
            var features = this._outdoorRoute;
            var floorId = features[0].properties.floor;
            this._addOutdoorLineLayers(floorId);
            var engine = this._mapView.getEngine();
            engine && engine.render();
        };
        NaviManager.prototype._addOutdoorLineLayers = function (floorId) {
            if (!this._outdoorRoute)
                return;
            var features = this._outdoorRoute;
            if (!this._outLineLayers) {
                this._outLineLayers = [];
            }
            if (this._mapView.getViewType() === 'multiple') {
                for (var i = 0; i < this._floorOrder.length; i += 1) {
                    var filterFeatures = NaviManager.processFeatures(features, this._floorOrder[i]);
                    if (filterFeatures.length !== 0) {
                        var lineLayer = this._createLineLayer(this._floorOrder[i], filterFeatures, 1);
                        this._outLineLayers.push(lineLayer);
                    }
                }
            }
            else {
                var filterFeatures = NaviManager.processFeatures(features, floorId);
                if (filterFeatures.length === 0)
                    return;
                var lineLayer = this._createLineLayer(floorId, filterFeatures, 1);
                this._outLineLayers.push(lineLayer);
            }
            this._mapView.addLayers(this._outLineLayers);
        };
        NaviManager.prototype.setActiveRoute = function (routeType) {
            return __awaiter(this, void 0, void 0, function () {
                var res, res, features, map, i, floorId, engine;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._activeRouteType = routeType;
                            if (!(this._routesCache && this._routesCache.has(routeType))) return [3, 1];
                            res = this._routesCache.get(routeType);
                            this._activeRoute = res && res.route.features;
                            return [3, 4];
                        case 1:
                            if (!(this._routesEmptyCache.indexOf(routeType) !== -1)) return [3, 2];
                            this._removeLineLayers();
                            this._removeMultiLineLayers();
                            this._floorOrder.length = 0;
                            throw new Error('renderNavi: 鏃犳绛栫暐璺嚎锛�');
                        case 2: return [4, this._renderNavi(this._startPosition, this._endPosition)];
                        case 3:
                            _a.sent();
                            res = this._routesArray.find(function (item) { return item.strategy === _this._activeRouteType; });
                            if (!res) {
                                console.error(routeType + " is not exit");
                                return [2];
                            }
                            this._routesCache.set(routeType, res);
                            this._activeRoute = res.route.features;
                            _a.label = 4;
                        case 4:
                            this._floorOrder.length = 0;
                            if (!this._activeRoute) {
                                console.error('no active route');
                                return [2];
                            }
                            features = this._activeRoute;
                            map = new Map();
                            for (i = 0; i < features.length; i += 1) {
                                if (!map.get(features[i].properties.floor)) {
                                    this._floorOrder.push(features[i].properties.floor);
                                    map.set(features[i].properties.floor, true);
                                }
                            }
                            floorId = this._mapView.currentFloor;
                            this._removeLineLayers();
                            this._addLineLayers(floorId);
                            this._removeMultiLineLayers();
                            this._addMultiLineLayers(floorId);
                            if (this._mapView.getViewType() === 'multiple') {
                                this._removeConnectionLayers();
                                this._addConnectionLayers();
                                this._mapView.highlightFloor(this._floorOrder);
                            }
                            engine = this._mapView.getEngine();
                            engine && engine.render();
                            return [2];
                    }
                });
            });
        };
        NaviManager.prototype.getLinesByFloor = function (floorId) {
            if (!this._activeRoute)
                return [];
            var result = [];
            var features = this._activeRoute;
            for (var i = 0; i < features.length; i += 1) {
                var _a = features[i], coordinates = _a.geometry.coordinates, properties = _a.properties;
                if (properties.floor === floorId) {
                    var start = coordinates[0], end = coordinates[1];
                    result.push([
                        new Point(start[0], start[1]),
                        new Point(end[0], end[1]),
                    ]);
                }
            }
            return result;
        };
        NaviManager.prototype.getRoutes = function () {
            if (!this._activeRoute)
                return [];
            var features = this._activeRoute;
            var result = [];
            for (var i = 0; i < features.length; i += 1) {
                var _a = features[i], _b = _a.geometry.coordinates, start = _b[0], end = _b[1], properties = _a.properties;
                result.push({
                    line: [
                        new Point(start[0], start[1]),
                        new Point(end[0], end[1]),
                    ],
                    floor: properties.floor,
                });
            }
            return result;
        };
        NaviManager.prototype.setWalked = function (floorId, coordinate, index) {
            if (this._mapView.getViewType() === 'multiple') {
                console.error('setWalked: multiple is not support');
                return;
            }
            var lineLayer = this._lineLayers && this._lineLayers[0];
            if (!this._activeRoute || !lineLayer)
                return;
            var features = this._activeRoute;
            if (index < 0 || index >= features.length)
                return;
            var filterFeatures = features.slice(index + 1);
            var coordinates = features[index].geometry.coordinates;
            filterFeatures.unshift({
                type: 'Feature',
                properties: features[index].properties,
                geometry: {
                    type: 'LineString',
                    coordinates: [
                        [coordinate.x, coordinate.y],
                        coordinates[1]
                    ],
                },
            });
            var resultFeatures = NaviManager.processFeatures(filterFeatures, floorId);
            if (resultFeatures.length !== 0) {
                lineLayer.setFeatures(resultFeatures);
                lineLayer.setFloorId(floorId);
                this._mapView.updateLayer(lineLayer);
                this.renderShortest(coordinate, resultFeatures, floorId);
            }
        };
        NaviManager.prototype.setAllWalked = function () {
            this._removeLineLayers();
        };
        NaviManager.prototype.getActiveRoute = function () {
            return this._activeRoute;
        };
        NaviManager.prototype._getFloorStop = function (startFloor, endFloor, order) {
            if (startFloor === endFloor)
                return [];
            var floors = Array.from(this._mapView.getFloors());
            order < 0 && floors.reverse();
            var result = [startFloor];
            var isStart = false;
            for (var i = 0; i < floors.length; i += 1) {
                if (floors[i].flId === endFloor) {
                    break;
                }
                if (isStart) {
                    result.push(floors[i].flId);
                }
                if (floors[i].flId === startFloor) {
                    isStart = true;
                }
            }
            return result;
        };
        NaviManager.prototype._addConnectionLayers = function () {
            if (!this._activeRoute)
                return;
            if (!this._connectionLayers) {
                this._connectionLayers = [];
            }
            var features = this._activeRoute;
            if (features.length === 0)
                return;
            var curFloor = features[0].properties.floor;
            for (var i = 1; i < features.length; i += 1) {
                if (features[i].properties.floor !== curFloor) {
                    var curNum = this._mapView.getFloorHeight(curFloor);
                    var targetNum = this._mapView.getFloorHeight(features[i].properties.floor);
                    var start = features[i - 1].geometry.coordinates[1];
                    var end = features[i].geometry.coordinates[0];
                    var floorStop = this._getFloorStop(curFloor, features[i].properties.floor, targetNum - curNum);
                    var allHeight = 0;
                    for (var j = 0; j < floorStop.length; j += 1) {
                        var itemStart = this._mapView.getFloorHeight(floorStop[j]);
                        var itemTarget = this._mapView.getFloorHeight(floorStop[j + 1] || features[i].properties.floor);
                        var diff = itemTarget - itemStart;
                        var feature = {
                            type: 'Feature',
                            geometry: {
                                type: 'LineString',
                                coordinates: [
                                    [start[0], start[1], 0],
                                    [end[0], end[1], diff]
                                ],
                            },
                            properties: {},
                        };
                        var layer = this._createConnectionLayer(floorStop[j], [feature]);
                        this._connectionLayers.push(layer);
                        allHeight += Math.abs(diff);
                    }
                    var midHeight = allHeight * 0.5;
                    if (this._mapView && floorStop.length > 0) {
                        this._mapView.getFloorHeight(floorStop[0]);
                        var domCont = document.createElement('div');
                        domCont.classList.add('marker');
                        this._mapView.getCenter();
                        var marker = new LiftMarker(domCont, {
                            draggable: false,
                        });
                        marker.addTo(this._mapView);
                        marker.setPosition2(new Point3(start[0], start[1], midHeight));
                        marker.setIconUrl('./assets/icon/lift_1.png');
                    }
                    curFloor = features[i].properties.floor;
                }
            }
            this._mapView.addLayers(this._connectionLayers);
        };
        NaviManager.prototype._createConnectionLayer = function (floorId, features) {
            var layer = new ConnectionLayer({
                width: this._options.lineWidth,
                icon: this._options.lineImage,
                base: this._options.lineHeight,
            });
            layer.setFloorId(floorId);
            layer.setFeatures(features);
            layer.setIgnoreMultiFade(true);
            return layer;
        };
        NaviManager.prototype._createLineLayer = function (floorId, features, opacity) {
            var lineLayer = new LineLayer({
                lineWidth: this._options.lineWidth,
                lineImage: this._options.lineImage,
                opacity: opacity,
                base: this._options.lineHeight,
            });
            lineLayer.setSync(false);
            lineLayer.setFloorId(floorId);
            lineLayer.setFeatures(features);
            lineLayer.setIgnoreMultiFade(true);
            return lineLayer;
        };
        NaviManager.prototype._addLineLayers = function (floorId) {
            if (!this._activeRoute)
                return;
            var features = this._activeRoute;
            if (!this._lineLayers) {
                this._lineLayers = [];
            }
            if (this._mapView.getViewType() === 'multiple') {
                for (var i = 0; i < this._floorOrder.length; i += 1) {
                    var filterFeatures = NaviManager.processFeatures(features, this._floorOrder[i]);
                    var start = filterFeatures[0].geometry.coordinates[0];
                    this.renderShortest({ x: start[0], y: start[1] }, filterFeatures, floorId);
                    if (filterFeatures.length !== 0) {
                        var lineLayer = this._createLineLayer(this._floorOrder[i], filterFeatures, 1);
                        this._lineLayers.push(lineLayer);
                    }
                }
            }
            else {
                var filterFeatures = NaviManager.processFeatures(features, floorId);
                if (filterFeatures.length === 0)
                    return;
                var start = filterFeatures[0].geometry.coordinates[0];
                this.renderShortest({ x: start[0], y: start[1] }, filterFeatures, floorId);
                var lineLayer = this._createLineLayer(floorId, filterFeatures, 1);
                this._lineLayers.push(lineLayer);
                if (this._grayLayer) {
                    this._grayLayer.setFeatures(filterFeatures);
                    this._grayLayer.setFloorId(floorId);
                    this._mapView.updateLayer(this._grayLayer);
                }
            }
            this._mapView.addLayers(this._lineLayers);
        };
        NaviManager.prototype._removeShortestLayers = function () {
            if (this._shortestLine) {
                this._mapView.removeLayer(this._shortestLine);
                delete this._shortestLine;
            }
        };
        NaviManager.prototype._addMultiLineLayers = function (floorId) {
            if (this._routesArray.length < 2)
                return;
            if (!this._multilineLayers) {
                this._multilineLayers = [];
            }
            if (this._mapView.getViewType() === 'multiple') {
                for (var i = 0; i < this._floorOrder.length; i += 1) {
                    var features = this._getOtherFeatures(this._floorOrder[i]);
                    if (features.length !== 0) {
                        var lineLayer = this._createLineLayer(this._floorOrder[i], features, this._options.multilineOpacity);
                        this._multilineLayers.push(lineLayer);
                    }
                }
            }
            else {
                var features = this._getOtherFeatures(floorId);
                if (features.length === 0)
                    return;
                var lineLayer = this._createLineLayer(floorId, features, this._options.multilineOpacity);
                this._multilineLayers.push(lineLayer);
            }
            this._mapView.addLayers(this._multilineLayers);
        };
        NaviManager.prototype._getOtherFeatures = function (floorId) {
            var resultFeatures = [];
            for (var i = 0; i < this._routesArray.length; i += 1) {
                if (this._routesArray[i].strategy !== this._activeRouteType) {
                    var features = this._routesArray[i].route.features;
                    resultFeatures = resultFeatures.concat(NaviManager.processFeatures(features, floorId));
                }
            }
            return resultFeatures;
        };
        NaviManager.prototype.getRestLines = function (floorId) {
            if (!this._lineLayers || this._lineLayers.length === 0
                || this._lineLayers[0].getFloorId() !== floorId)
                return [];
            var features = this._lineLayers[0].getFeatures();
            if (features.length === 0)
                return [];
            var geometry = features[0].geometry;
            if (geometry.type === 'LineString') {
                return geometry.coordinates;
            }
            else if (geometry.type === 'MultiLineString') {
                return geometry.coordinates[0];
            }
            return [];
        };
        NaviManager.prototype.getActiveRouteType = function () {
            return this._activeRouteType;
        };
        NaviManager.prototype.getRecommendRouteType = function () {
            return this._recommendRouteType;
        };
        NaviManager.prototype.getAllRouteType = function () {
            var result = [];
            for (var i = 0; i < this._routesArray.length; i += 1) {
                result.push(this._routesArray[i].strategy);
            }
            return result;
        };
        NaviManager.prototype.setIsShowMultiline = function (isShow) {
            this._isShowMultiline = isShow;
            if (this._mapView.currentFloor) {
                this._removeLineLayers();
                this._removeGrayLayer();
                this._addLineLayers(this._mapView.currentFloor);
                this._removeMultiLineLayers();
                if (this._isShowMultiline) {
                    this._addMultiLineLayers(this._mapView.currentFloor);
                }
            }
        };
        NaviManager.prototype.hasNavi = function () {
            return Boolean(this._lineLayers);
        };
        NaviManager.prototype._removeLineLayers = function () {
            if (this._lineLayers) {
                this._mapView.removeLayers(this._lineLayers);
                delete this._lineLayers;
            }
        };
        NaviManager.prototype.removeLineLayers = function () {
            if (this._lineLayers) {
                this._mapView.removeLayers(this._lineLayers);
                delete this._lineLayers;
            }
        };
        NaviManager.prototype.removeOutDoorLineLayers = function () {
            if (this._outLineLayers) {
                this._mapView.removeLayers(this._outLineLayers);
                delete this._outLineLayers;
            }
        };
        NaviManager.prototype._removeGrayLayer = function () {
            this._grayLayer && this._mapView.removeLayer(this._grayLayer);
        };
        NaviManager.prototype._removeMultiLineLayers = function () {
            if (this._multilineLayers) {
                this._mapView.removeLayers(this._multilineLayers);
                delete this._multilineLayers;
            }
        };
        NaviManager.prototype._removeConnectionLayers = function () {
            if (this._connectionLayers) {
                this._mapView.removeLayers(this._connectionLayers);
                delete this._connectionLayers;
            }
        };
        NaviManager.prototype.removeLayer = function () {
            this._removeGrayLayer();
            this._removeLineLayers();
            this.removeOutDoorLineLayers();
            this._removeMultiLineLayers();
            this._removeConnectionLayers();
            this._removeShortestLayers();
            this._routesArray.length = 0;
            this._routesCache.clear();
            this._floorOrder.length = 0;
            delete this._activeRouteType;
            delete this._activeRoute;
            delete this._startPosition;
            delete this._endPosition;
        };
        NaviManager.prototype.resetActiveRouteType = function () {
            delete this._activeRouteType;
        };
        NaviManager.prototype.destroy = function () {
            this._mapView.off('changeFloor', this._onChangeFloor);
            this._mapView.off('changeViewType', this._onChangeViewType);
        };
        NaviManager.processFeatures = function (features, floorId) {
            var result = [];
            var isNeedPushNew = true;
            for (var i = 0; i < features.length; i += 1) {
                var properties = features[i].properties;
                if (properties.floor === floorId) {
                    var _a = features[i].geometry.coordinates, start = _a[0], end = _a[1];
                    if (isNeedPushNew) {
                        isNeedPushNew = false;
                        result.push({
                            type: 'Feature',
                            properties: features[i].properties,
                            geometry: {
                                type: 'LineString',
                                coordinates: [],
                            }
                        });
                    }
                    var lastCoordinates = result[result.length - 1].geometry.coordinates;
                    lastCoordinates.push(start);
                    if (features[i + 1]) {
                        var nextFloor = features[i + 1].properties.floor;
                        var nextStart = features[i + 1].geometry.coordinates[0];
                        var isEqual = NaviManager.isCoordinateEqual(end, nextStart);
                        if (!isEqual || nextFloor !== floorId) {
                            lastCoordinates.push(end);
                        }
                    }
                    else {
                        lastCoordinates.push(end);
                    }
                }
                else {
                    isNeedPushNew = true;
                }
            }
            return result;
        };
        NaviManager.prototype.renderShortest = function (startPoint, features, floorId) {
            if (!this._options.showShortest)
                return;
            var coordinateLength = features[0].geometry.coordinates.length;
            var shortestLineEnd = features[0].geometry.coordinates[coordinateLength - 1];
            var curdCoordinates = [[startPoint.x, startPoint.y], [shortestLineEnd[0], shortestLineEnd[1]]];
            var shortestFeature = [{
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'LineString',
                        coordinates: curdCoordinates
                    }
                }];
            if (!this._shortestLine) {
                this._shortestLine = new LineLayer(this._options.shortestLineConfig || {});
                this._shortestLine.setFloorId(floorId);
                this._shortestLine.setFeatures(shortestFeature);
                this._mapView.addLayer(this._shortestLine);
            }
            else {
                this._shortestLine.setFloorId(floorId);
                this._shortestLine.setFeatures(shortestFeature);
            }
        };
        NaviManager.isCoordinateEqual = function (arr1, arr2) {
            return arr1[0] === arr2[0] && arr1[1] === arr2[1];
        };
        return NaviManager;
    }());

    var cn = {
        elevatorTip: '鐢垫',
        escalatorTip: '鎵舵',
        stairsTip: '妤兼',
        rampTip: '鍧￠亾',
        straightTip: '鐩磋',
        leftRearTip: '宸﹀悗鏂瑰墠琛�',
        leftTip: '宸﹁浆',
        leftFrontTip: '宸﹀墠鏂瑰墠琛�',
        rightFrontTip: '鍙冲墠鏂瑰墠琛�',
        rightTip: '鍙宠浆',
        rightRearTip: '鍙冲悗鏂瑰墠琛�',
        endTip: '鍒拌揪缁堢偣',
        beforeArriveTip: '鎮ㄥ凡鎺ヨ繎鐩殑鍦�,璇风暀鎰�',
        simStart: '妯℃嫙瀵艰埅寮€濮�',
        deviateTip: '鎮ㄥ凡鍋忕璺嚎,璇风暀鎰�',
        reInitTip: '姝ｅ湪涓烘偍閲嶆柊瑙勫垝璺嚎',
        startNaviTip: '瀵艰埅寮€濮�',
        initNaviError: '娓叉煋瀵艰埅绾垮け璐�',
        arriveTip: '鎮ㄥ凡鍒拌揪鐩殑鍦帮紝瀵艰埅缁撴潫',
        originalTip: '璇疯皟鏁存偍鐨勬墜鏈鸿嚦璺嚎鏂瑰悜',
    };

    var en = {
        elevatorTip: 'elevator',
        escalatorTip: 'escalator',
        stairsTip: 'stairs',
        rampTip: 'ramp',
        straightTip: 'straight',
        leftRearTip: 'Left rear',
        leftTip: 'Turn left',
        leftFrontTip: 'Ahead left',
        rightFrontTip: 'Right forward',
        rightTip: 'Turn right',
        rightRearTip: 'Right back',
        endTip: 'Reach the finish line',
        beforeArriveTip: 'You are near your destination',
        simStart: 'Simulate navigate start',
        deviateTip: 'You have deviated from the route',
        reInitTip: 'You are off course and are replanning your route',
        startNaviTip: 'Navigate start',
        initNaviError: 'Init navigate route failed',
        arriveTip: 'You have reached your destination and the navigation is over',
        originalTip: 'Please adjust your mobile phone to the direction of the route',
    };

    var Language = (function () {
        function Language(data) {
            this._languageType = 'cn';
            this._sourceData = data;
        }
        Language.prototype.getType = function () {
            return this._languageType;
        };
        Language.prototype.changeLanguage = function (type) {
            this._languageType = type;
        };
        Language.prototype.get = function (key) {
            var obj = this._sourceData[this._languageType];
            if (obj) {
                return obj[key];
            }
            return key;
        };
        return Language;
    }());
    var language = new Language({ en: en, cn: cn });

    var elevator$1 = new Set([25136, 25011]);
    var escalator$1 = new Set([25135, 25012]);
    var stairs$1 = new Set([21004, 25134, 25014]);
    var ramp$1 = new Set([25137, 25138, 25147]);
    function getFacility$1(category) {
        var text = '';
        var facility = '';
        if (elevator$1.has(category)) {
            text = language.get('elevatorTip');
            facility = 'elevator';
        }
        else if (escalator$1.has(category)) {
            text = language.get('escalatorTip');
            facility = 'escalator';
        }
        else if (stairs$1.has(category)) {
            text = language.get('stairsTip');
            facility = 'stairs';
        }
        else if (ramp$1.has(category)) {
            text = language.get('rampTip');
            facility = 'ramp';
        }
        return { text: text, facility: facility };
    }
    function getDirection$1(baseAngle) {
        var direction = 'straight';
        var angle = baseAngle;
        if (baseAngle >= 180) {
            angle -= 360;
        }
        else if (angle <= -180) {
            angle += 360;
        }
        if (-180 <= angle && angle <= -120) {
            direction = 'leftRear';
        }
        else if (-120 < angle && angle <= -60) {
            direction = 'left';
        }
        else if (-60 < angle && angle <= -20) {
            direction = 'leftFront';
        }
        else if (-5 < angle && angle <= 5) {
            direction = 'straight';
        }
        else if (20 < angle && angle <= 60) {
            direction = 'rightFront';
        }
        else if (60 < angle && angle <= 120) {
            direction = 'right';
        }
        else if (120 < angle && angle <= 180) {
            direction = 'rightRear';
        }
        return direction;
    }

    var Segment$1 = (function () {
        function Segment(line, properties) {
            this._isTipMovePhone = false;
            this.m_bias = 0;
            this.m_routeTrustness = 0;
            this.m_index = 0;
            this._line = new Line(line[0], line[1]);
            this._properties = properties;
            this._distance = this._line.getLength();
            var vector0 = new Vector2([0, 1]);
            var vector1 = new Vector2(line[0], line[1]);
            this._rotate = vector0.angleTo(vector1);
        }
        Segment.prototype.isFacility = function () {
            return Boolean(this._facility);
        };
        Segment.prototype.getNextSegment = function () {
            return this._nextSegment;
        };
        Segment.prototype.getStart = function () {
            return this._line.getStart();
        };
        Segment.prototype.getEnd = function () {
            return this._line.getEnd();
        };
        Segment.prototype.getClosest = function (coordinate) {
            return this._line.getClosest(coordinate);
        };
        Segment.prototype.setNextSegment = function (nextSegment) {
            this._nextSegment = nextSegment;
            if (this.floor === this._nextSegment.floor) {
                this._direction = getDirection$1(nextSegment._rotate - this._rotate);
            }
            else {
                var nextAltitude = nextSegment._properties.altitude;
                var altitude = this._properties.altitude;
                this._direction = nextAltitude > altitude ? 'top' : 'bottom';
                var _a = this._properties, category = _a.category, escalator = _a.escalator;
                var _b = getFacility$1(Number(category)), text = _b.text, facility = _b.facility;
                this._facility = facility;
                this._facilityTipText = text;
                this._facilityId = escalator;
            }
        };
        Segment.prototype.setLastSegment = function (lastSegment) {
            this._lastSegment = lastSegment;
        };
        Segment.prototype.getRestDistance = function (coordinate) {
            if (!coordinate)
                return this._distance;
            return coordinate.distanceTo(this._line.getEnd());
        };
        Segment.prototype._getOutBuildingText = function () {
            if (!this._lastSegment)
                return '';
            var lastBelong = this._lastSegment._properties.belong;
            var nowBelong = this._properties.belong;
            if (nowBelong === 'outdoor' && lastBelong && lastBelong !== 'outdoor') {
                var message = language.getType() === 'cn' ? "\u60A8\u5DF2\u79BB\u5F00" + lastBelong + "\uFF0C" : "You have to leave " + lastBelong;
                return message;
            }
        };
        Segment.prototype._getInBuildingText = function () {
            if (!this._nextSegment)
                return '';
            var nextBelong = this._nextSegment._properties.belong;
            var nowBelong = this._properties.belong;
            if (nowBelong === 'outdoor' && nextBelong && nextBelong !== 'outdoor') {
                var message = language.getType() === 'cn' ? "\u60A8\u5373\u5C06\u8FDB\u5165" + nextBelong + "\uFF0C" : "You are about to enter " + nextBelong;
                return message;
            }
            if (nowBelong && nowBelong !== 'outdoor'
                && nextBelong && nextBelong !== 'outdoor'
                && nextBelong !== nowBelong) {
                var message = language.getType() === 'cn' ? "\u60A8\u5373\u5C06\u8FDB\u5165" + nextBelong + "\uFF0C" : "You are about to enter " + nextBelong;
                return message;
            }
        };
        Segment.prototype._getRampBuilding = function () {
            if (this._facility !== 'ramp')
                return '';
            if (!this._nextSegment)
                return '';
            var nextBelong = this._nextSegment._properties.belong;
            var nowBelong = this._properties.belong;
            if (nextBelong && nextBelong !== 'outdoor' && nowBelong && nowBelong !== nextBelong) {
                return nextBelong;
            }
            return '';
        };
        Segment.prototype._getArrivedFloorText = function () {
            var message = '';
            var _a = this._properties, pathType = _a.pathType, floorAddress = _a.floorAddress;
            if (pathType === 'outEscalator') {
                message = language.getType() === 'cn'
                    ? "\u60A8\u5DF2\u5230\u8FBE" + floorAddress + "\u5C42\uFF0C" : "You are arriving at " + floorAddress + "\uFF0C";
                LogMgr$1.log('zhhengli _getArrivedFloorText '
                    + ' Floor:' + this._direction
                    + ' ');
            }
            return message;
        };
        Segment.prototype._getNaviDirectionTextReverse = function () {
            if (!this._nextSegment)
                return language.get('endTip');
            var throughText = (this._facility === 'elevator' || this._facility === 'escalator') ? '涔�' : '閫氳繃';
            switch (this._direction) {
                case 'leftRear': {
                    return '鍚戝彸鍓�';
                }
                case 'left': {
                    return '鍚戝彸';
                }
                case 'leftFront': {
                    return '鍚戝彸鍚�';
                }
                case 'rightFront': {
                    return '鍚戝乏鍚�';
                }
                case 'right': {
                    return '鍚戝乏';
                }
                case 'rightRear': {
                    return '鍚戝乏鍓�';
                }
                case 'straight': {
                    return '璋冨ご';
                }
                case 'top': {
                    var floorAddress = this._nextSegment._properties.floorAddress;
                    if (language.getType() === 'cn') {
                        return "" + throughText + this._facilityTipText + "\u4E0A\u884C\u81F3" + this._getRampBuilding() + floorAddress + "\u5C42";
                    }
                    else {
                        return "Use " + this._facilityTipText + " to " + floorAddress;
                    }
                }
                case 'bottom': {
                    var floorAddress = this._nextSegment._properties.floorAddress;
                    if (language.getType() === 'cn') {
                        return "" + throughText + this._facilityTipText + "\u4E0B\u884C\u81F3" + this._getRampBuilding() + floorAddress + "\u5C42";
                    }
                    else {
                        return "Use " + this._facilityTipText + " to " + floorAddress;
                    }
                }
                default: {
                    return '';
                }
            }
        };
        Segment.prototype.getEasyTextCrossFloor = function () {
            if (!this._nextSegment)
                return language.get('endTip');
            var throughText = (this._facility === 'elevator' || this._facility === 'escalator') ? '鍓嶅線' : '鍓嶅線';
            switch (this._direction) {
                case 'leftRear': {
                    return language.get('leftRearTip');
                }
                case 'left': {
                    return language.get('leftTip');
                }
                case 'leftFront': {
                    return language.get('leftFrontTip');
                }
                case 'rightFront': {
                    return language.get('rightFrontTip');
                }
                case 'right': {
                    return language.get('rightTip');
                }
                case 'rightRear': {
                    return language.get('rightRearTip');
                }
                case 'straight': {
                    return language.get('straightTip');
                }
                case 'top': {
                    var floorAddress = this._nextSegment._properties.floorAddress;
                    if (language.getType() === 'cn') {
                        return "" + throughText + this._facilityTipText + "\u4E0A\u81F3" + this._getRampBuilding() + floorAddress + "\u5C42";
                    }
                    else {
                        return "Use " + this._facilityTipText + " to " + floorAddress;
                    }
                }
                case 'bottom': {
                    var floorAddress = this._nextSegment._properties.floorAddress;
                    if (language.getType() === 'cn') {
                        return "" + throughText + this._facilityTipText + "\u4E0B\u81F3" + this._getRampBuilding() + floorAddress + "\u5C42";
                    }
                    else {
                        return "Use " + this._facilityTipText + " to " + floorAddress;
                    }
                }
                default: {
                    return '';
                }
            }
        };
        Segment.prototype._getNaviDirectionWithOutUpDown = function () {
            if (!this._nextSegment)
                return language.get('endTip');
            (this._facility === 'elevator' || this._facility === 'escalator') ? '涔�' : '閫氳繃';
            switch (this._direction) {
                case 'leftRear': {
                    return language.get('leftRearTip');
                }
                case 'left': {
                    return language.get('leftTip');
                }
                case 'leftFront': {
                    return language.get('leftFrontTip');
                }
                case 'rightFront': {
                    return language.get('rightFrontTip');
                }
                case 'right': {
                    return language.get('rightTip');
                }
                case 'rightRear': {
                    return language.get('rightRearTip');
                }
                case 'straight': {
                    return language.get('straightTip');
                }
                default: {
                    return '';
                }
            }
        };
        Segment.prototype._getNaviDirectionText = function (bNoEndTip) {
            if (bNoEndTip === void 0) { bNoEndTip = false; }
            if (!this._nextSegment) {
                if (bNoEndTip) {
                    return '';
                }
                else {
                    return language.get('endTip');
                }
            }
            var throughText = (this._facility === 'elevator' || this._facility === 'escalator') ? '涔�' : '閫氳繃';
            switch (this._direction) {
                case 'leftRear': {
                    return language.get('leftRearTip');
                }
                case 'left': {
                    return language.get('leftTip');
                }
                case 'leftFront': {
                    return language.get('leftFrontTip');
                }
                case 'rightFront': {
                    return language.get('rightFrontTip');
                }
                case 'right': {
                    return language.get('rightTip');
                }
                case 'rightRear': {
                    return language.get('rightRearTip');
                }
                case 'straight': {
                    return language.get('straightTip');
                }
                case 'top': {
                    var floorAddress = this._nextSegment._properties.floorAddress;
                    if (language.getType() === 'cn') {
                        return "" + throughText + this._facilityTipText + "\u4E0A\u884C\u81F3" + this._getRampBuilding() + floorAddress + "\u5C42";
                    }
                    else {
                        return "Use " + this._facilityTipText + " to " + floorAddress;
                    }
                }
                case 'bottom': {
                    var floorAddress = this._nextSegment._properties.floorAddress;
                    if (language.getType() === 'cn') {
                        return "" + throughText + this._facilityTipText + "\u4E0B\u884C\u81F3" + this._getRampBuilding() + floorAddress + "\u5C42";
                    }
                    else {
                        return "Use " + this._facilityTipText + " to " + floorAddress;
                    }
                }
                default: {
                    return '';
                }
            }
        };
        Segment.prototype.getFirstEasyMessageInNavi = function (maxFacilityDis, coordinate, isTipMovePhone, bForceMeter) {
            var distance;
            if (coordinate) {
                var startPoint = new Point(coordinate.x, coordinate.y);
                distance = startPoint.distanceTo(this._line.getEnd());
            }
            else {
                distance = this._distance;
            }
            distance = Math.round(distance);
            var resultMessage;
            resultMessage = this._getNaviDirectionTextReverse();
            return {
                isWillChange: distance < 5,
                message: resultMessage,
                direction: this._direction,
                facilityTipText: this._facilityTipText,
                facility: this._facility,
                facilityId: this._facilityId,
            };
        };
        Segment.prototype.getMessageInNextFloorFirstText = function (maxFacilityDis, coordinate, isTipMovePhone, bForceMeter) {
            if (isTipMovePhone === void 0) { isTipMovePhone = true; }
            var text = this.getMessageInNavi(maxFacilityDis, coordinate, isTipMovePhone, false, true);
            text.message = this._getNaviDirectionText(true);
            var _a = this._properties; _a.pathType; var floorAddress = _a.floorAddress;
            text.message = (language.getType() === 'cn'
                ? "\u62B5\u8FBE" + floorAddress + "\u5C42\u540E, " : "You are arriving at " + floorAddress + "\uFF0C") + text.message;
            return text;
        };
        Segment.prototype.getEasyMessageInCrossFloor = function (maxFacilityDis, coordinate, isTipMovePhone, bForceMeter) {
            var distance;
            if (coordinate) {
                var startPoint = new Point(coordinate.x, coordinate.y);
                distance = startPoint.distanceTo(this._line.getEnd());
            }
            else {
                distance = this._distance;
            }
            distance = Math.round(distance);
            var resultMessage;
            resultMessage = this.getEasyTextCrossFloor();
            return {
                isWillChange: distance < 5,
                message: resultMessage,
                direction: this._direction,
                facilityTipText: this._facilityTipText,
                facility: this._facility,
                facilityId: this._facilityId,
            };
        };
        Segment.prototype.getMessageInNaviWithOutUpDownInfo = function (maxFacilityDis, coordinate, isTipMovePhone, bForceMeter) {
            if (isTipMovePhone === void 0) { isTipMovePhone = true; }
            if (bForceMeter === void 0) { bForceMeter = false; }
            var distance;
            if (coordinate) {
                var startPoint = new Point(coordinate.x, coordinate.y);
                distance = startPoint.distanceTo(this._line.getEnd());
            }
            else {
                distance = this._distance;
            }
            distance = Math.round(distance);
            var message;
            var resultMessage;
            if (bForceMeter) {
                var dirText = this._getNaviDirectionWithOutUpDown();
                if (dirText == null || dirText == undefined || dirText == '') {
                    if (language.getType() === 'cn') {
                        message = "\u76F4\u884C" + distance + "\u7C73\u540E" + this._getNaviDirectionWithOutUpDown();
                    }
                    else {
                        message = "After " + distance + " meters" + this._getNaviDirectionWithOutUpDown();
                    }
                }
                else {
                    if (language.getType() === 'cn') {
                        message = "\u76F4\u884C" + distance + "\u7C73\u540E, " + this._getNaviDirectionWithOutUpDown();
                    }
                    else {
                        message = "After " + distance + " meters, " + this._getNaviDirectionWithOutUpDown();
                    }
                }
            }
            else {
                if (this._direction === 'straight') {
                    if (language.getType() === 'cn') {
                        message = "\u524D\u65B9, " + this._getNaviDirectionWithOutUpDown();
                    }
                    else {
                        message = "In front, " + this._getNaviDirectionWithOutUpDown();
                    }
                }
                else if (distance < 2) {
                    message = this._getNaviDirectionText();
                }
                else if (distance < 5) {
                    if (language.getType() === 'cn') {
                        message = "\u524D\u65B9, " + this._getNaviDirectionWithOutUpDown();
                    }
                    else {
                        message = "In front, " + this._getNaviDirectionWithOutUpDown();
                    }
                }
                else {
                    if (language.getType() === 'cn') {
                        message = "\u76F4\u884C" + distance + "\u7C73\u540E, " + this._getNaviDirectionWithOutUpDown();
                    }
                    else {
                        message = "After " + distance + " meters, " + this._getNaviDirectionWithOutUpDown();
                    }
                }
            }
            if (this._nextSegment && this._nextSegment._facility &&
                this._nextSegment._distance + distance < maxFacilityDis) {
                if (language.getType() === 'cn') {
                    message = "\u524D\u65B9" + this._getNaviDirectionWithOutUpDown() + ", \u7136\u540E" + this._nextSegment._getNaviDirectionWithOutUpDown();
                }
                else {
                    message = "In front " + this._getNaviDirectionWithOutUpDown() + ", then " + this._nextSegment._getNaviDirectionWithOutUpDown();
                }
                return {
                    isWillChange: distance < 5,
                    message: "" + message,
                    direction: this._nextSegment._direction,
                    facilityTipText: this._nextSegment._facilityTipText,
                    facility: this._nextSegment._facility,
                    facilityId: this._nextSegment._facilityId,
                };
            }
            if (isTipMovePhone && !this._isTipMovePhone && this._properties.pathType === 'outEscalator') {
                this._isTipMovePhone = true;
                message = language.get('originalTip');
            }
            var _outBuildingText = (this._getOutBuildingText() || '').replace(/\|/g, '');
            var _inBuildingText = (this._getInBuildingText() || '').replace(/\|/g, '');
            if (isTipMovePhone) {
                if (_outBuildingText) {
                    if (this._distance >= 5 && distance < 5) {
                        resultMessage = message;
                    }
                    else {
                        resultMessage = "" + _outBuildingText + message;
                    }
                }
                else if (_inBuildingText) {
                    if (distance < 5) {
                        resultMessage = "" + _inBuildingText + message;
                    }
                    else {
                        resultMessage = message;
                    }
                }
                else {
                    resultMessage = message;
                }
            }
            else {
                resultMessage = message;
            }
            if (this._distance >= 5 && distance < 5) ;
            else {
                resultMessage = "" + this._getArrivedFloorText() + resultMessage;
            }
            return {
                isWillChange: distance < 5,
                message: resultMessage,
                direction: this._direction,
                facilityTipText: this._facilityTipText,
                facility: this._facility,
                facilityId: this._facilityId,
            };
        };
        Segment.prototype.getMessageInNavi = function (maxFacilityDis, coordinate, isTipMovePhone, bForceMeter, bNoEndTip) {
            if (isTipMovePhone === void 0) { isTipMovePhone = true; }
            if (bForceMeter === void 0) { bForceMeter = false; }
            if (bNoEndTip === void 0) { bNoEndTip = false; }
            var distance;
            if (coordinate) {
                var startPoint = new Point(coordinate.x, coordinate.y);
                distance = startPoint.distanceTo(this._line.getEnd());
            }
            else {
                distance = this._distance;
            }
            distance = Math.round(distance);
            var message;
            var resultMessage;
            if (bForceMeter) {
                var naviText = this._getNaviDirectionText(bNoEndTip);
                if (naviText == null || naviText == undefined || naviText == '') {
                    if (language.getType() === 'cn') {
                        message = "\u76F4\u884C" + distance + "\u7C73\u540E" + this._getNaviDirectionText(bNoEndTip);
                    }
                    else {
                        message = "After " + distance + " meters" + this._getNaviDirectionText(bNoEndTip);
                    }
                }
                else {
                    if (language.getType() === 'cn') {
                        message = "\u76F4\u884C" + distance + "\u7C73\u540E, " + this._getNaviDirectionText(bNoEndTip);
                    }
                    else {
                        message = "After " + distance + " meters, " + this._getNaviDirectionText(bNoEndTip);
                    }
                }
            }
            else {
                if (this._direction === 'straight') {
                    if (language.getType() === 'cn') {
                        message = "\u524D\u65B9, " + this._getNaviDirectionText(bNoEndTip);
                    }
                    else {
                        message = "In front, " + this._getNaviDirectionText(bNoEndTip);
                    }
                }
                else if (distance < 2) {
                    message = this._getNaviDirectionText(bNoEndTip);
                }
                else if (distance < 5) {
                    if (language.getType() === 'cn') {
                        message = "\u524D\u65B9, " + this._getNaviDirectionText(bNoEndTip);
                    }
                    else {
                        message = "In front, " + this._getNaviDirectionText(bNoEndTip);
                    }
                }
                else {
                    if (language.getType() === 'cn') {
                        message = "\u76F4\u884C" + distance + "\u7C73\u540E, " + this._getNaviDirectionText(bNoEndTip);
                    }
                    else {
                        message = "After " + distance + " meters, " + this._getNaviDirectionText(bNoEndTip);
                    }
                }
            }
            if (this._nextSegment && this._nextSegment._facility &&
                this._nextSegment._distance + distance < maxFacilityDis) {
                if (language.getType() === 'cn') {
                    message = "\u524D\u65B9" + this._getNaviDirectionText(bNoEndTip) + ", \u7136\u540E" + this._nextSegment._getNaviDirectionText(bNoEndTip);
                }
                else {
                    message = "In front " + this._getNaviDirectionText(bNoEndTip) + ", then " + this._nextSegment._getNaviDirectionText(bNoEndTip);
                }
                return {
                    isWillChange: distance < 5,
                    message: "" + message,
                    direction: this._nextSegment._direction,
                    facilityTipText: this._nextSegment._facilityTipText,
                    facility: this._nextSegment._facility,
                    facilityId: this._nextSegment._facilityId,
                };
            }
            if (isTipMovePhone && !this._isTipMovePhone && this._properties.pathType === 'outEscalator') {
                this._isTipMovePhone = true;
                message = language.get('originalTip');
            }
            var _outBuildingText = (this._getOutBuildingText() || '').replace(/\|/g, '');
            var _inBuildingText = (this._getInBuildingText() || '').replace(/\|/g, '');
            if (isTipMovePhone) {
                if (_outBuildingText) {
                    if (this._distance >= 5 && distance < 5) {
                        resultMessage = message;
                    }
                    else {
                        resultMessage = "" + _outBuildingText + message;
                    }
                }
                else if (_inBuildingText) {
                    if (distance < 5) {
                        resultMessage = "" + _inBuildingText + message;
                    }
                    else {
                        resultMessage = message;
                    }
                }
                else {
                    resultMessage = message;
                }
            }
            else {
                resultMessage = message;
            }
            if (this._distance >= 5 && distance < 5) ;
            else {
                resultMessage = "" + this._getArrivedFloorText() + resultMessage;
            }
            return {
                isWillChange: distance < 5,
                message: resultMessage,
                direction: this._direction,
                facilityTipText: this._facilityTipText,
                facility: this._facility,
                facilityId: this._facilityId,
            };
        };
        Segment.prototype.getLine = function () {
            return this._line;
        };
        Segment.prototype.getDistance = function () {
            return this._distance;
        };
        Segment.prototype.getRotate = function () {
            return this._rotate;
        };
        Segment.prototype.getFacilityId = function () {
            return this._facilityId;
        };
        Object.defineProperty(Segment.prototype, "floor", {
            get: function () {
                return this._properties.floor;
            },
            enumerable: false,
            configurable: true
        });
        Segment.prototype.getProperties = function () {
            return this._properties;
        };
        Segment.prototype.getDirection = function () {
            return this._direction;
        };
        Segment.prototype.getFacilityTipText = function () {
            return this._facilityTipText;
        };
        Segment.prototype.getNextFloorAddress = function () {
            return this._nextSegment && this._nextSegment._properties.floorAddress;
        };
        return Segment;
    }());

    var DynamicNaviManager = (function () {
        function DynamicNaviManager(mapView, options) {
            this._segments = [];
            this._crtIndex = -1;
            this._hasTipMovePhone = false;
            this._mapView = mapView;
            this._options = options;
        }
        DynamicNaviManager.prototype.GetCurCoord = function () {
            return this._crtCoordinate;
        };
        DynamicNaviManager.prototype.init = function (features) {
            this.reset();
            for (var i = 0; i < features.length; i += 1) {
                var _a = features[i], coordinates = _a.geometry.coordinates, properties = _a.properties;
                var segment = new Segment$1(coordinates, properties);
                this._segments.push(segment);
            }
            for (var i = 0; i < this._segments.length; i += 1) {
                if (i + 1 < this._segments.length) {
                    this._segments[i].setNextSegment(this._segments[i + 1]);
                }
                if (i > 0 && i < this._segments.length) {
                    this._segments[i].setLastSegment(this._segments[i - 1]);
                }
            }
        };
        DynamicNaviManager.prototype.getClosestCoord = function (floorId, coordinate) {
            var index = -1;
            var closestResult;
            for (var i = 0; i < this._segments.length; i += 1) {
                if (this._segments[i].floor === floorId) {
                    var item = this._segments[i].getClosest(coordinate);
                    if (!closestResult || item.distance < closestResult.distance) {
                        closestResult = item;
                        index = i;
                    }
                }
            }
            var resultCoord = closestResult.coordinate;
            var startPoint = new Point(coordinate.x, coordinate.y);
            var point = new Point(resultCoord.x, resultCoord.y);
            var segment = this._segments[index];
            var nextSegment = segment.getNextSegment();
            var restDis = segment.getRestDistance(point);
            var result = {
                index: index,
                coordinate: point,
                isClosestFacility: false,
                distance: startPoint.distanceTo(point),
            };
            if (segment.isFacility() && restDis < this._options.adsorbFacilityDis) {
                result.coordinate = segment.getEnd();
                result.isClosestFacility = true;
            }
            else if (nextSegment && nextSegment.isFacility()) {
                restDis += nextSegment.getDistance();
                if (restDis < this._options.adsorbFacilityDis) {
                    result.index = index + 1;
                    result.coordinate = nextSegment.getEnd();
                    result.isClosestFacility = true;
                }
            }
            return result;
        };
        DynamicNaviManager.prototype.distanceToEnd = function (index, coordinate) {
            var result = 0;
            for (var i = index + 1; i < this._segments.length; i += 1) {
                result += this._segments[i].getDistance();
            }
            var end = this._segments[index].getEnd();
            result += new Point(coordinate.x, coordinate.y).distanceTo(end);
            return result;
        };
        DynamicNaviManager.prototype.findNearSegment = function (index, coordinate, isMove) {
            if (isMove === void 0) { isMove = true; }
            this._crtIndex = index;
            this._crtCoordinate = coordinate;
            var num = index;
            var restDistance = this.crtSegment.getRestDistance(this._crtCoordinate);
            var restRotateDistance = this._options.restRotateDistance;
            if (restDistance < restRotateDistance &&
                index < this._segments.length - 1 &&
                this._segments[index].floor === this._segments[index + 1].floor) {
                num += 1;
            }
            this._crtRotate = this._segments[num].getRotate();
            isMove && this._moveToSegment(this._crtRotate);
        };
        DynamicNaviManager.prototype._moveToSegment = function (rotate) {
            if (rotate === this._mapView.getRotate())
                return;
            var startRotate = this._mapView.getRotate() || 0;
            var targetRotate = Camera.normalizeRotate(rotate, startRotate);
            var deltaRotate = Math.abs(targetRotate - startRotate);
            var duration = deltaRotate / this._options.rotateSpeed * 1000;
            this._mapView.easeTo({
                rotate: rotate,
                duration: duration,
                easing: 'linear',
                offset: this._options.offset,
            });
        };
        DynamicNaviManager.prototype.getMessageInNavi = function (isTipMovePhone) {
            if (isTipMovePhone === void 0) { isTipMovePhone = true; }
            var curSegment = this._segments[this._crtIndex];
            var info = curSegment.getMessageInNavi(this._options.maxFacilityDis, this._crtCoordinate, isTipMovePhone);
            if (isTipMovePhone && !this._hasTipMovePhone) {
                info.message = language.get('originalTip');
                info.direction = undefined;
                this._hasTipMovePhone = true;
            }
            return info;
        };
        DynamicNaviManager.prototype.getMessageInList = function () {
            var result = [];
            for (var i = 0; i < this._segments.length; i += 1) {
                result.push(this._segments[i].getMessageInNavi(this._options.maxFacilityDis));
            }
            return result;
        };
        Object.defineProperty(DynamicNaviManager.prototype, "crtRotate", {
            get: function () {
                return this._crtRotate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicNaviManager.prototype, "crtSegment", {
            get: function () {
                return this._segments[this._crtIndex];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicNaviManager.prototype, "crtIndex", {
            get: function () {
                return this._crtIndex;
            },
            enumerable: false,
            configurable: true
        });
        DynamicNaviManager.prototype.getStartFloor = function () {
            return this._segments[0].floor;
        };
        DynamicNaviManager.prototype.getWholeDistance = function () {
            var distance = 0;
            for (var i = 0; i < this._segments.length; i += 1) {
                distance += this._segments[i].getDistance();
            }
            return distance;
        };
        DynamicNaviManager.prototype.getEndFloor = function () {
            return this._segments[this._segments.length - 1].floor;
        };
        DynamicNaviManager.prototype.getSegments = function () {
            return this._segments;
        };
        DynamicNaviManager.prototype.getNextSegmentBySegment = function (segment) {
            if (segment == null || segment == undefined) {
                return null;
            }
            var result = null;
            for (var i = 0; i < this._segments.length; i++) {
                if (this._segments[i] == segment) {
                    result = this._segments[i + 1];
                }
            }
            return result;
        };
        DynamicNaviManager.prototype.getLastSegmentInCurFloor = function () {
            if (this._crtIndex < 0 || this._crtIndex >= this._segments.length) {
                return null;
            }
            var curSegment = this._segments[this._crtIndex];
            var curFloor = curSegment.floor;
            var lastSegment = curSegment;
            for (var i = this._crtIndex; i + 1 < this._segments.length; i++) {
                var tempSegment = this._segments[i + 1];
                if (tempSegment && tempSegment.floor != curFloor) {
                    lastSegment = this._segments[i];
                    break;
                }
            }
            return lastSegment;
        };
        DynamicNaviManager.prototype.getCurSegment = function () {
            return this._segments[this._crtIndex];
        };
        DynamicNaviManager.prototype.getNextSegment = function () {
            if (this._crtIndex + 1 < this._segments.length) {
                return this._segments[this._crtIndex + 1];
            }
            else {
                return null;
            }
        };
        DynamicNaviManager.prototype.reset = function () {
            this._segments.length = 0;
            delete this._crtCoordinate;
            this._crtIndex = -1;
            this.resetTipMovePhone();
        };
        DynamicNaviManager.prototype.resetTipMovePhone = function () {
            this._hasTipMovePhone = false;
        };
        return DynamicNaviManager;
    }());

    var MarkerManager = (function () {
        function MarkerManager(markerConfig) {
            this._markers = new Map();
            this._markerConfig = markerConfig;
        }
        MarkerManager.prototype.addTo = function (mapView) {
            this._mapView = mapView;
        };
        MarkerManager.prototype.forceUpdate = function () {
            if (this._markers == undefined || this._markers == null) {
                return;
            }
            var marker = this._markers.get('sim');
            if (marker) {
                var _a = marker.getPosition(), floorId = _a.floorId, coordinate = _a.coordinate;
                marker.setPosition(floorId, coordinate);
                return;
            }
        };
        MarkerManager.prototype.setMarker = function (name, floorId, coordinate) {
            if (!this._mapView) {
                console.error('setMarker: please use it after addTo');
                return;
            }
            var marker = this._markers.get(name);
            if (marker) {
                marker.setPosition(floorId, coordinate);
                return;
            }
            var _a = this._markerConfig[name], type = _a.type, url = _a.url, size = _a.size, anchor = _a.anchor, plane = _a.plane;
            if (type === 'layer') {
                if (typeof size !== 'number') {
                    throw new Error('MarkerConfig: type 鏄� layer 鏃�, size 搴斾负 number');
                }
                marker = new CanvasMarker({
                    iconImage: url,
                    iconAnchor: anchor,
                    iconSize: size,
                });
                marker.setIgnoreMultiFade(true);
            }
            else {
                if (!Array.isArray(size) || size.length !== 2) {
                    throw new Error('MarkerConfig: type 鏄� overlay 鏄�, size 搴斾负[width, height]');
                }
                var img = new Image();
                img.src = url;
                img.style.width = size[0] + "px";
                img.style.height = size[1] + "px";
                marker = new Marker(img, {
                    pitchWidthMap: plane,
                    anchor: anchor,
                });
            }
            marker.addTo(this._mapView);
            marker.setPosition(floorId, coordinate);
            this._markers.set(name, marker);
        };
        MarkerManager.prototype.updateMarker = function (oldName, newName) {
            var oldMarker = this.getMarker(oldName);
            if (!oldMarker) {
                console.warn('updateMarker: oldMarker is not exit');
                return;
            }
            var position = oldMarker.getPosition();
            if (!position)
                return;
            var floorId = position.floorId, coordinate = position.coordinate;
            this.setMarker(newName, floorId, coordinate);
            var newMarker = this._markers.get(newName);
            newMarker && newMarker.setAlwaysShow(oldMarker.getAlwaysShow());
            this.removeMarker(oldName);
        };
        MarkerManager.prototype.removeMarker = function (name) {
            var _a, _b;
            var marker = this.getMarker(name);
            if (!marker)
                return;
            if (name == 'pick') {
                (_b = (_a = this._mapView) === null || _a === void 0 ? void 0 : _a.getCurNavi()) === null || _b === void 0 ? void 0 : _b.OnPickMarkerRemoved();
            }
            marker.remove();
            this._markers.delete(name);
        };
        MarkerManager.prototype.getMarker = function (name) {
            return this._markers.get(name);
        };
        MarkerManager.prototype.clear = function () {
            this._markers.forEach(function (value) {
                value.remove();
            });
            this._markers.clear();
        };
        MarkerManager.prototype.destroy = function () {
            this.clear();
            delete this._mapView;
        };
        return MarkerManager;
    }());

    var defaults = {
        lines: 12,
        length: 7,
        width: 5,
        radius: 10,
        scale: 1.0,
        corners: 1,
        color: '#000',
        fadeColor: 'transparent',
        animation: 'spinner-line-fade-default',
        rotate: 0,
        direction: 1,
        speed: 1,
        zIndex: 2e9,
        className: 'spinner',
        top: '50%',
        left: '50%',
        shadow: '0 0 1px transparent',
        position: 'absolute',
    };
    var Spinner = (function () {
        function Spinner(opts) {
            if (opts === void 0) { opts = {}; }
            this.opts = __assign$1(__assign$1({}, defaults), opts);
        }
        Spinner.prototype.spin = function (target) {
            this.stop();
            this.el = document.createElement('div');
            if (this.opts.className) {
                this.el.className = this.opts.className;
            }
            this.el.setAttribute('role', 'progressbar');
            css(this.el, {
                position: this.opts.position,
                width: 0,
                zIndex: this.opts.zIndex,
                left: this.opts.left,
                top: this.opts.top,
                transform: "scale(" + this.opts.scale + ")",
            });
            if (target) {
                target.insertBefore(this.el, target.firstChild || null);
            }
            drawLines(this.el, this.opts);
            return this;
        };
        Spinner.prototype.stop = function () {
            if (this.el) {
                if (typeof requestAnimationFrame !== 'undefined') {
                    cancelAnimationFrame(this.animateId);
                }
                else {
                    clearTimeout(this.animateId);
                }
                if (this.el.parentNode) {
                    this.el.parentNode.removeChild(this.el);
                }
                this.el = undefined;
            }
            return this;
        };
        return Spinner;
    }());
    function css(el, props) {
        for (var key in props) {
            el.style[key] = props[key];
        }
        return el;
    }
    function getColor(color, idx) {
        return typeof color === 'string' ? color : color[idx % color.length];
    }
    function drawLines(el, opts) {
        var borderRadius = (Math.round(opts.corners * opts.width * 500) / 1000) + 'px';
        var shadow = 'none';
        if (opts.shadow === true) {
            shadow = '0 2px 4px #000';
        }
        else if (typeof opts.shadow === 'string') {
            shadow = opts.shadow;
        }
        var shadows = parseBoxShadow(shadow);
        for (var i = 0; i < opts.lines; i++) {
            var degrees = ~~(360 / opts.lines * i + opts.rotate);
            var backgroundLine = css(document.createElement('div'), {
                position: 'absolute',
                top: -opts.width / 2 + "px",
                width: (opts.length + opts.width) + 'px',
                height: opts.width + 'px',
                background: getColor(opts.fadeColor, i),
                borderRadius: borderRadius,
                transformOrigin: 'left',
                transform: "rotate(" + degrees + "deg) translateX(" + opts.radius + "px)",
            });
            var delay = i * opts.direction / opts.lines / opts.speed;
            delay -= 1 / opts.speed;
            var line = css(document.createElement('div'), {
                width: '100%',
                height: '100%',
                background: getColor(opts.color, i),
                borderRadius: borderRadius,
                boxShadow: normalizeShadow(shadows, degrees),
                animation: 1 / opts.speed + "s linear " + delay + "s infinite " + opts.animation,
            });
            backgroundLine.appendChild(line);
            el.appendChild(backgroundLine);
        }
    }
    function parseBoxShadow(boxShadow) {
        var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
        var shadows = [];
        for (var _i = 0, _a = boxShadow.split(','); _i < _a.length; _i++) {
            var shadow = _a[_i];
            var matches = shadow.match(regex);
            if (matches === null) {
                continue;
            }
            var x = +matches[2];
            var y = +matches[5];
            var xUnits = matches[4];
            var yUnits = matches[7];
            if (x === 0 && !xUnits) {
                xUnits = yUnits;
            }
            if (y === 0 && !yUnits) {
                yUnits = xUnits;
            }
            if (xUnits !== yUnits) {
                continue;
            }
            shadows.push({
                prefix: matches[1] || '',
                x: x,
                y: y,
                xUnits: xUnits,
                yUnits: yUnits,
                end: matches[8],
            });
        }
        return shadows;
    }
    function normalizeShadow(shadows, degrees) {
        var normalized = [];
        for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
            var shadow = shadows_1[_i];
            var xy = convertOffset(shadow.x, shadow.y, degrees);
            normalized.push(shadow.prefix + xy[0] + shadow.xUnits + ' ' + xy[1] + shadow.yUnits + shadow.end);
        }
        return normalized.join(', ');
    }
    function convertOffset(x, y, degrees) {
        var radians = degrees * Math.PI / 180;
        var sin = Math.sin(radians);
        var cos = Math.cos(radians);
        return [
            Math.round((x * cos + y * sin) * 1000) / 1000,
            Math.round((-x * sin + y * cos) * 1000) / 1000,
        ];
    }

    var Tool = (function () {
        function Tool() {
            this._spinner = new Spinner();
            this._loadingDom = document.createElement('div');
            this._loadingDom.className = 'ngr-loading';
            this._tipDom = document.createElement('div');
            this._tipDom.className = 'ngr-tip';
        }
        Tool.prototype.setLoadingStyle = function (styles) {
            for (var key in styles) {
                this._loadingDom.style[key] = styles[key];
            }
        };
        Tool.prototype.setTipStyle = function (styles) {
            for (var key in styles) {
                this._tipDom.style[key] = styles[key];
            }
        };
        Tool.prototype.loading = function () {
            if (!this._loadingDom.parentElement) {
                this._spinner.spin(this._loadingDom);
                document.body.appendChild(this._loadingDom);
            }
        };
        Tool.prototype.hideLoading = function () {
            this._spinner.stop();
            this._loadingDom.remove();
        };
        Tool.prototype.tip = function (texts, time) {
            var _this = this;
            if (time === void 0) { time = 2000; }
            if (this._tipTimer) {
                this._tipDom.innerHTML = '';
                clearTimeout(this._tipTimer);
                delete this._tipTimer;
            }
            var arr = [];
            if (typeof texts === 'string') {
                this._tipDom.style.textAlign = 'center';
                arr.push(texts);
            }
            else if (Array.isArray(texts)) {
                arr = texts;
            }
            for (var i = 0; i < arr.length; i += 1) {
                var textSpan = document.createElement('span');
                textSpan.className = 'ngr-text-span';
                textSpan.textContent = arr[i];
                var br = document.createElement('br');
                this._tipDom.appendChild(textSpan);
                this._tipDom.appendChild(br);
            }
            if (!this._tipDom.parentElement) {
                document.body.appendChild(this._tipDom);
            }
            if (time !== 0) {
                this._tipTimer = window.setTimeout(function () { return _this._tipDom.remove(); }, time);
            }
        };
        Tool.prototype.hideTip = function () {
            this._tipDom.remove();
        };
        return Tool;
    }());
    var tool = new Tool();
    function setLoadingStyle(styles) {
        tool.setLoadingStyle(styles);
    }
    function loading() {
        tool.loading();
    }
    function hideLoading() {
        tool.hideLoading();
    }
    function setTipStyle(styles) {
        tool.setTipStyle(styles);
    }
    function tip(texts, time) {
        if (time === void 0) { time = 2000; }
        tool.tip(texts, time);
    }
    function hideTip() {
        tool.hideTip();
    }

    var TOOL = /*#__PURE__*/Object.freeze({
        __proto__: null,
        setLoadingStyle: setLoadingStyle,
        loading: loading,
        hideLoading: hideLoading,
        setTipStyle: setTipStyle,
        tip: tip,
        hideTip: hideTip
    });

    var AudioProvider = (function () {
        function AudioProvider() {
            this._audioStack = [];
            this._status = 'open';
            this._isPlaying = false;
            bindAll([
                '_onPlaying',
                '_onPlayEnd',
            ], this);
            this._dom = document.createElement('audio');
            this._initDom();
            this._initToken();
        }
        AudioProvider.prototype._initToken = function () {
            var _this = this;
            return new HttpClient().get(AudioProvider.TOKEN_SERVER).then(function (res) {
                _this._token = res.data;
            });
        };
        AudioProvider.prototype._onPlaying = function () {
            this._isPlaying = true;
        };
        AudioProvider.prototype._onPlayEnd = function () {
            this._isPlaying = false;
            this.playMessage(this._audioStack.shift());
        };
        AudioProvider.prototype.playMessage = function (msg, isForce) {
            if (isForce === void 0) { isForce = false; }
            return __awaiter(this, void 0, void 0, function () {
                var url;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!msg || this._status === 'close')
                                return [2];
                            LogMgr$1.log('zhengli 7 msg:' + msg
                                + ' isForce:' + isForce);
                            if (this._isPlaying) {
                                isForce && this._audioStack.push(msg);
                                return [2];
                            }
                            if (!!this._token) return [3, 2];
                            return [4, this._initToken()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            url = AudioProvider.AUDIO_SERVER + "?tex=" + msg + "&tok=" + this._token + "&cuid=cuid&ctp=1&lan=zh";
                            this._dom.src = url;
                            this._isPlaying = true;
                            this._dom.play();
                            return [2];
                    }
                });
            });
        };
        AudioProvider.prototype.open = function () {
            this._status = 'open';
            this._dom.muted = false;
        };
        AudioProvider.prototype.close = function () {
            this._status = 'close';
            this._dom.muted = true;
        };
        AudioProvider.prototype.destroy = function () {
            this._status = 'open';
            this._isPlaying = false;
            this._dom.removeEventListener('playing', this._onPlaying);
            this._dom.removeEventListener('ended', this._onPlayEnd);
            this._dom.remove();
        };
        AudioProvider.prototype._initDom = function () {
            this._dom.addEventListener('playing', this._onPlaying);
            this._dom.addEventListener('ended', this._onPlayEnd);
            this._dom.style.display = 'none';
            document.body.appendChild(this._dom);
        };
        AudioProvider.prototype.refresh = function () {
            this.destroy();
            this._dom = document.createElement('audio');
            this._initDom();
        };
        AudioProvider.TOKEN_SERVER = 'https://auth.ipalmap.com/audiotoken/token';
        AudioProvider.AUDIO_SERVER = 'https://tsn.baidu.com/text2audio';
        return AudioProvider;
    }());

    var defaultOptions$1 = {
        lineWidth: 15,
        lineHeight: 0,
        multilineOpacity: 0.8,
        changeFloorTime: 600,
        maxDistanceArriving: 3,
        maxRoadAttachDistance: 20,
        maxDistanceReInitNavi: 30,
        outdoorMaxRoadAttachDistance: 20,
        outdoorMaxDistanceReInitNavi: 30,
        maxShakeDistance: 1,
        navigatingZoom: 21,
        navigatingPitch: 60,
        navigatingOffset: [0, 150],
        rotateSpeed: 220,
        autoTip: true,
        restRotateDistance: 0.3,
        hideControlByNavigating: ['view', 'floor', 'locate'],
        strategies: ['shortest', 'elevator', 'escalator', 'stair', 'ramp'],
        defaultStrategy: 'shortest',
        maxDistanceArriveTip: 15,
        fitPadding: 120,
        simSpeed: 3,
        simNaviInfoInterval: 1000,
        maxFacilityDis: 10,
        recoveryTime: 5000,
        adsorbFacilityDis: 6,
        simulateEasing: 'easeInOutSine',
        naviServer: 'https://pmap.ipalmap.com/pathplan/pathDemo/navi',
        defaultFloorGap: 2,
        recommendRouteType: 'escalator',
        startLimitLength: 0,
        offline: false,
        isAddFacilityTip: true,
        facilityTipStyle: {},
        maxHisNoticeDistance: 10,
        naviFailedTip: '璇锋眰瀵艰埅澶辫触',
        reInitTip: '姝ｅ湪涓烘偍閲嶆柊瑙勫垝璺嚎',
        beforeArriveTip: '鎮ㄥ凡鎺ヨ繎鐩殑鍦�,璇风暀鎰�',
        noRouteTip: '鏆傛棤姝よ矾绾�',
        deviateReInitNum: 3,
        reInitTimeDiff: 10,
        showShortest: false,
        shortestLineConfig: {
            visible: true,
            lineWidth: 1,
            lineColor: '#ff0000',
            height: 100000
        },
        isShowNaviProgress: false
    };

    var Navigate = (function (_super) {
        __extends$1(Navigate, _super);
        function Navigate(options) {
            var _this = _super.call(this) || this;
            _this._isInitNavi = false;
            _this._locationMng = null;
            _this._status = 'init';
            _this._isTipEnd = false;
            _this._isPlayWill = false;
            _this._isMapRotate = false;
            _this._audioProvider = new AudioProvider();
            _this._isInInterrupt = false;
            _this._simIndex = 0;
            _this._canPop = false;
            _this._otherFloorNum = 0;
            _this._facilityTipMarkers = [];
            _this._isPlayingMoveToFloor = false;
            _this._lastFloorIsOutdoor = false;
            _this._locationIsStart = true;
            _this._navigateViewType = 'first';
            _this._deviateNum = 0;
            _this._interruptNum = 0;
            _this._reInitNaviTime = 0;
            _this._navigateSpeed = 0;
            _this._interruptRestTime = 0;
            _this._interruptRestDistance = 0;
            _this._isNaviSleep = false;
            bindAll([
                '_onMapGestureStart',
                '_onMapGestureEnd',
                '_onMapRotate',
            ], _this);
            _this._options = __assign$1(__assign$1({}, defaultOptions$1), options);
            _this._markerMng = new MarkerManager(_this._options.markerConfig);
            return _this;
        }
        Navigate.prototype.GetOption = function () {
            return this._options;
        };
        Navigate.prototype.addTo = function (mapView) {
            this._mapView = mapView;
            this._mapView.setCurNavi(this);
            this._mapView.on('gestureStart', this._onMapGestureStart);
            this._mapView.on('gestureEnd', this._onMapGestureEnd);
            this._mapView.on('rotate', this._onMapRotate);
            this._markerMng.addTo(mapView);
            this._naviMng = new NaviManager(mapView, {
                lineImage: this._options.lineImage,
                lineWidth: this._options.lineWidth,
                server: this._options.naviServer,
                lineHeight: this._options.lineHeight,
                multilineOpacity: this._options.multilineOpacity,
                defaultFloorGap: this._options.defaultFloorGap,
                recommendRouteType: this._options.recommendRouteType,
                defaultStrategy: this._options.defaultStrategy,
                startLimitLength: this._options.startLimitLength,
                offline: this._options.offline,
                grayImage: this._options.grayImage,
                showShortest: this._options.showShortest,
                shortestLineConfig: this._options.shortestLineConfig,
                isShowNaviProgress: this._options.isShowNaviProgress
            });
            this._dynamicMng = new DynamicNaviManager(mapView, {
                rotateSpeed: this._options.rotateSpeed,
                offset: this._options.navigatingOffset,
                restRotateDistance: this._options.restRotateDistance,
                maxFacilityDis: this._options.maxFacilityDis,
                adsorbFacilityDis: this._options.adsorbFacilityDis,
            });
            this.UpdateNaviConfig();
        };
        Navigate.prototype.getMarkerMgr = function () {
            return this._markerMng;
        };
        Navigate.prototype.setNavigateViewType = function (viewType) {
            this._navigateViewType = viewType;
        };
        Navigate.prototype.UpdateNaviConfig = function () {
            if (this._mapView == null || this._mapView == undefined) {
                return;
            }
            if (this._options == null || this._options == undefined) {
                return;
            }
            var naviParam = this._mapView.GetNaviParam();
            this._options.maxRoadAttachDistance = naviParam.maxRoadAttachDistance;
            this._options.maxDistanceReInitNavi = naviParam.maxDistanceReInitNavi;
            this._options.outdoorMaxRoadAttachDistance = naviParam.maxOutRoadAttachDistance;
            this._options.outdoorMaxDistanceReInitNavi = naviParam.maxOutDistanceReInitNavi;
        };
        Navigate.prototype.interruptNavigating = function () {
            if (this._status === 'init')
                return;
            this.fire('navigatingInterrupt');
            this._mapView && this._mapView.stop();
            if (this._simAnimator) {
                this._simAnimator.pause();
            }
            else {
                this._interruptNum += 1;
            }
            this._isInInterrupt = true;
        };
        Navigate.prototype._onMapGestureStart = function () {
            if (this._status === 'init' || (this._status === 'simulateNavigate' && this._navigateViewType !== 'first'))
                return;
            this.interruptNavigating();
            if (this._touchTimer) {
                clearTimeout(this._touchTimer);
                delete this._touchTimer;
            }
        };
        Navigate.prototype._onMapGestureEnd = function () {
            var _this = this;
            if (this._status === 'init' || (this._status === 'simulateNavigate' && this._navigateViewType !== 'first'))
                return;
            this.fire('recoveryNavigatingReady');
            this._touchTimer = window.setTimeout(function () {
                _this.recoveryNavigating();
            }, this._options.recoveryTime);
        };
        Navigate.prototype._onMapRotate = function () {
            if (this._status !== 'simulateNavigate' || !this._dynamicMng)
                return;
            var thirdViewRotate = this._dynamicMng.crtSegment.getRotate();
            if (this._mapView && this._mapView.getRotate()) {
                thirdViewRotate = this._dynamicMng.crtSegment.getRotate() - this._mapView.getRotate();
            }
            var simMarker = this._markerMng.getMarker('sim');
            if (!simMarker)
                return;
            simMarker.setRotate(this._navigateViewType === 'first' ? 0 : thirdViewRotate);
        };
        Navigate.prototype.recoveryNavigating = function () {
            var _this = this;
            if (!this._mapView || !this._dynamicMng || !this._isInInterrupt)
                return;
            this._isInInterrupt = false;
            if (this._touchTimer) {
                clearTimeout(this._touchTimer);
                delete this._touchTimer;
            }
            this.fire('recoveryNavigating');
            if (this._status === 'navigating') {
                if (this._options.isShowNaviProgress) {
                    this.setCountdownTimer();
                }
                if (!this._locationMng)
                    return;
                var position = this._locationMng.getPosition();
                if (!position)
                    return;
                this._navigateViewType === 'first' && this._mapView.easeTo({
                    center: position.coordinate,
                    offset: this._options.navigatingOffset,
                    rotate: this._dynamicMng.crtRotate,
                    duration: 300,
                    easing: 'linear',
                });
            }
            else if (this._status === 'simulateNavigate') {
                var simMarker = this._markerMng.getMarker('sim');
                if (!simMarker)
                    return;
                var position = simMarker.getPosition();
                if (!position)
                    return;
                this._navigateViewType === 'first' && this._mapView.easeTo({
                    center: position.coordinate,
                    offset: this._options.navigatingOffset,
                    rotate: this._dynamicMng.crtRotate,
                    duration: 300,
                    easing: 'linear',
                });
                sleep(316).then(function () {
                    if (_this._options.isShowNaviProgress) {
                        _this.setCountdownTimer();
                    }
                    if (_this._simAnimator) {
                        if (!_this._navigateSpeed) {
                            _this._simAnimator.play(false);
                        }
                        else {
                            _this._simAnimator.play(true);
                        }
                    }
                    else {
                        _this._simulate();
                    }
                });
            }
        };
        Navigate.prototype.updateSpeed = function (nowSpeed) {
            var _this = this;
            this.interruptNavigating();
            this._navigateSpeed = nowSpeed;
            setTimeout(function () {
                _this.recoveryNavigating();
            }, 1000);
        };
        Navigate.prototype.getActiveRouteType = function () {
            return this._naviMng && this._naviMng.getActiveRouteType();
        };
        Navigate.prototype.getRecommendRouteType = function () {
            return this._naviMng && this._naviMng.getRecommendRouteType();
        };
        Navigate.prototype.initNavi = function () {
            return __awaiter(this, void 0, void 0, function () {
                var startMarker, endMarker, startPosition, endPosition;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            startMarker = this.getMarker('start') ? this.getMarker('start') : this.getMarker('indoorStart');
                            endMarker = this.getMarker('end');
                            if (!startMarker || !endMarker) {
                                console.error('initNavi: startMarker and endMarker is all required');
                                return [2];
                            }
                            startPosition = startMarker.getPosition();
                            endPosition = endMarker.getPosition();
                            if (!startPosition || !endPosition) {
                                console.error('initNavi: startPosition and endPosition is all required');
                                return [2];
                            }
                            this.fire('beforeInitNavi');
                            this._naviMng && this._naviMng.resetActiveRouteType();
                            return [4, this._renderNavi(startPosition, endPosition)];
                        case 1:
                            _a.sent();
                            this.fire('initNavi');
                            return [2];
                    }
                });
            });
        };
        Navigate.prototype.addFacilityTip = function () {
            if (!this._dynamicMng)
                return;
            var segments = this._dynamicMng.getSegments();
            var facilitySegs = [];
            for (var i = 0; i < segments.length; i += 1) {
                if (segments[i].isFacility()) {
                    facilitySegs.push(segments[i]);
                }
            }
            var arr = [];
            for (var i = 0; i < facilitySegs.length; i += 1) {
                var segObj = {
                    direction: facilitySegs[i].getDirection(),
                    facilityTipText: facilitySegs[i].getFacilityTipText(),
                    nextFloorAddress: facilitySegs[i].getNextFloorAddress(),
                };
                var tipContent = this.getFacilityTipContent(segObj);
                var facilityObj = {
                    floor: facilitySegs[i].floor,
                    coord: facilitySegs[i].getEnd(),
                    tipContent: tipContent,
                };
                arr.push(facilityObj);
            }
            this.setFacilityTipMarkers(arr);
        };
        Navigate.prototype.getFacilityTipContent = function (segObj) {
            var direction = segObj.direction, facilityTipText = segObj.facilityTipText, nextFloorAddress = segObj.nextFloorAddress;
            var facilityText = {
                elevator: '鐢垫',
                escalator: '鎵舵',
                stairs: '妤兼',
                ramp: '鍧￠亾',
            };
            var facility = '';
            if (facilityText[facilityTipText]) {
                facility = facilityText[facilityTipText];
            }
            else {
                facility = facilityTipText;
            }
            switch (direction) {
                case 'top':
                    if (facilityTipText === '鍧￠亾') {
                        return "\u6CBF\u9053\u8DEF\u81F3" + nextFloorAddress;
                    }
                    else {
                        return "" + (facilityTipText === '妤兼' ? '璧�' : '涔�') + facility + "\u4E0A\u884C\u81F3" + nextFloorAddress;
                    }
                case 'bottom':
                    if (facilityTipText === '鍧￠亾') {
                        return "\u6CBF\u9053\u8DEF\u81F3" + nextFloorAddress;
                    }
                    else {
                        return "" + (facilityTipText === '妤兼' ? '璧�' : '涔�') + facility + "\u4E0B\u884C\u81F3" + nextFloorAddress;
                    }
                default: {
                    return '';
                }
            }
        };
        Navigate.prototype.setFacilityTipMarkers = function (arr) {
            this.removeFacilityTipMarkers();
            for (var i = 0; i < arr.length; i += 1) {
                var _a = arr[i], floor = _a.floor, coord = _a.coord, tipContent = _a.tipContent;
                if (this._mapView) {
                    var dom = document.createElement('div');
                    var defaultTipStyle = {
                        minWidth: '130px',
                        height: '47px',
                        fontSize: '12px',
                        color: '#fff',
                        paddingTop: '8px',
                        display: 'flex',
                        justifyContent: 'center',
                        background: this._options.facilityTipBg ? "url(" + this._options.facilityTipBg + ")" : '#666',
                        backgroundSize: '100% 100%',
                    };
                    var tipStyle = __assign$1(__assign$1({}, defaultTipStyle), this._options.facilityTipStyle);
                    for (var key in tipStyle) {
                        dom.style[key] = tipStyle[key];
                    }
                    dom.innerText = tipContent;
                    var marker = new Marker(dom, { anchor: 'bottom' });
                    marker.addTo(this._mapView);
                    marker.setPosition(floor, { x: coord.x, y: coord.y });
                    this._facilityTipMarkers.push(marker);
                }
            }
        };
        Navigate.prototype.removeFacilityTipMarkers = function () {
            if (this._facilityTipMarkers && this._facilityTipMarkers.length > 0) {
                this._facilityTipMarkers.forEach(function (item) {
                    item.remove();
                });
            }
            this._facilityTipMarkers.length = 0;
        };
        Navigate.prototype.initOutDoorNavi = function (origin, destination, floorId) {
            return __awaiter(this, void 0, void 0, function () {
                var result, features;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._options.autoTip && loading();
                            this._isInitNavi = true;
                            if (!this._naviMng)
                                return [2];
                            return [4, this._naviMng.renderOutDoorNavi(origin, destination, floorId)];
                        case 1:
                            result = _a.sent();
                            features = this._naviMng.getActiveRoute();
                            if (this._dynamicMng && features) {
                                this._dynamicMng.init(features);
                            }
                            this.fire('initNaviOutDoor');
                            this._options.autoTip && hideLoading();
                            return [2, result];
                    }
                });
            });
        };
        Navigate.prototype.getWholeDistance = function () {
            if (!this._dynamicMng)
                return -1;
            return this._dynamicMng.getWholeDistance();
        };
        Navigate.prototype.getAllRouteType = function () {
            if (!this._naviMng)
                return [];
            return this._naviMng.getAllRouteType();
        };
        Navigate.prototype.setActiveRoute = function (activeRouteType) {
            return __awaiter(this, void 0, void 0, function () {
                var locationPosition, endMarker, endPosition, floorId, coordinate, activeRoute, e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._naviMng || this._naviMng.getActiveRouteType() === activeRouteType)
                                return [2];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, 4, 5]);
                            this._options.autoTip && loading();
                            if (this._status === 'navigating' && this._locationMng) {
                                locationPosition = this._locationMng.getPosition();
                                endMarker = this._markerMng.getMarker('end');
                                if (endMarker && locationPosition) {
                                    endPosition = endMarker.getPosition();
                                    if (endPosition) {
                                        floorId = locationPosition.floorId, coordinate = locationPosition.coordinate;
                                        this.setStartMarker(floorId, coordinate);
                                        this._naviMng.resetStartEnd(locationPosition, endPosition);
                                    }
                                }
                            }
                            return [4, this._naviMng.setActiveRoute(activeRouteType)];
                        case 2:
                            _a.sent();
                            activeRoute = this._naviMng.getActiveRoute();
                            activeRoute && this._dynamicMng && this._dynamicMng.init(activeRoute);
                            this._options.isAddFacilityTip && this.addFacilityTip();
                            return [3, 5];
                        case 3:
                            e_1 = _a.sent();
                            this._options.autoTip && hideLoading();
                            this.removeFacilityTipMarkers();
                            throw e_1;
                        case 4:
                            this._options.autoTip && hideLoading();
                            this.fire('setActiveRoute');
                            return [7];
                        case 5: return [2];
                    }
                });
            });
        };
        Navigate.prototype._beforeReInit = function (locationPosition, endPosition) {
            return __awaiter(this, void 0, void 0, function () {
                var maxRoadAttachDistance, locationFloor, coordinate, message, closestResult;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._dynamicMng)
                                return [2];
                            maxRoadAttachDistance = this._options.maxRoadAttachDistance;
                            if (this._lastFloor === 'outdoor') {
                                maxRoadAttachDistance = this._options.outdoorMaxRoadAttachDistance;
                            }
                            locationFloor = locationPosition.floorId, coordinate = locationPosition.coordinate;
                            message = language.get('reInitTip');
                            this._tip(message);
                            return [4, this._renderNavi(locationPosition, endPosition)];
                        case 1:
                            _a.sent();
                            closestResult = this._dynamicMng.getClosestCoord(locationFloor, coordinate);
                            if (closestResult.distance < maxRoadAttachDistance) {
                                this._setupNavigating(locationFloor, closestResult.coordinate, closestResult.index);
                            }
                            return [2];
                    }
                });
            });
        };
        Navigate.prototype.startNavigate = function () {
            return __awaiter(this, void 0, void 0, function () {
                var endMarker, endPosition, locationPosition, locationFloor, coordinate, maxRoadAttachDistance, floorSet, closestResult;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._mapView || !this._dynamicMng || !this._naviMng)
                                return [2];
                            if (!this._locationMng) {
                                console.error('startNavigate: 闇€瑕佽缃� setLocationManager');
                                return [2];
                            }
                            endMarker = this._markerMng.getMarker('end');
                            if (!this._isCanNavi() || !endMarker) {
                                console.error('startNavigate: 璇峰厛瑙勫垝璺嚎');
                                return [2];
                            }
                            endPosition = endMarker.getPosition();
                            locationPosition = this._locationMng.getPosition();
                            if (!locationPosition || !endPosition) {
                                console.error('startNavigate: 鏃犲畾浣嶇偣鏃犳硶寮€濮嬪鑸�');
                                return [2];
                            }
                            this._preNavigating();
                            this._locationMng.startNavigate();
                            locationFloor = locationPosition.floorId, coordinate = locationPosition.coordinate;
                            if (!(locationFloor !== this._mapView.currentFloor)) return [3, 3];
                            return [4, this._mapView.setCurrentFloor(locationFloor)];
                        case 1:
                            _a.sent();
                            return [4, sleep(this._options.changeFloorTime)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            maxRoadAttachDistance = this._options.maxRoadAttachDistance;
                            if (this._lastFloor === 'outdoor') {
                                maxRoadAttachDistance = this._options.outdoorMaxRoadAttachDistance;
                            }
                            floorSet = new Set(this._naviMng.getFloorOrder());
                            if (floorSet.has(locationFloor)) {
                                closestResult = this._dynamicMng.getClosestCoord(locationFloor, coordinate);
                                if (closestResult.distance < maxRoadAttachDistance) {
                                    this._setupNavigating(locationFloor, closestResult.coordinate, closestResult.index);
                                }
                                else {
                                    this._beforeReInit(locationPosition, endPosition);
                                }
                            }
                            else {
                                this._beforeReInit(locationPosition, endPosition);
                            }
                            return [4, sleep(1000)];
                        case 4:
                            _a.sent();
                            this._status = 'navigating';
                            this.fire('startNavigate');
                            return [2];
                    }
                });
            });
        };
        Navigate.prototype.getNaviClosestCoord = function (floorId, coordinate) {
            if (!this._dynamicMng)
                return;
            return this._dynamicMng.getClosestCoord(floorId, coordinate);
        };
        Navigate.prototype._setupNavigating = function (floorId, coordinate, index) {
            return __awaiter(this, void 0, void 0, function () {
                var info, distanceToEnd, easyNaviTextArray;
                return __generator(this, function (_a) {
                    if (!this._locationMng || !this._dynamicMng || !this._mapView || !this._naviMng)
                        return [2];
                    this._locationMng.setPosition(floorId, coordinate);
                    this._dynamicMng.findNearSegment(index, coordinate, false);
                    info = this._dynamicMng.getMessageInNavi();
                    distanceToEnd = this._dynamicMng.distanceToEnd(index, coordinate);
                    this._fireNavigatingInfo(__assign$1(__assign$1({}, info), { distanceToEnd: distanceToEnd }));
                    this._naviMng.setWalked(floorId, coordinate, index);
                    this._fireARChange(floorId, coordinate);
                    this._navigateViewType === 'first' && this._mapView.easeTo({
                        center: coordinate,
                        zoom: this._options.navigatingZoom,
                        pitch: this._options.navigatingPitch,
                        rotate: this._dynamicMng.crtSegment.getRotate(),
                        duration: 1000,
                        offset: this._options.navigatingOffset,
                    });
                    easyNaviTextArray = this.GetEasyNaviVoiceTextArray();
                    LogMgr$1.log('easyNaviText: ' + easyNaviTextArray);
                    return [2];
                });
            });
        };
        Navigate.prototype._preNavigating = function () {
            this._audioProvider.refresh();
            this._naviMng && this._naviMng.setIsShowMultiline(false);
            this._toggleControl(false);
            this._mapView && this._mapView.setViewType('single');
        };
        Navigate.prototype.removeLayers = function () {
            this._markerMng.clear();
            this._naviMng && this._naviMng.removeLayer();
            this._dynamicMng && this._dynamicMng.reset();
            this.removeFacilityTipMarkers();
        };
        Navigate.prototype.removeOutDoorLineLayers = function () {
            this._markerMng.removeMarker('outdoorStart');
            this._naviMng && this._naviMng.removeOutDoorLineLayers();
        };
        Navigate.prototype._isCanNavi = function () {
            return this._naviMng && this._naviMng.hasNavi() &&
                this._dynamicMng && this._dynamicMng.getSegments().length > 0;
        };
        Navigate.prototype.locationChange = function (floorId, coordinate, duration) {
            if (!this._mapView)
                return;
            if (floorId === '0' || coordinate.x === 0 || coordinate.y === 0)
                return;
            var transFloor = floorId === 'outdoor' ? this._mapView.getDefaultFloor() : floorId;
            if (!transFloor)
                return;
            if (this._status === 'navigating') {
                var point = new Point(coordinate.x, coordinate.y);
                this._dynamicNavigate(transFloor, point, duration, floorId === 'outdoor');
            }
            else {
                this._locationMng && this._locationMng.setPosition(transFloor, coordinate, duration);
            }
            this.fire('locationChange', {
                floorId: floorId,
                coordinate: coordinate,
                duration: duration,
            });
            this._lastFloor = floorId;
        };
        Navigate.prototype.getNavigatingRotate = function () {
            if (!this._dynamicMng)
                return 0;
            return this._dynamicMng.crtRotate;
        };
        Navigate.prototype._fireARChange = function (floorId, coordinate) {
            if (!this._naviMng || !this._mapView)
                return;
            var engine = this._mapView.getEngine();
            if (!engine)
                return;
            this.fire('arChange', {
                coordinate: coordinate,
                line: this._naviMng.getRestLines(floorId),
                offset: engine.getOffset(),
            });
        };
        Navigate.prototype.getFloorOrder = function () {
            return this._naviMng ? this._naviMng.getFloorOrder() : [];
        };
        Navigate.prototype.IsNaviInDiffFloor = function () {
            var segments = this._dynamicMng.getSegments();
            if (segments == null || segments == undefined || segments.length == 0) {
                return 0;
            }
            var bDiffFloor = false;
            for (var i = 0; i < segments.length; i++) {
                var segment = segments[i];
                var nextSegment = null;
                if (i + 1 < segments.length) {
                    nextSegment = segments[i + 1];
                }
                if (segment == null || segment == undefined || nextSegment == null || nextSegment == undefined) {
                    continue;
                }
                if (nextSegment.floor != segment.floor) {
                    bDiffFloor = true;
                    break;
                }
            }
            return bDiffFloor;
        };
        Navigate.prototype.GetEasyNaviTextInDiffFloor = function () {
            var resultArray = [];
            var curSegment = this._dynamicMng.getCurSegment();
            var nextSegment = this._dynamicMng.getNextSegment();
            var maxFacilityDis = this._options.maxFacilityDis;
            var curCoord = this._dynamicMng.GetCurCoord();
            var firstText = null;
            if (curSegment == null || curSegment == undefined) {
                curSegment = nextSegment;
                if (nextSegment) {
                    nextSegment = nextSegment.getNextSegment();
                }
            }
            if (curSegment) {
                firstText = curSegment.getFirstEasyMessageInNavi(maxFacilityDis, curCoord, false, true);
                firstText.message = '1.' + firstText.message;
            }
            if (nextSegment) {
                var nextText = nextSegment.getMessageInNaviWithOutUpDownInfo(maxFacilityDis, null, false, true);
                if (firstText) {
                    firstText.message = firstText.message + nextText.message;
                }
            }
            var lastSegmentInCurFloor = this._dynamicMng.getLastSegmentInCurFloor();
            if (lastSegmentInCurFloor != curSegment) {
                if (lastSegmentInCurFloor) {
                    var lastSegmentTextInCurFloor = lastSegmentInCurFloor.getEasyMessageInCrossFloor(maxFacilityDis, null, false, true);
                    firstText.message = firstText.message + ', ' + lastSegmentTextInCurFloor.message;
                }
            }
            resultArray.push(firstText);
            var nextSegmentInNextFloor = this._dynamicMng.getNextSegmentBySegment(lastSegmentInCurFloor);
            if (nextSegmentInNextFloor) {
                var nextSegmentInSextFloorText = nextSegmentInNextFloor.getMessageInNextFloorFirstText(maxFacilityDis, null, false, true);
                nextSegmentInSextFloorText.message = '2.' + nextSegmentInSextFloorText.message + ', 鍓嶅線鐩殑鍦�';
                resultArray.push(nextSegmentInSextFloorText);
            }
            else {
                var nextSegmentInSextFloorText = { message: '2.鍒拌揪鐩殑鍦�' };
                resultArray.push(nextSegmentInSextFloorText);
            }
            return resultArray;
        };
        Navigate.prototype.GetEasyNaviTextInSameFloor = function () {
            var resultArray = [];
            var curSegment = this._dynamicMng.getCurSegment();
            var nextSegment = this._dynamicMng.getNextSegment();
            var nextSegment2 = this._dynamicMng.getNextSegmentBySegment(nextSegment);
            var maxFacilityDis = this._options.maxFacilityDis;
            var curCoord = this._dynamicMng.GetCurCoord();
            var firstText = null;
            if (curSegment == null || curSegment == undefined) {
                curSegment = nextSegment;
                if (nextSegment) {
                    nextSegment = nextSegment.getNextSegment();
                }
                if (nextSegment) {
                    nextSegment2 = nextSegment.getNextSegment();
                }
            }
            if (curSegment) {
                firstText = curSegment.getFirstEasyMessageInNavi(maxFacilityDis, curCoord, false, true);
                firstText.message = '1.' + firstText.message;
            }
            if (nextSegment) {
                var nextText = nextSegment.getMessageInNavi(maxFacilityDis, null, false, true, true);
                if (firstText) {
                    firstText.message = firstText.message + nextText.message;
                }
                resultArray.push(firstText);
            }
            else {
                resultArray.push(firstText);
                return resultArray;
            }
            if (nextSegment2) {
                var nextText2 = nextSegment2.getMessageInNavi(maxFacilityDis, null, false, true, true);
                nextText2.message = '2.' + nextText2.message + ', 鍓嶅線鐩殑鍦�';
                resultArray.push(nextText2);
            }
            else if (curSegment) {
                var nextText2 = curSegment.getFirstEasyMessageInNavi(maxFacilityDis, curCoord, false, true);
                nextText2.message = '2.鍒拌揪鐩殑鍦�';
                resultArray.push(nextText2);
            }
            else {
                var nextText2 = { message: '2.鍒拌揪鐩殑鍦�' };
                nextText2.message = '2.鍒拌揪鐩殑鍦�';
                resultArray.push(nextText2);
            }
            return resultArray;
        };
        Navigate.prototype.GetEasyNaviVoiceTextArray = function () {
            var bDiffFloor = this.IsNaviInDiffFloor();
            var resultArray = [];
            if (bDiffFloor) {
                resultArray = this.GetEasyNaviTextInDiffFloor();
            }
            else {
                resultArray = this.GetEasyNaviTextInSameFloor();
            }
            return resultArray;
        };
        Navigate.prototype.GetEasyNaviTextNoDiffFloor = function (coordinate) {
            var segment1 = null;
            var segments = this._dynamicMng.getSegments();
            if (segments.length >= 1) {
                segment1 = segments[0];
            }
            if (segments.length >= 2) ;
            if (segments.length >= 3) ;
            if (segment1) {
                if (coordinate) {
                    var startPoint = new Point(coordinate.x, coordinate.y);
                    startPoint.distanceTo(segment1._line.getEnd());
                }
            }
        };
        Navigate.prototype._dynamicNavigate = function (floorId, coordinate, duration, isOutdoor) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, maxDistanceReInitNavi, maxRoadAttachDistance, floorSet, segment, nextSegment, distance_1, _b, closestIndex, closestCoord, distance, oldIndex, oldSegment, distanceToEnd, segment, message, isInFlow, info, message;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            if (!this._mapView || !this._dynamicMng || !this._naviMng || !this._locationMng)
                                return [2];
                            if (this._isInitNavi) {
                                this._locationMng.setPosition(floorId, coordinate, duration);
                                this._fireARChange(floorId, coordinate);
                                return [2];
                            }
                            _a = this._options, maxDistanceReInitNavi = _a.maxDistanceReInitNavi, maxRoadAttachDistance = _a.maxRoadAttachDistance;
                            if (isOutdoor) {
                                maxDistanceReInitNavi = this._options.outdoorMaxDistanceReInitNavi;
                                maxRoadAttachDistance = this._options.outdoorMaxRoadAttachDistance;
                            }
                            if (!(floorId !== this._mapView.currentFloor)) return [3, 3];
                            return [4, this._mapView.setCurrentFloor(floorId)];
                        case 1:
                            _c.sent();
                            return [4, sleep(this._options.changeFloorTime)];
                        case 2:
                            _c.sent();
                            _c.label = 3;
                        case 3:
                            floorSet = new Set(this._naviMng.getFloorOrder());
                            if (!floorSet.has(floorId)) {
                                segment = this._dynamicMng.crtSegment;
                                if (!segment)
                                    return [2];
                                nextSegment = segment.getNextSegment();
                                distance_1 = segment.getEnd().distanceTo(coordinate);
                                if (distance_1 < maxRoadAttachDistance && (segment.isFacility() || (nextSegment && nextSegment.isFacility()))) {
                                    this._locationMng.setPosition(floorId, segment.getEnd(), duration);
                                    this._mapMoveToCenter(segment.getEnd(), duration);
                                    this._fireARChange(floorId, segment.getEnd());
                                    this._deviateNum = 0;
                                }
                                else {
                                    this._deviateNum += 1;
                                    this._locationMng.setPosition(floorId, coordinate, duration);
                                }
                                if (this._deviateNum >= this._options.deviateReInitNum) {
                                    this._reInitNavi(floorId, coordinate, isOutdoor);
                                    this._mapMoveToCenter(coordinate, duration);
                                    this._fireARChange(floorId, coordinate);
                                    this._deviateNum = 0;
                                }
                                return [2];
                            }
                            this._otherFloorNum = 0;
                            _b = this._dynamicMng.getClosestCoord(floorId, coordinate), closestIndex = _b.index, closestCoord = _b.coordinate, distance = _b.distance;
                            oldIndex = this._dynamicMng.crtIndex;
                            oldSegment = this._dynamicMng.crtSegment;
                            distanceToEnd = this._dynamicMng.distanceToEnd(closestIndex, closestCoord);
                            if (distanceToEnd < this._options.maxHisNoticeDistance) {
                                this.fire('showHisNotice');
                            }
                            if (floorId !== this._lastFloor && oldSegment && oldSegment.isFacility()) {
                                segment = this._dynamicMng.getSegments()[oldIndex + 1];
                                if (!segment)
                                    return [2];
                                closestIndex = oldIndex + 1;
                                distance = 0;
                                closestCoord = segment.getStart();
                            }
                            if (!(distance <= maxRoadAttachDistance)) return [3, 6];
                            if (this._isSameFloor(floorId) && distanceToEnd <= this._options.maxDistanceArriving) {
                                this._locationMng.setPosition(floorId, coordinate, duration);
                                this._mapMoveToCenter(coordinate, duration);
                                this._fireNavigateEnd();
                                this._naviMng.setAllWalked();
                                this._fireARChange(floorId, coordinate);
                                return [2];
                            }
                            if (this._lastDisToEnd && distanceToEnd > this._lastDisToEnd &&
                                distanceToEnd - this._lastDisToEnd < this._options.maxShakeDistance) {
                                return [2];
                            }
                            this._lastDisToEnd = distanceToEnd;
                            if (this._isSameFloor(floorId) && distanceToEnd < this._options.maxDistanceArriveTip &&
                                !this._isTipEnd &&
                                floorId === this._dynamicMng.getEndFloor()) {
                                message = language.getType() === 'cn' ? this._options.beforeArriveTip : 'You are near to your desination';
                                this._tip(message);
                                this._isTipEnd = true;
                            }
                            this._locationMng.setPosition(floorId, closestCoord, duration);
                            this._naviMng.setWalked(floorId, closestCoord, closestIndex);
                            this._fireARChange(floorId, closestCoord);
                            isInFlow = this._locationMng && this._locationMng.isEnableFlow();
                            this._dynamicMng.findNearSegment(closestIndex, closestCoord, !this._isInInterrupt && !isInFlow);
                            info = this._dynamicMng.getMessageInNavi();
                            this._fireNavigatingInfo(__assign$1(__assign$1({}, info), { distanceToEnd: distanceToEnd }));
                            if (oldIndex !== this._dynamicMng.crtIndex) {
                                this._isPlayWill = false;
                            }
                            else if (info.isWillChange && !this._isPlayWill) {
                                this._isPlayWill = true;
                            }
                            if (!(this._dynamicMng.crtRotate !== this._mapView.getRotate())) return [3, 5];
                            this._isMapRotate = true;
                            return [4, sleep(this._getRotateDuration(this._dynamicMng.crtRotate) + 16)];
                        case 4:
                            _c.sent();
                            this._isMapRotate = false;
                            _c.label = 5;
                        case 5:
                            !this._isMapRotate && this._mapMoveToCenter(closestCoord, duration);
                            return [3, 7];
                        case 6:
                            if (distance < maxDistanceReInitNavi) {
                                message = language.get('deviateTip');
                                this._fireNavigatingInfo({ message: message, distanceToEnd: distanceToEnd, isWillChange: false });
                                this._locationMng.setPosition(floorId, coordinate, duration);
                                this._fireARChange(floorId, coordinate);
                                this._mapMoveToCenter(coordinate, duration);
                            }
                            else {
                                this._locationMng.setPosition(floorId, coordinate, duration);
                                this._fireARChange(floorId, coordinate);
                                this._mapMoveToCenter(coordinate, duration);
                                this._reInitNavi(floorId, coordinate, isOutdoor);
                            }
                            _c.label = 7;
                        case 7:
                            this.fire('navigating');
                            return [2];
                    }
                });
            });
        };
        Navigate.prototype._isSameFloor = function (floorId) {
            if (!this._naviMng)
                return false;
            var floorOrder = this._naviMng.getFloorOrder();
            return floorOrder[floorOrder.length - 1] === floorId;
        };
        Navigate.prototype._getRotateDuration = function (rotate) {
            if (!this._mapView || typeof rotate !== 'number')
                return 0;
            var startRotate = this._mapView.getRotate() || 0;
            var targetRotate = Camera.normalizeRotate(rotate, startRotate);
            var delta = Math.abs(targetRotate - startRotate);
            return delta / this._options.rotateSpeed * 1000 + 16;
        };
        Navigate.prototype._mapMoveToCenter = function (center, duration) {
            if (!this._mapView)
                return;
            !this._isInInterrupt &&
                this._navigateViewType === 'first' &&
                this._mapView.easeTo({
                    center: center,
                    duration: duration,
                    easing: 'linear',
                    offset: this._options.navigatingOffset,
                });
        };
        Navigate.prototype._isCanReInitNavi = function () {
            return Date.now() - this._reInitNaviTime > this._options.reInitTimeDiff * 1000;
        };
        Navigate.prototype._reInitNavi = function (floorId, coordinate, isOutdoor) {
            return __awaiter(this, void 0, void 0, function () {
                var endMarker, endPosition, message;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this._lastReInitNaviPoint && this._lastReInitNaviPoint.equal(coordinate))
                                return [2];
                            if (!this._dynamicMng || !this._naviMng || !this._isCanReInitNavi())
                                return [2];
                            this._reInitNaviTime = Date.now();
                            this.setStartMarker(floorId, coordinate);
                            this._lastReInitNaviPoint = coordinate.clone();
                            endMarker = this._markerMng.getMarker('end');
                            if (!endMarker)
                                return [2];
                            endPosition = endMarker.getPosition();
                            if (!endPosition)
                                return [2];
                            message = language.getType() === 'cn' ? this._options.reInitTip : 'You are off course and are replanning your route';
                            this._tip(message);
                            delete this._lastDisToEnd;
                            return [4, this._renderNavi({ floorId: floorId, coordinate: coordinate }, endPosition, true)];
                        case 1:
                            _a.sent();
                            this._dynamicNavigate(floorId, coordinate, 500, isOutdoor);
                            this.fire('routeTypeChange', true);
                            return [2];
                    }
                });
            });
        };
        Navigate.prototype._resetStatus = function () {
            this._status = 'init';
            this._isPlayWill = false;
            this._isTipEnd = false;
            this._simIndex = 0;
            delete this._lastDisToEnd;
            this._isInInterrupt = false;
            if (this._touchTimer) {
                clearTimeout(this._touchTimer);
                delete this._touchTimer;
            }
            if (this._shortestRouteTimer) {
                clearTimeout(this._shortestRouteTimer);
                delete this._shortestRouteTimer;
            }
        };
        Navigate.prototype._toggleControl = function (isShow) {
            if (!this._mapView)
                return;
            var hideControlByNavigating = this._options.hideControlByNavigating;
            for (var i = 0; i < hideControlByNavigating.length; i += 1) {
                var control = this._mapView.getControl(hideControlByNavigating[i]);
                if (control) {
                    isShow ? control.show() : control.hide();
                }
            }
        };
        Navigate.prototype._tip = function (msg) {
            if (!this._options.autoTip)
                return;
            this.fire('tip', msg);
            tip(msg);
        };
        Navigate.prototype._fireNavigateEnd = function () {
            if (!this._mapView)
                return;
            this.fire('navigateEnd');
            this._resetStatus();
            this._status = 'SimulateNaviEnd';
            this._toggleControl(true);
            this._locationMng && this._locationMng.endNavigate();
        };
        Navigate.prototype.navigateComplete = function () {
            this.removeLayers();
        };
        Navigate.prototype.navigateCancel = function () {
            this._toggleControl(true);
            this._resetStatus();
            this._simAnimator && this._simAnimator.stop();
            this._mapView && this._mapView.stop();
            this._audioProvider.close();
            if (this._locationMng) {
                this._locationMng.show();
                this._locationMng.endNavigate();
            }
            this.removeLayers();
            this.fire('navigateCancel');
        };
        Navigate.prototype.exitNavigate = function () {
            return __awaiter(this, void 0, void 0, function () {
                var floorId, locPosition;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._mapView || !this._dynamicMng || !this._naviMng)
                                return [2];
                            this._resetStatus();
                            this._toggleControl(true);
                            this.removeMarker('sim');
                            this._simAnimator && this._simAnimator.stop();
                            this._mapView && this._mapView.stop();
                            this._audioProvider.close();
                            floorId = this._dynamicMng.getStartFloor();
                            if (this._locationMng) {
                                this._locationMng.show();
                                this._locationMng.endNavigate();
                                locPosition = this._locationMng.getPosition();
                                floorId = locPosition ? locPosition.floorId : floorId;
                            }
                            if (!(floorId !== this._mapView.currentFloor)) return [3, 3];
                            return [4, this._mapView.setCurrentFloor(floorId)];
                        case 1:
                            _a.sent();
                            return [4, sleep(this._options.changeFloorTime)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            this._naviMng.setIsShowMultiline(true);
                            this._dynamicMng && this._dynamicMng.resetTipMovePhone();
                            this.fire('exitNavigate');
                            return [2];
                    }
                });
            });
        };
        Navigate.prototype.fitNaviLine = function (mode) {
            if (mode === void 0) { mode = false; }
            if (!this._naviMng || !this._mapView || this._mapView.getViewType() === 'multiple')
                return;
            var fitPadding = this._options.fitPadding;
            var bounds = this._naviMng.getNaviBounds(mode);
            var zoom;
            bounds && (zoom = this._mapView.fitBounds(bounds, fitPadding));
            return zoom;
        };
        Navigate.prototype.setLocationManager = function (locationMng) {
            this._locationMng = locationMng;
        };
        Navigate.prototype.removeLocationManager = function () {
            delete this._locationMng;
        };
        Navigate.prototype.getStatus = function () {
            return this._status;
        };
        Navigate.prototype._renderNavi = function (startPosition, endPosition, isReinitNavi) {
            if (isReinitNavi === void 0) { isReinitNavi = false; }
            return __awaiter(this, void 0, void 0, function () {
                var features, error_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this._shortestRouteTimer) {
                                clearTimeout(this._shortestRouteTimer);
                                delete this._shortestRouteTimer;
                            }
                            if (!this._naviMng)
                                return [2];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, 4, 5]);
                            this._options.autoTip && loading();
                            this._isInitNavi = true;
                            return [4, this._naviMng.renderNavi(startPosition, endPosition)];
                        case 2:
                            _a.sent();
                            features = this._naviMng.getActiveRoute();
                            if (this._dynamicMng && features) {
                                this._dynamicMng.init(features);
                            }
                            this._options.isAddFacilityTip && this.addFacilityTip();
                            return [3, 5];
                        case 3:
                            error_1 = _a.sent();
                            if (isReinitNavi && this.getActiveRouteType() !== 'shortest') {
                                this._shortestRouteTimer = window.setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4, this.setActiveRoute('shortest')];
                                            case 1:
                                                _a.sent();
                                                return [2];
                                        }
                                    });
                                }); }, 1000);
                            }
                            else {
                                this._tip(language.getType() === 'cn' ? this._options.naviFailedTip : 'Navigate server maintenance is in process');
                                this._options.autoTip && hideLoading();
                                throw error_1;
                            }
                            return [3, 5];
                        case 4:
                            this._options.autoTip && hideLoading();
                            this._isInitNavi = false;
                            return [7];
                        case 5:
                            this.fire('renderNavi');
                            return [2];
                    }
                });
            });
        };
        Navigate.prototype.setPickMarker = function (floorId, coordinate) {
            this.setMarker('pick', floorId, coordinate);
            this.fire('setPickMarker', { floorId: floorId, coordinate: coordinate });
        };
        Navigate.prototype.setStartMarker = function (floorId, coordinate) {
            this.setMarker('start', floorId, coordinate);
        };
        Navigate.prototype.setEndMarker = function (floorId, coordinate) {
            this.setMarker('end', floorId, coordinate);
        };
        Navigate.prototype._lngLatToMercator = function (_a) {
            var lng = _a[0], lat = _a[1];
            var x = Number(lng) * 20037508.34 / 180;
            var y = Math.log(Math.tan((90 + Number(lat)) * Math.PI / 360)) / (Math.PI / 180);
            y = y * 20037508.34 / 180;
            return { x: x, y: y };
        };
        Navigate.prototype.setOutdoorStartMarker = function (floorId, LatLong) {
            var startMercator = this._lngLatToMercator(LatLong);
            this.setMarker('outdoorStart', floorId, startMercator);
            this.updateMarker('start', 'indoorStart');
        };
        Navigate.prototype.setOutdoorEndMarker = function (floorId, LatLong) {
            var endMercator = this._lngLatToMercator(LatLong);
            this.setMarker('outdoorEnd', floorId, endMercator);
        };
        Navigate.prototype.updateMarker = function (oldName, newName) {
            this._markerMng.updateMarker(oldName, newName);
        };
        Navigate.prototype.removeMarker = function (name) {
            this._markerMng.removeMarker(name);
        };
        Navigate.prototype.simulateNavigate = function () {
            return __awaiter(this, void 0, void 0, function () {
                var simSpeed, startFloor, routes, segments, info, easyNaviTextArray;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            simSpeed = this._options.simSpeed;
                            if (this._navigateSpeed) {
                                this._navigateSpeed = simSpeed;
                            }
                            if (this._options.isShowNaviProgress) {
                                (!this._naviProgress) && this.addProgress();
                            }
                            if (!this._mapView || !this._naviMng || !this._dynamicMng)
                                return [2];
                            if (!this._naviMng.hasNavi()) {
                                console.error('璇峰厛瑙勫垝璺嚎');
                                return [2];
                            }
                            this._status = 'simulateNavigate';
                            if (this._options.isShowNaviProgress) {
                                setTimeout(function () {
                                    _this.setCountdownTimer();
                                }, 3000);
                            }
                            this._preNavigating();
                            this._locationMng && this._locationMng.hide();
                            startFloor = this._dynamicMng.getStartFloor();
                            routes = this._naviMng.getRoutes();
                            this.setMarker('sim', startFloor, routes[0].line[0]);
                            if (!(startFloor !== this._mapView.currentFloor)) return [3, 3];
                            return [4, this._mapView.setCurrentFloor(startFloor)];
                        case 1:
                            _a.sent();
                            return [4, sleep(this._options.changeFloorTime)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            segments = this._dynamicMng.getSegments();
                            this._dynamicMng.findNearSegment(0, routes[0].line[0], false);
                            info = this._dynamicMng.getMessageInNavi(false);
                            this._fireNavigatingInfo(__assign$1(__assign$1({}, info), { distanceToEnd: this._dynamicMng.getWholeDistance() }));
                            easyNaviTextArray = this.GetEasyNaviVoiceTextArray();
                            this.fire('timeToGetEasyText', easyNaviTextArray);
                            this.OutPutEasyNaviText(easyNaviTextArray);
                            this._navigateViewType === 'first' ? this._mapView.easeTo({
                                center: routes[0].line[0],
                                zoom: this._options.navigatingZoom,
                                pitch: this._options.navigatingPitch,
                                rotate: segments[0].getRotate(),
                                duration: 3000,
                                offset: this._options.navigatingOffset,
                                complete: function () { return _this._simulate(); },
                            }) : this._simulate();
                            return [2];
                    }
                });
            });
        };
        Navigate.prototype.OutPutEasyNaviText = function (textArray) {
            if (textArray == null || textArray == undefined) {
                return;
            }
            LogMgr$1.log('Easy Navi Text:');
            for (var i = 0; i < textArray.length; i++) {
                LogMgr$1.log('' + textArray[i].message);
            }
        };
        Navigate.prototype.OnPickMarkerRemoved = function () {
            this.fire('OnPickMarkerRemoved');
        };
        Navigate.prototype._simulate = function () {
            var _this = this;
            if (!this._naviMng)
                return;
            if (this._status !== 'simulateNavigate')
                return;
            var routes = this._naviMng.getRoutes();
            console.log('Navigate.ts _simulate');
            MapView$1.GetInstance().OnClick2d3d();
            var simSpeed = this._options.simSpeed;
            var animate = function () { return __awaiter(_this, void 0, void 0, function () {
                var oldInterruptNum, endPoint, simMarker, coordinate, startPoint, distance, time, lastUpdateTime, thirdViewRotate;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this._status !== 'simulateNavigate' || !this._dynamicMng || !this._mapView)
                                return [2];
                            oldInterruptNum = this._interruptNum;
                            this._simAnimator && this._simAnimator.stop();
                            endPoint = routes[this._simIndex].line[1];
                            simMarker = this._markerMng.getMarker('sim');
                            coordinate = simMarker.getPosition().coordinate;
                            startPoint = new Point(coordinate.x, coordinate.y);
                            distance = startPoint.distanceTo(endPoint);
                            if (!this._navigateSpeed) {
                                time = Math.max(distance / simSpeed * 1000, 16);
                            }
                            else {
                                time = Math.max(distance / this._navigateSpeed * 1000, 16);
                            }
                            lastUpdateTime = Date.now();
                            this._dynamicMng.findNearSegment(this._simIndex, startPoint, this._navigateViewType === 'first');
                            thirdViewRotate = this._dynamicMng.crtSegment.getRotate();
                            if (this._mapView && this._mapView.getRotate()) {
                                thirdViewRotate = this._dynamicMng.crtSegment.getRotate() - this._mapView.getRotate();
                            }
                            simMarker.setRotate(this._navigateViewType === 'first' ? 0 : thirdViewRotate);
                            if (!(this._dynamicMng.crtRotate !== this._mapView.getRotate() && this._navigateViewType === 'first')) return [3, 2];
                            return [4, sleep(this._getRotateDuration(this._dynamicMng.crtRotate) + 16)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            if (this._interruptNum !== oldInterruptNum)
                                return [2];
                            this._dynamicMng.getMessageInNavi();
                            this._simAnimator = new Animator().ofObject(startPoint, endPoint, time);
                            this._simAnimator.easing(this._options.simulateEasing);
                            this._simAnimator.on('update', function (e) { return __awaiter(_this, void 0, void 0, function () {
                                var value, floorId, info_1, distanceToEnd;
                                return __generator(this, function (_a) {
                                    value = e;
                                    if (this._status !== 'simulateNavigate' ||
                                        !this._naviMng || !this._dynamicMng || !this._mapView)
                                        return [2];
                                    floorId = this._mapView.currentFloor;
                                    this.setMarker('sim', floorId, value);
                                    if (this._navigateViewType === 'first') {
                                        this._naviMng.setWalked(floorId, value, this._simIndex);
                                        this._mapView.setCenterByOffset(value, this._options.navigatingOffset);
                                    }
                                    if (Date.now() - lastUpdateTime > this._options.simNaviInfoInterval) {
                                        this._dynamicMng.findNearSegment(this._simIndex, new Point(value.x, value.y), false);
                                        info_1 = this._dynamicMng.getMessageInNavi(false);
                                        distanceToEnd = this._dynamicMng.distanceToEnd(this._simIndex, value);
                                        this._fireNavigatingInfo(__assign$1(__assign$1({}, info_1), { distanceToEnd: distanceToEnd }));
                                        if (info_1.isWillChange && !this._isPlayWill) {
                                            this._isPlayWill = true;
                                        }
                                        lastUpdateTime = Date.now();
                                    }
                                    return [2];
                                });
                            }); }).on('complete', function () { return __awaiter(_this, void 0, void 0, function () {
                                var info_2, distanceToEnd, nextPoint, sleepDuration;
                                var _this = this;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            delete this._simAnimator;
                                            this._isPlayWill = false;
                                            if (this._status !== 'simulateNavigate' ||
                                                !this._mapView || !this._dynamicMng || !this._naviMng)
                                                return [2];
                                            this._simIndex += 1;
                                            if (!routes[this._simIndex]) return [3, 5];
                                            if (!(routes[this._simIndex].floor === this._mapView.currentFloor)) return [3, 1];
                                            this._dynamicMng.findNearSegment(this._simIndex - 1, endPoint, this._navigateViewType === 'first');
                                            info_2 = this._dynamicMng.getMessageInNavi(false);
                                            distanceToEnd = this._dynamicMng.distanceToEnd(this._simIndex - 1, endPoint);
                                            this._fireNavigatingInfo(__assign$1(__assign$1({}, info_2), { distanceToEnd: distanceToEnd }));
                                            return [3, 4];
                                        case 1: return [4, this._mapView.setCurrentFloor(routes[this._simIndex].floor)];
                                        case 2:
                                            _a.sent();
                                            return [4, sleep(this._options.changeFloorTime)];
                                        case 3:
                                            _a.sent();
                                            if (this._status === 'simulateNavigate') {
                                                nextPoint = routes[this._simIndex].line[0];
                                                this._navigateViewType === 'first' && this._mapView.jumpTo({
                                                    center: nextPoint,
                                                    offset: this._options.navigatingOffset,
                                                });
                                                this.setMarker('sim', routes[this._simIndex].floor, nextPoint);
                                            }
                                            _a.label = 4;
                                        case 4:
                                            sleepDuration = this._navigateViewType === 'first' ?
                                                this._getRotateDuration(this._dynamicMng.crtRotate) : 0;
                                            this._isNaviSleep = true;
                                            this._interruptNum === oldInterruptNum && sleep(sleepDuration).then(function () {
                                                if ((_this._simIndex + 1) !== routes.length) {
                                                    _this._isNaviSleep = false;
                                                    if (_this._options.isShowNaviProgress) {
                                                        _this.setCountdownTimer();
                                                    }
                                                }
                                                _this._interruptNum === oldInterruptNum && animate();
                                            });
                                            return [3, 6];
                                        case 5:
                                            this.fire('simulateNavigateEnd');
                                            clearInterval(this._progressInter);
                                            this.destoryCountdownTime();
                                            this._resetStatus();
                                            this._toggleControl(true);
                                            this._locationMng && this._locationMng.show();
                                            this.removeMarker('sim');
                                            this._naviMng.setIsShowMultiline(true);
                                            _a.label = 6;
                                        case 6: return [2];
                                    }
                                });
                            }); }).on('changeSpeed', function (e) {
                                animate();
                            }).start();
                            return [2];
                    }
                });
            }); };
            animate();
        };
        Navigate.prototype.setCountdownTimer = function () {
            return __awaiter(this, void 0, void 0, function () {
                var countdown, simSpeed, segments, distance, orginTime, time, nowSpeed, t;
                var _this = this;
                return __generator(this, function (_a) {
                    if (!this._options.isShowNaviProgress)
                        return [2];
                    if (document.getElementById('ngr-countDown')) {
                        document.getElementById('ngr-countDown').style.zIndex = 100001;
                    }
                    countdown = document.getElementById('ngr-process');
                    if (!countdown)
                        return [2];
                    if (!this._dynamicMng)
                        return [2];
                    simSpeed = this._options.simSpeed;
                    segments = this._dynamicMng.getSegments();
                    distance = 0;
                    segments.map(function (item, i) {
                        distance += item.getDistance();
                    });
                    orginTime = Math.max(distance / simSpeed * 100, 0);
                    time = 0;
                    nowSpeed = 0;
                    if (!this._navigateSpeed) {
                        if (this._interruptRestDistance) {
                            time = Math.max(this._interruptRestDistance / simSpeed * 100, 0);
                        }
                        else {
                            time = Math.max(distance / simSpeed * 100, 0);
                        }
                        nowSpeed = simSpeed;
                    }
                    else {
                        nowSpeed = this._navigateSpeed;
                        if (this._interruptRestDistance) {
                            time = Math.max(this._interruptRestDistance / this._navigateSpeed * 100, 0);
                            orginTime = Math.max(distance / this._navigateSpeed * 100, 0);
                        }
                        else {
                            time = Math.max(distance / this._navigateSpeed * 100, 0);
                        }
                    }
                    t = time;
                    this._progressInter = setInterval(function () {
                        t--;
                        var height = 100 - (t / orginTime) * 100 + '%';
                        var countDownHeight = 94 - (t / orginTime) * 100 + '%';
                        if (document.getElementById('ngr-process') && document.getElementById('ngr-countDown')) {
                            document.getElementById('ngr-process').style.height = height;
                            document.getElementById('ngr-countDown').style.bottom = countDownHeight;
                        }
                        if (_this._isInInterrupt || _this._isNaviSleep) {
                            _this._interruptRestTime = t;
                            if (!_this._navigateSpeed) {
                                _this._interruptRestDistance = nowSpeed * (_this._interruptRestTime) / 100;
                            }
                            else {
                                _this._interruptRestDistance = nowSpeed * (_this._interruptRestTime) / 100;
                            }
                            clearInterval(_this._progressInter);
                        }
                        if (t <= 0) {
                            _this._interruptRestTime = 0;
                            _this._interruptRestDistance = 0;
                            _this._navigateSpeed = 0;
                            _this._isNaviSleep = false;
                            clearInterval(_this._progressInter);
                            _this.destoryCountdownTime();
                        }
                    }, 10);
                    return [2];
                });
            });
        };
        Navigate.prototype.destoryCountdownTime = function () {
            if (!this._naviProgress)
                return;
            if (!this._mapView)
                return;
            var map = this._mapView.getContainer();
            map === null || map === void 0 ? void 0 : map.removeChild(this._naviProgress);
            this._progressInter && clearInterval(this._progressInter);
            delete this._naviProgress;
        };
        Navigate.prototype.addProgress = function () {
            return __awaiter(this, void 0, void 0, function () {
                var map;
                return __generator(this, function (_a) {
                    if (!this._mapView)
                        return [2];
                    this._naviProgress = document.createElement('div');
                    this._naviProgress.setAttribute('id', 'ngr-loading-status');
                    this._naviProgress.innerHTML = "     <div id=\"ngr-process\"></div>\n        <span class=\"ngr-start-loading\"></span>\n        <span class=\"ngr-end-loading\"></span>\n        <span id=\"ngr-countDown\"></span>";
                    map = this._mapView.getContainer();
                    map === null || map === void 0 ? void 0 : map.appendChild(this._naviProgress);
                    return [2];
                });
            });
        };
        Navigate.prototype.getSegments = function () {
            return this._dynamicMng ? this._dynamicMng.getSegments() : [];
        };
        Navigate.prototype.getCurSegment = function () {
            return this._dynamicMng ? this._dynamicMng.getCurSegment() : null;
        };
        Navigate.prototype._fireNavigatingInfo = function (info) {
            this.fire('navigatingInfo', info);
        };
        Navigate.prototype.setMarker = function (name, floorId, coordinate) {
            this._markerMng.setMarker(name, floorId, coordinate);
        };
        Navigate.prototype.hasNaviLine = function () {
            return this._naviMng && this._naviMng.hasNavi();
        };
        Navigate.prototype.getMarker = function (name) {
            return this._markerMng.getMarker(name);
        };
        Navigate.prototype.openAudio = function () {
            this._audioProvider.open();
        };
        Navigate.prototype.closeAudio = function () {
            this._audioProvider.close();
        };
        Navigate.prototype.playMessage = function (msg, bForce) {
            if (bForce === void 0) { bForce = false; }
            this._audioProvider.playMessage(msg, bForce);
        };
        Navigate.prototype.setNavigatingStartFloor = function (floorId) {
            this._startNavigatingFloor = floorId;
        };
        Navigate.prototype.getNavigatingStartFloor = function () {
            return this._startNavigatingFloor;
        };
        Navigate.prototype.setPopStatus = function (status) {
            this._canPop = status;
        };
        Navigate.prototype.setIsPoping = function (status) {
            this._popStatus = status;
        };
        Navigate.prototype.setLocationIsStart = function (status) {
            this._locationIsStart = status;
        };
        Navigate.prototype.IsInNaviMode = function () {
            if (this._status == 'navigating'
                || this._status == 'simulateNavigate'
                || this._status == 'SimulateNaviEnd') {
                return true;
            }
            else {
                return false;
            }
        };
        Navigate.prototype.IsInSimulateMode = function () {
            if (this._status == 'simulateNavigate') {
                return true;
            }
            else {
                return false;
            }
        };
        Navigate.prototype.destroy = function () {
            if (this._mapView) {
                this._mapView.off('gestureStart', this._onMapGestureStart);
                this._mapView.off('gestureEnd', this._onMapGestureEnd);
                this._mapView.off('rotate', this._onMapRotate);
                delete this._mapView;
            }
            if (this._naviMng) {
                this._naviMng.destroy();
                delete this._naviMng;
            }
            if (this._locationMng) {
                this._locationMng.destroy();
                delete this._locationMng;
            }
            this._markerMng.destroy();
            this._audioProvider.destroy();
        };
        return Navigate;
    }(NCore$1));

    var LocationManager = (function (_super) {
        __extends$1(LocationManager, _super);
        function LocationManager(options) {
            var _this = _super.call(this) || this;
            _this._isNavigating = false;
            _this._rotate = 0;
            _this._isShow = true;
            _this._isAutoChangeFloor = true;
            _this._isEnableFlow = false;
            _this._lastIsSimulate = false;
            _this._options = options;
            bindAll([
                '_frameRender',
            ], _this);
            return _this;
        }
        LocationManager.prototype._frameRender = function () {
            this._renderTimer = requestAnimationFrame(this._frameRender);
            if (!this._mapView)
                return;
            var engine = this._mapView.getEngine();
            if (engine) {
                var camera = engine.getCamera();
                camera.set({ rotate: this._rotate });
                this._mapView.fire('rotate');
                this._mapView.fire('move');
                engine.render();
            }
        };
        LocationManager.prototype.enableFlow = function () {
            this._isEnableFlow = true;
            this._enableFlow();
        };
        LocationManager.prototype._enableFlow = function () {
            !this._renderTimer && this._frameRender();
        };
        LocationManager.prototype.disableFlow = function () {
            this._isEnableFlow = false;
            this._disableFlow();
        };
        LocationManager.prototype._disableFlow = function () {
            if (this._renderTimer) {
                cancelAnimationFrame(this._renderTimer);
                delete this._renderTimer;
            }
        };
        LocationManager.prototype.isEnableFlow = function () {
            return this._isEnableFlow;
        };
        LocationManager.prototype.addTo = function (mapView) {
            this._mapView = mapView;
        };
        LocationManager.prototype._createIconDom = function () {
            var _this = this;
            var url = this._isNavigating ? this._options.navigatingImage : this._options.iconImage;
            var size = this._isNavigating ? this._options.navigatingSize : this._options.iconSize;
            var imgDom = new Image();
            imgDom.src = url;
            imgDom.style.width = size[0] + "px";
            imgDom.style.height = size[1] + "px";
            imgDom.addEventListener('error', function () {
                setTimeout(function () {
                    var dom = _this._createIconDom();
                    _this._locationMarker && _this._locationMarker.updateDom(dom);
                }, 1000);
            });
            return imgDom;
        };
        LocationManager.prototype.setPosition = function (floorId, coordinate, duration, bForceAnim) {
            var _this = this;
            if (duration === void 0) { duration = 0; }
            if (bForceAnim === void 0) { bForceAnim = false; }
            if (!this._mapView)
                return;
            if (floorId === '0' || coordinate.x === 0 || coordinate.y === 0)
                return;
            this._mapView.currentFloor;
            this._isAutoChangeFloor && this._mapView.setCurrentFloor(floorId);
            var isFirstSuccess = false;
            if (!this._locationMarker) {
                var imgDom = this._createIconDom();
                this._locationMarker = new Marker(imgDom, {
                    pitchWidthMap: true,
                    rotateWidthMap: true,
                });
                this._mapView && this._locationMarker.addTo(this._mapView);
                isFirstSuccess = true;
            }
            this._mapView.getCenter();
            if (bForceAnim) {
                isFirstSuccess = true;
            }
            this._animator && this._animator.stop();
            var oldPosition = this._locationMarker.getPosition();
            if (oldPosition && oldPosition.floorId === floorId && duration !== 0 && floorId != 'outdoor'
                && oldPosition.coordinate.distanceTo(new Point(coordinate.x, coordinate.y)) <= 200) {
                this._animator = new Animator().ofObject(oldPosition.coordinate, coordinate, duration);
                this._animator.on('update', function (value) {
                    _this._locationMarker && _this._locationMarker.setPosition(floorId, value);
                }).on('complete', function () {
                    delete _this._animator;
                }).start();
            }
            else {
                this._locationMarker.setPosition(floorId, coordinate);
            }
            if (oldPosition
                && (oldPosition.floorId != floorId
                    || oldPosition.coordinate.distanceTo(new Point(coordinate.x, coordinate.y)) > 100)) {
                if (this._animator) {
                    delete this._animator;
                }
                this._locationMarker.setPosition(floorId, coordinate);
                isFirstSuccess = true;
            }
            isFirstSuccess && this.fire('locationSuccess');
            !this._isShow && this._locationMarker.hide();
            this._locationMarker.show();
        };
        LocationManager.prototype.getPosition = function () {
            return this._locationMarker && this._locationMarker.getPosition();
        };
        LocationManager.prototype.removeLayer = function () {
            if (this._locationMarker) {
                this._locationMarker.remove();
                delete this._locationMarker;
            }
        };
        LocationManager.prototype.setAutoChangeFloor = function (isAutoChangeFloor) {
            this._isAutoChangeFloor = isAutoChangeFloor;
        };
        LocationManager.prototype.getAutoChangeFloor = function () {
            return this._isAutoChangeFloor;
        };
        LocationManager.prototype.show = function () {
            if (this._isShow)
                return;
            this._isShow = true;
            this._locationMarker && this._locationMarker.show();
            this._isEnableFlow && this._enableFlow();
        };
        LocationManager.prototype.hide = function () {
            if (!this._isShow)
                return;
            this._isShow = false;
            this._animator && this._animator.stop();
            this._locationMarker && this._locationMarker.hide();
            this._isEnableFlow && this._disableFlow();
        };
        LocationManager.prototype.setRotate = function (rotate) {
            this._rotate = rotate;
            this._locationMarker && this._locationMarker.setRotate(rotate);
        };
        LocationManager.prototype.getRotate = function () {
            return this._rotate;
        };
        LocationManager.prototype.startNavigate = function () {
            this._isNavigating = true;
            var dom = new Image();
            dom.src = this._options.navigatingImage;
            var size = this._options.navigatingSize;
            dom.style.width = size[0] + "px";
            dom.style.height = size[1] + "px";
            this._locationMarker && this._locationMarker.updateDom(dom);
        };
        LocationManager.prototype.endNavigate = function () {
            this._isNavigating = false;
            var dom = new Image();
            dom.src = this._options.iconImage;
            var size = this._options.iconSize;
            dom.style.width = size[0] + "px";
            dom.style.height = size[1] + "px";
            this._locationMarker && this._locationMarker.updateDom(dom);
        };
        LocationManager.prototype.hasPosition = function () {
            return Boolean(this._locationMarker);
        };
        LocationManager.prototype.destroy = function () {
            this.removeLayer();
            delete this._mapView;
        };
        return LocationManager;
    }(NCore$1));

    var defaultOptions = {
        isFillet: false,
        filletNumber: 4,
        filletDistance: 3,
        multilineOpacity: 0.8,
        defaultFloorGap: 2,
        recommendRouteType: 'escalator',
    };
    var NewNaviManager = (function () {
        function NewNaviManager(mapView, options) {
            this._routesArray = [];
            this._isShowMultiline = true;
            this._floorOrder = [];
            this._forcedStrategies = [];
            this._isForcedStrategiesAllFloor = false;
            this._routesCache = new Map();
            this._routesEmptyCache = [];
            this._client = new NaviHttpClient();
            this._mapView = mapView;
            this._options = __assign$1(__assign$1({}, defaultOptions), options);
            bindAll([
                '_onChangeFloor',
                '_onChangeViewType',
            ], this);
            this._mapView.on('changeFloor', this._onChangeFloor);
            this._mapView.on('changeViewType', this._onChangeViewType);
            if (this._options.offline) {
                this._roadCalc = new RoadCalculate(this._mapView, {
                    bdId: this._mapView.getBdId(),
                });
            }
            if (this._options.grayImage) {
                this._grayLayer = new LineLayer({
                    lineImage: this._options.grayImage,
                    lineWidth: this._options.lineWidth,
                    base: this._options.lineHeight,
                });
                this._grayLayer.SetGray(true);
                this._grayLayer.setSync(false);
            }
        }
        NewNaviManager.prototype._onChangeViewType = function () {
            if (this._mapView.getViewType() === 'single') {
                this._removeConnectionLayers();
            }
            else {
                this._addConnectionLayers();
                this.hasNavi() && this._mapView.highlightFloor(this._floorOrder);
            }
            this._removeLineLayers();
            this._addLineLayers(this._mapView.currentFloor);
            this._removeMultiLineLayers();
            if (this._isShowMultiline) {
                this._addMultiLineLayers(this._mapView.currentFloor);
            }
        };
        NewNaviManager.prototype.getFloorOrder = function () {
            return this._floorOrder;
        };
        NewNaviManager.prototype._onChangeFloor = function (floorId) {
            if (!this._activeRoute || this._mapView.getViewType() === 'multiple')
                return;
            this._removeLineLayers();
            this._addLineLayers(floorId);
            this._removeMultiLineLayers();
            if (this._isShowMultiline) {
                this._addMultiLineLayers(floorId);
            }
        };
        NewNaviManager.prototype.getNaviBounds = function (mode) {
            if (mode === void 0) { mode = false; }
            if (mode && !this._outdoorRoute)
                return;
            if (!mode && !this._activeRoute)
                return;
            var features = mode ? this._outdoorRoute : this._activeRoute;
            var minX, minY, maxX, maxY;
            for (var i = 0; i < features.length; i += 1) {
                var _a = features[i], coordinates = _a.geometry.coordinates, properties = _a.properties;
                if (properties.floor === this._mapView.currentFloor) {
                    for (var j = 0; j < coordinates.length; j += 1) {
                        var _b = coordinates[j], x = _b[0], y = _b[1];
                        minX = minX ? (x < minX ? x : minX) : x;
                        minY = minY ? (y < minY ? y : minY) : y;
                        maxX = maxX ? (x > maxX ? x : maxX) : x;
                        maxY = maxY ? (y > maxY ? y : maxY) : y;
                    }
                }
            }
            if (minX && minY && maxX && maxY) {
                var bounds = {
                    topLeft: { x: minX, y: maxY },
                    bottomRight: { x: maxX, y: minY },
                };
                return bounds;
            }
        };
        NewNaviManager.prototype.renderNaviByJson = function (json, startPosition, endPosition) {
            var jsonObj = json;
            if (typeof json === 'string') {
                jsonObj = JSON.parse(json);
            }
            this._routesArray = jsonObj;
            startPosition.floorId; startPosition.coordinate;
            endPosition.floorId; endPosition.coordinate;
            var _a = this._options; _a.server; var strategies = _a.strategies; _a.isFillet; _a.filletDistance; _a.filletNumber;
            this._activeRouteType ? [this._activeRouteType] : strategies;
            LogMgr$1.log('NewNaviManager.ts renderNavi 185 ' + this._routesArray);
            this.setActiveRoute(this._routesArray[0].strategy);
        };
        NewNaviManager.prototype.renderNavi = function (startPosition, endPosition) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._routesCache.clear();
                            this._routesEmptyCache.length = 0;
                            this._startPosition = startPosition;
                            this._endPosition = endPosition;
                            return [4, this._renderNavi(startPosition, endPosition)];
                        case 1:
                            _a.sent();
                            return [2];
                    }
                });
            });
        };
        NewNaviManager.prototype._renderNavi = function (startPosition, endPosition) {
            return __awaiter(this, void 0, void 0, function () {
                var startFloor, startCoord, endFloor, endCoord, _a, server, isFillet, filletDistance, filletNumber, strates, serverStatus, tip, data, res;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (startPosition == null || startPosition == undefined
                                || endPosition == null || endPosition == undefined) {
                                return [2];
                            }
                            startFloor = startPosition.floorId, startCoord = startPosition.coordinate;
                            endFloor = endPosition.floorId, endCoord = endPosition.coordinate;
                            _a = this._options, server = _a.server, isFillet = _a.isFillet, filletDistance = _a.filletDistance, filletNumber = _a.filletNumber;
                            strates = this._activeRouteType ? [this._activeRouteType] : [this._options.defaultStrategy];
                            if (this._forcedStrategies.length > 0) {
                                if (startFloor === endFloor && !this._isForcedStrategiesAllFloor) {
                                    strates = ['shortest'];
                                }
                                else {
                                    strates = this._forcedStrategies;
                                }
                            }
                            serverStatus = 200;
                            tip = '';
                            if (!(this._roadCalc && this._roadCalc.loaded())) return [3, 2];
                            return [4, this._roadCalc.calculate(startPosition, endPosition, strates)];
                        case 1:
                            data = _b.sent();
                            return [3, 4];
                        case 2:
                            this._client.cancel();
                            startFloor = this.ReNameFloorId(startFloor);
                            endFloor = this.ReNameFloorId(endFloor);
                            return [4, this._client.post(server, {
                                    json: {
                                        from_floor: startFloor,
                                        from_x: startCoord.x,
                                        from_y: startCoord.y,
                                        to_floor: endFloor,
                                        to_x: endCoord.x,
                                        to_y: endCoord.y,
                                        strategies: strates,
                                        isFillet: isFillet,
                                        filletDistance: filletDistance,
                                        filletNumber: filletNumber,
                                        limitLength: this._options.startLimitLength,
                                    },
                                    timeout: 5000,
                                })];
                        case 3:
                            res = _b.sent();
                            serverStatus = res.serverStatus;
                            tip = res.txtTip;
                            if (res.data && res.data.data) {
                                data = res.data.data;
                            }
                            _b.label = 4;
                        case 4:
                            if (serverStatus != 200) {
                                this._routesArray.length = 0;
                                this._routesEmptyCache.push(strates[0]);
                                this._removeLineLayers();
                                this._removeMultiLineLayers();
                                this._floorOrder.length = 0;
                                throw new Error(tip);
                            }
                            else if (!data || data.length === 0) {
                                this._routesArray.length = 0;
                                this._routesEmptyCache.push(strates[0]);
                                this._removeLineLayers();
                                this._removeMultiLineLayers();
                                this._floorOrder.length = 0;
                                throw new Error(tip);
                            }
                            this._routesCache.set(strates[0], data[0]);
                            this._routesArray = data;
                            this.renderNaviByJson(data, startPosition, endPosition);
                            this.setActiveRoute(this._routesArray[0].strategy);
                            return [2];
                    }
                });
            });
        };
        NewNaviManager.prototype.ReNameFloorId = function (floorId) {
            if (floorId == null || floorId == undefined) {
                return '';
            }
            var floor = floorId.substr(6, 3);
            if (floor == 'F00') {
                floor = 'F01';
            }
            var result = floorId.substr(0, 6);
            return result + floor;
        };
        NewNaviManager.prototype.setForcedStrategies = function (strategies, isForced) {
            this._forcedStrategies = strategies;
            if (isForced !== undefined) {
                this._isForcedStrategiesAllFloor = isForced;
            }
        };
        NewNaviManager.prototype.clearForcedStrategies = function () {
            this._forcedStrategies = [];
        };
        NewNaviManager.prototype.resetStartEnd = function (startPosition, endPosition) {
            this._routesCache.clear();
            this._routesEmptyCache.length = 0;
            this._startPosition = startPosition;
            this._endPosition = endPosition;
        };
        NewNaviManager.prototype._lngLatToMercator = function (_a, isArray) {
            var lng = _a[0], lat = _a[1];
            if (isArray === void 0) { isArray = false; }
            var x = Number(lng) * 20037508.34 / 180;
            var y = Math.log(Math.tan((90 + Number(lat)) * Math.PI / 360)) / (Math.PI / 180);
            y = y * 20037508.34 / 180;
            return isArray ? [x, y] : { x: x, y: y };
        };
        NewNaviManager.prototype.renderOutDoorNavi = function (origin, destination, floorId) {
            if (floorId === void 0) { floorId = this._mapView.currentFloor; }
            return __awaiter(this, void 0, void 0, function () {
                var result, polyline, distance, duration, steps, diff, total, stepLength, removeStep, pathIndex, lastStep, features, i, data;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, fetchJsonp("https://apis.map.qq.com/ws/direction/v1/driving?output=jsonp&from=" + origin.join(',') + "&to=" + destination.join(',') + "&key=DVRBZ-RTPKP-KBKDH-VHFG3-TDOH6-ZYFAX")
                                .then(function (response) {
                                return response.json();
                            })];
                        case 1:
                            result = _a.sent();
                            if (result.status !== 0)
                                throw new Error('renderOutDoorNavi: 瑙勫垝瀹ゅ璺嚎澶辫触锛�');
                            polyline = result.result.routes[0].polyline, distance = result.result.routes[0].distance, duration = result.result.routes[0].duration, steps = [
                                this._lngLatToMercator([polyline[1], polyline[0]]),
                            ], diff = 0, total = 5000, stepLength = 0, removeStep = 0, pathIndex = 0, lastStep = [], features = [];
                            for (i = 2; i < polyline.length; i += 2) {
                                polyline[i] = Number(Number(polyline[i - 2] + polyline[i] / 1000000).toFixed(6));
                                polyline[i + 1] = Number(Number(polyline[i - 1] + polyline[i + 1] / 1000000).toFixed(6));
                                steps.push(this._lngLatToMercator([polyline[i + 1], polyline[i]], true));
                            }
                            diff = steps.length - total;
                            stepLength = steps.length;
                            lastStep = steps.pop();
                            if (steps.length > total) {
                                if (diff > 0) {
                                    if (2 * diff < steps.length) {
                                        removeStep = Math.floor(stepLength / (diff + 1));
                                        while (diff > 0 && pathIndex < steps.length) {
                                            pathIndex += removeStep;
                                            steps.splice(pathIndex, 1);
                                            --pathIndex;
                                            --diff;
                                        }
                                    }
                                    else {
                                        removeStep = Math.floor(stepLength / (stepLength - diff - 1));
                                        while (diff > 0 && pathIndex + removeStep + 1 < steps.length) {
                                            steps.splice(pathIndex, removeStep);
                                            ++pathIndex;
                                            diff -= removeStep;
                                        }
                                    }
                                }
                            }
                            steps.push(lastStep);
                            steps.reduce(function (preStep, curStep, index) {
                                if (!index)
                                    return curStep;
                                features.push({
                                    direction: 1,
                                    featureId: 'outdoor-outdoor-' + index,
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: [preStep, curStep]
                                    },
                                    properties: {
                                        altitude: 1,
                                        belong: 'outdoor',
                                        category: null,
                                        endIndex: null,
                                        escalator: null,
                                        filletFlag: null,
                                        floor: floorId,
                                        floorAddress: 'F1',
                                        hasTransitPoint: false,
                                        name: '瀹ゅ',
                                        pathType: null,
                                        startIndex: null,
                                    },
                                    type: null,
                                });
                                return curStep;
                            });
                            data = {
                                route: {
                                    features: features,
                                    type: 'FeatureCollection'
                                },
                                strategy: 'shortest'
                            };
                            this._routesArray = [data];
                            this.setOutDoorActiveRoute(this._routesArray[0].strategy);
                            return [2, { distance: Number(distance), duration: Number(duration) }];
                    }
                });
            });
        };
        NewNaviManager.prototype.GetRouteArrayData = function () {
            return this._routesArray;
        };
        NewNaviManager.prototype.setOutDoorActiveRoute = function (routeType) {
            var res = this._routesArray.find(function (item) { return item.strategy === routeType; });
            if (!res) {
                console.error(routeType + " is not exit");
                return;
            }
            this._activeRouteType = routeType;
            this._outdoorRoute = res.route.features;
            var features = this._outdoorRoute;
            var floorId = features[0].properties.floor;
            this._addOutdoorLineLayers(floorId);
            var engine = this._mapView.getEngine();
            engine && engine.render();
        };
        NewNaviManager.prototype._addOutdoorLineLayers = function (floorId) {
            if (!this._outdoorRoute)
                return;
            var features = this._outdoorRoute;
            if (!this._outLineLayers) {
                this._outLineLayers = [];
            }
            if (this._mapView.getViewType() === 'multiple') {
                for (var i = 0; i < this._floorOrder.length; i += 1) {
                    var filterFeatures = NewNaviManager.processFeatures(features, this._floorOrder[i]);
                    if (filterFeatures.length !== 0) {
                        var lineLayer = this._createLineLayer(this._floorOrder[i], filterFeatures, 1);
                        this._outLineLayers.push(lineLayer);
                    }
                }
            }
            else {
                var filterFeatures = NewNaviManager.processFeatures(features, floorId);
                if (filterFeatures.length === 0)
                    return;
                var lineLayer = this._createLineLayer(floorId, filterFeatures, 1);
                this._outLineLayers.push(lineLayer);
            }
            this._mapView.addLayers(this._outLineLayers);
        };
        NewNaviManager.prototype.setActiveRoute = function (routeType) {
            return __awaiter(this, void 0, void 0, function () {
                var res, res, features, map, i, floorId, engine;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._activeRouteType = routeType;
                            if (!(this._routesCache && this._routesCache.has(routeType))) return [3, 1];
                            res = this._routesCache.get(routeType);
                            this._activeRoute = res && res.route.features;
                            return [3, 4];
                        case 1:
                            if (!(this._routesEmptyCache.indexOf(routeType) !== -1)) return [3, 2];
                            this._removeLineLayers();
                            this._removeMultiLineLayers();
                            this._floorOrder.length = 0;
                            throw new Error('renderNavi: 鏃犳绛栫暐璺嚎锛�');
                        case 2: return [4, this._renderNavi(this._startPosition, this._endPosition)];
                        case 3:
                            _a.sent();
                            res = this._routesArray.find(function (item) { return item.strategy === _this._activeRouteType; });
                            if (!res) {
                                console.error(routeType + " is not exit");
                                return [2];
                            }
                            this._routesCache.set(routeType, res);
                            this._activeRoute = res.route.features;
                            _a.label = 4;
                        case 4:
                            this._floorOrder.length = 0;
                            if (!this._activeRoute) {
                                console.error('no active route');
                                return [2];
                            }
                            features = this._activeRoute;
                            map = new Map();
                            for (i = 0; i < features.length; i += 1) {
                                if (!map.get(features[i].properties.floor)) {
                                    this._floorOrder.push(features[i].properties.floor);
                                    map.set(features[i].properties.floor, true);
                                }
                            }
                            floorId = this._mapView.currentFloor;
                            this._removeLineLayers();
                            this._addLineLayers(floorId);
                            this._removeMultiLineLayers();
                            this._addMultiLineLayers(floorId);
                            if (this._mapView.getViewType() === 'multiple') {
                                this._removeConnectionLayers();
                                this._addConnectionLayers();
                                this._mapView.highlightFloor(this._floorOrder);
                            }
                            engine = this._mapView.getEngine();
                            engine && engine.render();
                            return [2];
                    }
                });
            });
        };
        NewNaviManager.prototype.getLinesByFloor = function (floorId) {
            if (!this._activeRoute)
                return [];
            var result = [];
            var features = this._activeRoute;
            for (var i = 0; i < features.length; i += 1) {
                var _a = features[i], coordinates = _a.geometry.coordinates, properties = _a.properties;
                if (properties.floor === floorId) {
                    var start = coordinates[0], end = coordinates[1];
                    result.push([
                        new Point(start[0], start[1]),
                        new Point(end[0], end[1]),
                    ]);
                }
            }
            return result;
        };
        NewNaviManager.prototype.getRoutes = function () {
            if (!this._activeRoute)
                return [];
            var features = this._activeRoute;
            var result = [];
            for (var i = 0; i < features.length; i += 1) {
                var _a = features[i], _b = _a.geometry.coordinates, start = _b[0], end = _b[1], properties = _a.properties;
                result.push({
                    line: [
                        new Point(start[0], start[1]),
                        new Point(end[0], end[1]),
                    ],
                    floor: properties.floor,
                });
            }
            return result;
        };
        NewNaviManager.prototype.setWalked = function (floorId, coordinate, index) {
            if (this._mapView.getViewType() === 'multiple') {
                console.error('setWalked: multiple is not support');
                return;
            }
            var lineLayer = this._lineLayers && this._lineLayers[0];
            if (!this._activeRoute || !lineLayer)
                return;
            var features = this._activeRoute;
            if (index < 0 || index >= features.length)
                return;
            var filterFeatures = features.slice(index + 1);
            var coordinates = features[index].geometry.coordinates;
            filterFeatures.unshift({
                type: 'Feature',
                properties: features[index].properties,
                geometry: {
                    type: 'LineString',
                    coordinates: [
                        [coordinate.x, coordinate.y],
                        coordinates[1]
                    ],
                },
            });
            var resultFeatures = NewNaviManager.processFeatures(filterFeatures, floorId);
            if (resultFeatures.length !== 0) {
                lineLayer.setFeatures(resultFeatures);
                lineLayer.setFloorId(floorId);
                this._mapView.updateLayer(lineLayer);
                this.renderShortest(coordinate, resultFeatures, floorId);
            }
        };
        NewNaviManager.prototype.setAllWalked = function () {
            this._removeLineLayers();
        };
        NewNaviManager.prototype.getActiveRoute = function () {
            return this._activeRoute;
        };
        NewNaviManager.prototype._getFloorStop = function (startFloor, endFloor, order) {
            if (startFloor === endFloor)
                return [];
            var floors = Array.from(this._mapView.getFloors());
            order < 0 && floors.reverse();
            var result = [startFloor];
            var isStart = false;
            for (var i = 0; i < floors.length; i += 1) {
                if (floors[i].flId === endFloor) {
                    break;
                }
                if (isStart) {
                    result.push(floors[i].flId);
                }
                if (floors[i].flId === startFloor) {
                    isStart = true;
                }
            }
            return result;
        };
        NewNaviManager.prototype._addConnectionLayers = function () {
            if (!this._activeRoute)
                return;
            if (!this._connectionLayers) {
                this._connectionLayers = [];
            }
            var features = this._activeRoute;
            if (features.length === 0)
                return;
            var curFloor = features[0].properties.floor;
            for (var i = 1; i < features.length; i += 1) {
                if (features[i].properties.floor !== curFloor) {
                    var curNum = this._mapView.getFloorHeight(curFloor);
                    var targetNum = this._mapView.getFloorHeight(features[i].properties.floor);
                    var start = features[i - 1].geometry.coordinates[1];
                    var end = features[i].geometry.coordinates[0];
                    var floorStop = this._getFloorStop(curFloor, features[i].properties.floor, targetNum - curNum);
                    var allHeight = 0;
                    for (var j = 0; j < floorStop.length; j += 1) {
                        var itemStart = this._mapView.getFloorHeight(floorStop[j]);
                        var itemTarget = this._mapView.getFloorHeight(floorStop[j + 1] || features[i].properties.floor);
                        var diff = itemTarget - itemStart;
                        var feature = {
                            type: 'Feature',
                            geometry: {
                                type: 'LineString',
                                coordinates: [
                                    [start[0], start[1], 0],
                                    [end[0], end[1], diff]
                                ],
                            },
                            properties: {},
                        };
                        var layer = this._createConnectionLayer(floorStop[j], [feature]);
                        this._connectionLayers.push(layer);
                        allHeight += Math.abs(diff);
                    }
                    var midHeight = allHeight * 0.5;
                    if (this._mapView && floorStop.length > 0) {
                        this._mapView.getFloorHeight(floorStop[0]);
                        var domCont = document.createElement('div');
                        domCont.classList.add('marker');
                        this._mapView.getCenter();
                        var marker = new LiftMarker(domCont, {
                            draggable: false,
                        });
                        marker.addTo(this._mapView);
                        marker.setPosition2(new Point3(start[0], start[1], midHeight));
                        marker.setIconUrl('./assets/icon/lift_1.png');
                    }
                    curFloor = features[i].properties.floor;
                }
            }
            this._mapView.addLayers(this._connectionLayers);
        };
        NewNaviManager.prototype._createConnectionLayer = function (floorId, features) {
            var layer = new ConnectionLayer({
                width: this._options.lineWidth,
                icon: this._options.lineImage,
                base: this._options.lineHeight,
            });
            layer.setFloorId(floorId);
            layer.setFeatures(features);
            layer.setIgnoreMultiFade(true);
            return layer;
        };
        NewNaviManager.prototype._createLineLayer = function (floorId, features, opacity) {
            var lineLayer = new LineLayer({
                lineWidth: this._options.lineWidth,
                lineImage: this._options.lineImage,
                opacity: opacity,
                base: this._options.lineHeight,
            });
            lineLayer.setSync(false);
            lineLayer.setFloorId(floorId);
            lineLayer.setFeatures(features);
            lineLayer.setIgnoreMultiFade(true);
            return lineLayer;
        };
        NewNaviManager.prototype._addLineLayers = function (floorId) {
            if (!this._activeRoute)
                return;
            var features = this._activeRoute;
            if (!this._lineLayers) {
                this._lineLayers = [];
            }
            if (this._mapView.getViewType() === 'multiple') {
                for (var i = 0; i < this._floorOrder.length; i += 1) {
                    var filterFeatures = NewNaviManager.processFeatures(features, this._floorOrder[i]);
                    var start = filterFeatures[0].geometry.coordinates[0];
                    this.renderShortest({ x: start[0], y: start[1] }, filterFeatures, floorId);
                    if (filterFeatures.length !== 0) {
                        var lineLayer = this._createLineLayer(this._floorOrder[i], filterFeatures, 1);
                        this._lineLayers.push(lineLayer);
                    }
                }
            }
            else {
                var filterFeatures = NewNaviManager.processFeatures(features, floorId);
                if (filterFeatures.length === 0)
                    return;
                var start = filterFeatures[0].geometry.coordinates[0];
                this.renderShortest({ x: start[0], y: start[1] }, filterFeatures, floorId);
                var lineLayer = this._createLineLayer(floorId, filterFeatures, 1);
                this._lineLayers.push(lineLayer);
                if (this._grayLayer) {
                    this._grayLayer.setFeatures(filterFeatures);
                    this._grayLayer.setFloorId(floorId);
                    this._mapView.updateLayer(this._grayLayer);
                }
            }
            this._mapView.addLayers(this._lineLayers);
        };
        NewNaviManager.prototype._removeShortestLayers = function () {
            if (this._shortestLine) {
                this._mapView.removeLayer(this._shortestLine);
                delete this._shortestLine;
            }
        };
        NewNaviManager.prototype._addMultiLineLayers = function (floorId) {
            if (this._routesArray.length < 2)
                return;
            if (!this._multilineLayers) {
                this._multilineLayers = [];
            }
            if (this._mapView.getViewType() === 'multiple') {
                for (var i = 0; i < this._floorOrder.length; i += 1) {
                    var features = this._getOtherFeatures(this._floorOrder[i]);
                    if (features.length !== 0) {
                        var lineLayer = this._createLineLayer(this._floorOrder[i], features, this._options.multilineOpacity);
                        this._multilineLayers.push(lineLayer);
                    }
                }
            }
            else {
                var features = this._getOtherFeatures(floorId);
                if (features.length === 0)
                    return;
                var lineLayer = this._createLineLayer(floorId, features, this._options.multilineOpacity);
                this._multilineLayers.push(lineLayer);
            }
            this._mapView.addLayers(this._multilineLayers);
        };
        NewNaviManager.prototype._getOtherFeatures = function (floorId) {
            var resultFeatures = [];
            for (var i = 0; i < this._routesArray.length; i += 1) {
                if (this._routesArray[i].strategy !== this._activeRouteType) {
                    var features = this._routesArray[i].route.features;
                    resultFeatures = resultFeatures.concat(NewNaviManager.processFeatures(features, floorId));
                }
            }
            return resultFeatures;
        };
        NewNaviManager.prototype.getRestLines = function (floorId) {
            if (!this._lineLayers || this._lineLayers.length === 0
                || this._lineLayers[0].getFloorId() !== floorId)
                return [];
            var features = this._lineLayers[0].getFeatures();
            if (features.length === 0)
                return [];
            var geometry = features[0].geometry;
            if (geometry.type === 'LineString') {
                return geometry.coordinates;
            }
            else if (geometry.type === 'MultiLineString') {
                return geometry.coordinates[0];
            }
            return [];
        };
        NewNaviManager.prototype.getActiveRouteType = function () {
            return this._activeRouteType;
        };
        NewNaviManager.prototype.getRecommendRouteType = function () {
            return this._recommendRouteType;
        };
        NewNaviManager.prototype.getAllRouteType = function () {
            var result = [];
            for (var i = 0; i < this._routesArray.length; i += 1) {
                result.push(this._routesArray[i].strategy);
            }
            return result;
        };
        NewNaviManager.prototype.setIsShowMultiline = function (isShow) {
            this._isShowMultiline = isShow;
            if (this._mapView.currentFloor) {
                this._removeLineLayers();
                this._removeGrayLayer();
                this._addLineLayers(this._mapView.currentFloor);
                this._removeMultiLineLayers();
                if (this._isShowMultiline) {
                    this._addMultiLineLayers(this._mapView.currentFloor);
                }
            }
        };
        NewNaviManager.prototype.hasNavi = function () {
            return Boolean(this._lineLayers);
        };
        NewNaviManager.prototype._removeLineLayers = function () {
            if (this._lineLayers) {
                this._mapView.removeLayers(this._lineLayers);
                delete this._lineLayers;
            }
        };
        NewNaviManager.prototype.removeLineLayers = function () {
            if (this._lineLayers) {
                this._mapView.removeLayers(this._lineLayers);
                delete this._lineLayers;
            }
        };
        NewNaviManager.prototype.removeOutDoorLineLayers = function () {
            if (this._outLineLayers) {
                this._mapView.removeLayers(this._outLineLayers);
                delete this._outLineLayers;
            }
        };
        NewNaviManager.prototype._removeGrayLayer = function () {
            this._grayLayer && this._mapView.removeLayer(this._grayLayer);
        };
        NewNaviManager.prototype._removeMultiLineLayers = function () {
            if (this._multilineLayers) {
                this._mapView.removeLayers(this._multilineLayers);
                delete this._multilineLayers;
            }
        };
        NewNaviManager.prototype._removeConnectionLayers = function () {
            if (this._connectionLayers) {
                this._mapView.removeLayers(this._connectionLayers);
                delete this._connectionLayers;
            }
        };
        NewNaviManager.prototype.removeLayer = function () {
            this._removeGrayLayer();
            this._removeLineLayers();
            this.removeOutDoorLineLayers();
            this._removeMultiLineLayers();
            this._removeConnectionLayers();
            this._removeShortestLayers();
            this._routesArray.length = 0;
            this._routesCache.clear();
            this._floorOrder.length = 0;
            delete this._activeRouteType;
            delete this._activeRoute;
            delete this._startPosition;
            delete this._endPosition;
        };
        NewNaviManager.prototype.resetActiveRouteType = function () {
            delete this._activeRouteType;
        };
        NewNaviManager.prototype.destroy = function () {
            this._mapView.off('changeFloor', this._onChangeFloor);
            this._mapView.off('changeViewType', this._onChangeViewType);
        };
        NewNaviManager.processFeatures = function (features, floorId) {
            var result = [];
            var isNeedPushNew = true;
            for (var i = 0; i < features.length; i += 1) {
                var properties = features[i].properties;
                if (properties.floor === floorId) {
                    var _a = features[i].geometry.coordinates, start = _a[0], end = _a[1];
                    if (isNeedPushNew) {
                        isNeedPushNew = false;
                        result.push({
                            type: 'Feature',
                            properties: features[i].properties,
                            geometry: {
                                type: 'LineString',
                                coordinates: [],
                            }
                        });
                    }
                    var lastCoordinates = result[result.length - 1].geometry.coordinates;
                    lastCoordinates.push(start);
                    if (features[i + 1]) {
                        var nextFloor = features[i + 1].properties.floor;
                        var nextStart = features[i + 1].geometry.coordinates[0];
                        var isEqual = NewNaviManager.isCoordinateEqual(end, nextStart);
                        if (!isEqual || nextFloor !== floorId) {
                            lastCoordinates.push(end);
                        }
                    }
                    else {
                        lastCoordinates.push(end);
                    }
                }
                else {
                    isNeedPushNew = true;
                }
            }
            return result;
        };
        NewNaviManager.prototype.renderShortest = function (startPoint, features, floorId) {
            if (!this._options.showShortest)
                return;
            if (features.length == 0) {
                return;
            }
            var coordinateLength = features[0].geometry.coordinates.length;
            var shortestLineEnd = features[0].geometry.coordinates[coordinateLength - 1];
            var curdCoordinates = [[startPoint.x, startPoint.y], [shortestLineEnd[0], shortestLineEnd[1]]];
            var shortestFeature = [{
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'LineString',
                        coordinates: curdCoordinates
                    }
                }];
            if (!this._shortestLine) {
                this._shortestLine = new LineLayer(this._options.shortestLineConfig || {});
                this._shortestLine.setFloorId(floorId);
                this._shortestLine.setFeatures(shortestFeature);
                this._mapView.addLayer(this._shortestLine);
            }
            else {
                this._shortestLine.setFloorId(floorId);
                this._shortestLine.setFeatures(shortestFeature);
                var engine = this._mapView.getEngine();
                if (this._mapView.hasLayer(this._shortestLine) == false) {
                    this._mapView.addLayer(this._shortestLine);
                }
                if (engine && engine.hasLayer(this._shortestLine) == false) {
                    engine.addLayer(this._shortestLine);
                }
            }
        };
        NewNaviManager.isCoordinateEqual = function (arr1, arr2) {
            return arr1[0] === arr2[0] && arr1[1] === arr2[1];
        };
        return NewNaviManager;
    }());

    var NaviEvent = (function () {
        function NaviEvent() {
        }
        return NaviEvent;
    }());
    var NaviEventMgr = (function () {
        function NaviEventMgr() {
            this.m_eventQueue = [];
        }
        NaviEventMgr.GetInstance = function () {
            if (NaviEventMgr.m_instance == null) {
                NaviEventMgr.m_instance = new NaviEventMgr();
            }
            return NaviEventMgr.m_instance;
        };
        NaviEventMgr.prototype.PostMsg = function (eventName, eventData) {
            var naviEvent = new NaviEvent();
            naviEvent.m_eventName = eventName;
            naviEvent.m_eventData = eventData;
            this.m_eventQueue.push(naviEvent);
        };
        NaviEventMgr.prototype.PopMsg = function () {
            if (this.m_eventQueue.length == 0) {
                return null;
            }
            var naviEvent = this.m_eventQueue.pop();
            return naviEvent;
        };
        NaviEventMgr.m_instance = null;
        return NaviEventMgr;
    }());

    var elevator = new Set([25136, 25011]);
    var escalator = new Set([25135, 25012]);
    var stairs = new Set([21004, 25134, 25014]);
    var ramp = new Set([25137, 25138, 25147]);
    function getFacility(category) {
        var text = '';
        var facility = '';
        if (elevator.has(category)) {
            text = language.get('elevatorTip');
            facility = 'elevator';
        }
        else if (escalator.has(category)) {
            text = language.get('escalatorTip');
            facility = 'escalator';
        }
        else if (stairs.has(category)) {
            text = language.get('stairsTip');
            facility = 'stairs';
        }
        else if (ramp.has(category)) {
            text = language.get('rampTip');
            facility = 'ramp';
        }
        return { text: text, facility: facility };
    }
    function getDirection(baseAngle) {
        var direction = 'straight';
        var angle = baseAngle;
        if (baseAngle >= 180) {
            angle -= 360;
        }
        else if (angle <= -180) {
            angle += 360;
        }
        if (-180 <= angle && angle <= -120) {
            direction = 'leftRear';
        }
        else if (-120 < angle && angle <= -60) {
            direction = 'left';
        }
        else if (-60 < angle && angle <= -5) {
            direction = 'leftFront';
        }
        else if (-5 < angle && angle <= 5) {
            direction = 'straight';
        }
        else if (5 < angle && angle <= 60) {
            direction = 'rightFront';
        }
        else if (60 < angle && angle <= 120) {
            direction = 'right';
        }
        else if (120 < angle && angle <= 180) {
            direction = 'rightRear';
        }
        return direction;
    }

    var Segment = (function () {
        function Segment(line, properties) {
            this._isBezier = false;
            this._angle = 0;
            this._isTipMovePhone = false;
            this.m_bias = 0;
            this.m_routeTrustness = 0;
            this.m_index = 0;
            this._line = new Line(line[0], line[1]);
            this._properties = properties;
            this._distance = this._line.getLength();
            var vector0 = new Vector2([0, 1]);
            var vector1 = new Vector2(line[0], line[1]);
            this._rotate = vector0.angleTo(vector1);
            if (properties.isBezier == null || properties.isBezier == undefined) {
                this._isBezier = false;
            }
            else {
                this._isBezier = properties.isBezier;
            }
            if (properties.angle == null || properties.angle == undefined) {
                this._angle = 0;
            }
            else {
                this._angle = properties.angle;
            }
        }
        Segment.prototype.isFacility = function () {
            return Boolean(this._facility);
        };
        Segment.prototype.getNextSegment = function () {
            return this._nextSegment;
        };
        Segment.prototype.getStart = function () {
            return this._line.getStart();
        };
        Segment.prototype.getEnd = function () {
            return this._line.getEnd();
        };
        Segment.prototype.getClosest = function (coordinate) {
            return this._line.getClosest(coordinate);
        };
        Segment.prototype.setNextSegment = function (nextSegment) {
            this._nextSegment = nextSegment;
            if (this.floor === this._nextSegment.floor) {
                if (this._isBezier) {
                    this._direction = getDirection(this._angle);
                }
                else {
                    this._direction = getDirection(nextSegment._rotate - this._rotate);
                }
            }
            else {
                var nextAltitude = nextSegment._properties.altitude;
                var altitude = this._properties.altitude;
                this._direction = nextAltitude > altitude ? 'top' : 'bottom';
                var _a = nextSegment._properties, category = _a.category, escalator = _a.escalator;
                var _b = getFacility(Number(category)), text = _b.text, facility = _b.facility;
                this._facility = facility;
                this._facilityTipText = text;
                this._facilityId = escalator;
            }
        };
        Segment.prototype.setLastSegment = function (lastSegment) {
            this._lastSegment = lastSegment;
        };
        Segment.prototype.getRestDistance = function (coordinate) {
            if (!coordinate)
                return this._distance;
            return coordinate.distanceTo(this._line.getEnd());
        };
        Segment.prototype._getOutBuildingText = function () {
            if (!this._lastSegment)
                return '';
            var lastBelong = this._lastSegment._properties.belong;
            var nowBelong = this._properties.belong;
            if (nowBelong === 'outdoor' && lastBelong && lastBelong !== 'outdoor') {
                var message = language.getType() === 'cn' ? "\u60A8\u5DF2\u79BB\u5F00" + lastBelong + "\uFF0C" : "You have to leave " + lastBelong;
                return message;
            }
        };
        Segment.prototype._getInBuildingText = function () {
            if (!this._nextSegment)
                return '';
            var nextBelong = this._nextSegment._properties.belong;
            var nowBelong = this._properties.belong;
            if (nextBelong && nowBelong && nextBelong != nowBelong) {
                if (nextBelong == 'outdoor') {
                    nextBelong = '瀹ゅ';
                }
                var message = language.getType() === 'cn' ? "\u60A8\u5373\u5C06\u8FDB\u5165" + nextBelong + "\uFF0C" : "You are about to enter " + nextBelong;
                return message;
            }
        };
        Segment.prototype._getRampBuilding = function () {
            if (this._facility !== 'ramp')
                return '';
            if (!this._nextSegment)
                return '';
            var nextBelong = this._nextSegment._properties.belong;
            var nowBelong = this._properties.belong;
            if (nextBelong && nextBelong !== 'outdoor' && nowBelong && nowBelong !== nextBelong) {
                return nextBelong;
            }
            return '';
        };
        Segment.prototype.GetFloorIdVoiceStringByFloorId = function (floorId) {
            if (floorId == null || floorId == undefined) {
                return '';
            }
            var strName = floorId.charAt(6);
            var tenName = floorId.charAt(7);
            var lastName = floorId.charAt(8);
            var result = '';
            LogMgr$1.log('GetFloorIdVoiceStringByFloorId 1 '
                + ' strName:' + strName
                + ' tenName:' + tenName
                + ' lastName:' + lastName);
            if (tenName == '0') {
                result = '' + strName + lastName;
            }
            else if (tenName == '1') {
                result = '' + strName + '鍗�' + lastName;
            }
            else {
                result = '' + strName + tenName + '鍗�' + lastName;
            }
            return result;
        };
        Segment.prototype._getArrivedFloorText = function (floorId) {
            var message = '';
            var strFloor = this.GetFloorIdVoiceStringByFloorId(floorId);
            var _a = this._properties; _a.pathType; _a.floorAddress;
            {
                message = language.getType() === 'cn'
                    ? "\u60A8\u5DF2\u5230\u8FBE" + strFloor + "\u5C42\uFF0C" : "You are arriving at " + strFloor + "\uFF0C";
                LogMgr$1.log('zhengli1 _getArrivedFloorText '
                    + ' floor:' + this._properties.floorAddress
                    + ' distance:' + this._distance
                    + ' floorId:' + floorId
                    + ' strFloor:' + strFloor);
            }
            return message;
        };
        Segment.prototype.IsBezier = function () {
            return this._isBezier;
        };
        Segment.prototype._getNaviDirectionText = function () {
            if (!this._nextSegment)
                return language.get('endTip');
            var throughText = (this._facility === 'elevator' || this._facility === 'escalator') ? '涔�' : '閫氳繃';
            switch (this._direction) {
                case 'leftRear': {
                    return language.get('leftRearTip');
                }
                case 'left': {
                    return language.get('leftTip');
                }
                case 'leftFront': {
                    return language.get('leftFrontTip');
                }
                case 'rightFront': {
                    return language.get('rightFrontTip');
                }
                case 'right': {
                    return language.get('rightTip');
                }
                case 'rightRear': {
                    return language.get('rightRearTip');
                }
                case 'straight': {
                    return language.get('straightTip');
                }
                case 'top': {
                    var floorAddress = this._nextSegment._properties.floorAddress;
                    if (language.getType() === 'cn') {
                        return "" + throughText + this._facilityTipText + "\u4E0A\u884C\u81F3" + this._getRampBuilding() + floorAddress + "\u5C42";
                    }
                    else {
                        return "Use " + this._facilityTipText + " to " + floorAddress;
                    }
                }
                case 'bottom': {
                    var floorAddress = this._nextSegment._properties.floorAddress;
                    if (language.getType() === 'cn') {
                        return "" + throughText + this._facilityTipText + "\u4E0B\u884C\u81F3" + this._getRampBuilding() + floorAddress + "\u5C42";
                    }
                    else {
                        return "Use " + this._facilityTipText + " to " + floorAddress;
                    }
                }
                default: {
                    return '';
                }
            }
        };
        Segment.prototype.HasElevatarInMeter = function (segment, checkMeter, curDisToEnd) {
            var result = {
                hasElevatar: false,
                direction: 'unknown',
                facilityText: '鐢垫',
                floorAddress: 'F1',
                distance: 0,
            };
            if (segment == null || segment == undefined) {
                return result;
            }
            var leftMeter = checkMeter;
            var curSegment = segment;
            var bFirstSegment = true;
            while (curSegment) {
                if (curSegment._direction == 'top' || curSegment._direction == 'bottom') {
                    result.hasElevatar = true;
                    result.direction = curSegment._direction;
                    if (curSegment._nextSegment) {
                        result.floorAddress = curSegment._nextSegment._properties.floorAddress;
                    }
                    else {
                        result.floorAddress = curSegment._properties.floorAddress;
                    }
                    result.facilityText = curSegment._facilityTipText;
                    result.distance = Math.floor(checkMeter - leftMeter);
                    if (result.distance < 1) {
                        result.distance = 1;
                    }
                    return result;
                }
                else {
                    if (bFirstSegment) {
                        leftMeter -= curDisToEnd;
                        curSegment = curSegment._nextSegment;
                        bFirstSegment = false;
                    }
                    else {
                        leftMeter -= curSegment._distance;
                        curSegment = curSegment._nextSegment;
                    }
                }
                if (leftMeter < 0) {
                    return result;
                }
            }
            return result;
        };
        Segment.prototype.getMessageInNavi = function (maxFacilityDis, coordinate, isTipMovePhone, canPlayLiftMsg, bChangeFloor, strFloorId) {
            if (isTipMovePhone === void 0) { isTipMovePhone = true; }
            if (canPlayLiftMsg === void 0) { canPlayLiftMsg = true; }
            if (bChangeFloor === void 0) { bChangeFloor = false; }
            if (strFloorId === void 0) { strFloorId = ''; }
            var distance;
            var isLeftMsg = false;
            var startPoint = new Point(coordinate.x, coordinate.y);
            if (coordinate) {
                distance = startPoint.distanceTo(this._line.getEnd());
            }
            else {
                distance = this._distance;
            }
            startPoint.distanceTo(this._line.getStart());
            distance = Math.round(distance);
            var message;
            var resultMessage;
            if (this._direction === 'straight') {
                if (language.getType() === 'cn') {
                    message = "\u524D\u65B9, " + this._getNaviDirectionText();
                }
                else {
                    message = "In front, " + this._getNaviDirectionText();
                }
            }
            else if (distance <= 4) {
                message = this._getNaviDirectionText();
            }
            else if (distance > 4 && distance < 8) {
                if (language.getType() === 'cn') {
                    message = "\u524D\u65B9, " + this._getNaviDirectionText();
                }
                else {
                    message = "In front, " + this._getNaviDirectionText();
                }
            }
            else if (distance >= 8) {
                if (language.getType() === 'cn') {
                    message = "\u76F4\u884C" + distance + "\u7C73\u540E, " + this._getNaviDirectionText();
                }
                else {
                    message = "After " + distance + " meters, " + this._getNaviDirectionText();
                }
            }
            var hasElevatarResult = this.HasElevatarInMeter(this, 8, distance);
            if (hasElevatarResult.hasElevatar == true && canPlayLiftMsg) {
                var facilityText = hasElevatarResult.facilityText;
                var floorAddress = hasElevatarResult.floorAddress;
                var distanceToLift = hasElevatarResult.distance;
                if (facilityText == '鐢垫' || facilityText == '鎵舵') {
                    resultMessage = distanceToLift + "\u7C73\u540E\u642D\u4E58" + facilityText + "\u524D\u5F80" + this._getRampBuilding() + floorAddress + "\u5C42";
                    message = resultMessage;
                }
                else {
                    resultMessage = distanceToLift + "\u7C73\u540E\u8D70" + facilityText + "\u524D\u5F80" + this._getRampBuilding() + floorAddress + "\u5C42";
                    message = resultMessage;
                }
                isLeftMsg = true;
                LogMgr$1.log('zhengli101 ' + ' facilityText:' + facilityText
                    + ' floorAddress:' + floorAddress
                    + ' direction:' + hasElevatarResult.direction);
            }
            else {
                maxFacilityDis = 4;
                if (this._nextSegment && this._nextSegment._facility &&
                    this._nextSegment._distance + distance < maxFacilityDis
                    && this._properties.pathType != 'outEscalator') {
                    if (language.getType() === 'cn') {
                        message = '璇锋部璺嚎鍓嶈繘';
                    }
                    else {
                        message = 'Please Follow the navi.';
                    }
                    return {
                        isWillChange: distance < 8,
                        message: "" + message,
                        direction: this._nextSegment._direction,
                        facilityTipText: this._nextSegment._facilityTipText,
                        facility: this._nextSegment._facility,
                        facilityId: this._nextSegment._facilityId,
                        isLeftMsg: isLeftMsg,
                        isInBuildingMsg: false,
                        isBezier: this._isBezier,
                    };
                }
            }
            if (isTipMovePhone && !this._isTipMovePhone && this._properties.pathType === 'outEscalator') {
                this._isTipMovePhone = true;
                resultMessage = language.get('originalTip');
            }
            var isInBuildingMsg = false;
            (this._getOutBuildingText() || '').replace(/\|/g, '');
            var _inBuildingText = (this._getInBuildingText() || '').replace(/\|/g, '');
            {
                if (_inBuildingText) {
                    if (distance < 8) {
                        isInBuildingMsg = true;
                        resultMessage = "" + _inBuildingText + message;
                    }
                    else {
                        resultMessage = message;
                    }
                }
                else {
                    resultMessage = message;
                }
            }
            LogMgr$1.log('zhengli 2 changeFloorMsg: bChangeFloor:' + bChangeFloor
                + ' floorId:' + strFloorId);
            if (bChangeFloor) {
                var strTempMsg = this._getArrivedFloorText(strFloorId);
                LogMgr$1.log('zhengli 3 changeFloorMsg:' + strTempMsg);
                resultMessage = "" + strTempMsg;
            }
            return {
                isWillChange: distance < 8,
                message: resultMessage,
                direction: this._direction,
                facilityTipText: this._facilityTipText,
                facility: this._facility,
                facilityId: this._facilityId,
                isLeftMsg: isLeftMsg,
                isInBuildingMsg: isInBuildingMsg,
                isBezier: this._isBezier,
            };
        };
        Segment.prototype.getLine = function () {
            return this._line;
        };
        Segment.prototype.getDistance = function () {
            return this._distance;
        };
        Segment.prototype.getRotate = function () {
            return this._rotate;
        };
        Segment.prototype.getFacilityId = function () {
            return this._facilityId;
        };
        Object.defineProperty(Segment.prototype, "floor", {
            get: function () {
                return this._properties.floor;
            },
            enumerable: false,
            configurable: true
        });
        Segment.prototype.getProperties = function () {
            return this._properties;
        };
        Segment.prototype.getDirection = function () {
            return this._direction;
        };
        Segment.prototype.getFacilityTipText = function () {
            return this._facilityTipText;
        };
        Segment.prototype.getNextFloorAddress = function () {
            return this._nextSegment && this._nextSegment._properties.floorAddress;
        };
        return Segment;
    }());

    var NewDynamicNaviManager = (function () {
        function NewDynamicNaviManager(mapView, options) {
            this._segments = [];
            this._crtIndex = -1;
            this._hasTipMovePhone = false;
            this._mapView = mapView;
            this._options = options;
        }
        NewDynamicNaviManager.prototype.init = function (features) {
            this.reset();
            for (var i = 0; i < features.length; i += 1) {
                var _a = features[i], coordinates = _a.geometry.coordinates, properties = _a.properties;
                var segment = new Segment(coordinates, properties);
                this._segments.push(segment);
            }
            for (var i = 0; i < this._segments.length; i += 1) {
                if (i + 1 < this._segments.length) {
                    this._segments[i].setNextSegment(this._segments[i + 1]);
                }
            }
        };
        NewDynamicNaviManager.prototype.getCurSegment = function () {
            if (this._crtIndex < 0 || this._crtIndex >= this._segments.length) {
                return null;
            }
            else {
                return this._segments[this._crtIndex];
            }
        };
        NewDynamicNaviManager.prototype.resetTipMovePhone = function () {
            this._hasTipMovePhone = false;
        };
        NewDynamicNaviManager.prototype.getClosestCoordArray = function (floorId, coordinate) {
            var segmentArray = [];
            for (var i = 0; i < this._segments.length; i++) {
                this._segments[i].m_index = i;
            }
            for (var i = 0; i < this._segments.length; i++) {
                if (this._segments[i].floor === floorId) {
                    var item = this._segments[i];
                    segmentArray.push(item);
                }
            }
            for (var i = 0; i < segmentArray.length; i++) {
                var k = i;
                var minDisItem = segmentArray[k];
                if (minDisItem == null || minDisItem == undefined) {
                    continue;
                }
                var item = minDisItem.getClosest(coordinate);
                for (var j = i + 1; j < segmentArray.length; j++) {
                    var item2 = segmentArray[j].getClosest(coordinate);
                    if (item2.distance < item.distance) {
                        k = j;
                        minDisItem = segmentArray[j];
                        item = minDisItem.getClosest(coordinate);
                    }
                }
                var tempDisItem = segmentArray[i];
                segmentArray[i] = segmentArray[k];
                segmentArray[k] = tempDisItem;
            }
            var resultArray = [];
            for (var i = 0; i < segmentArray.length; i++) {
                var itemResult = segmentArray[i].getClosest(coordinate);
                var resultCoord = itemResult.coordinate;
                new Point(coordinate.x, coordinate.y);
                var point = new Point(resultCoord.x, resultCoord.y);
                var segment = segmentArray[i];
                segment.getNextSegment();
                segment.getRestDistance(point);
                var result = {
                    index: segmentArray[i].m_index,
                    coordinate: point,
                    isClosestFacility: false,
                    distance: itemResult.distance,
                    bias: 0,
                    endPoint: segment._line.getEnd(),
                    startPoint: segment._line.getStart(),
                };
                resultArray.push(result);
            }
            this.LogRouteBiasToDom(resultArray);
            return resultArray;
        };
        NewDynamicNaviManager.prototype.LogRouteBiasToDom = function (threeRouteArray) {
            return;
        };
        NewDynamicNaviManager.prototype.getClosestCoord = function (floorId, coordinate) {
            var index = -1;
            var closestResult;
            for (var i = 0; i < this._segments.length; i += 1) {
                if (this._segments[i].floor === floorId) {
                    var item = this._segments[i].getClosest(coordinate);
                    if (!closestResult || item.distance < closestResult.distance) {
                        closestResult = item;
                        index = i;
                    }
                }
            }
            var resultCoord = closestResult.coordinate;
            var startPoint = new Point(coordinate.x, coordinate.y);
            var point = new Point(resultCoord.x, resultCoord.y);
            var segment = this._segments[index];
            var nextSegment = segment.getNextSegment();
            var restDis = segment.getRestDistance(point);
            var result = {
                index: index,
                coordinate: point,
                isClosestFacility: false,
                distance: startPoint.distanceTo(point),
            };
            if (segment.isFacility() && restDis < this._options.adsorbFacilityDis) {
                result.coordinate = segment.getEnd();
                result.isClosestFacility = true;
            }
            else if (nextSegment && nextSegment.isFacility()) {
                restDis += nextSegment.getDistance();
                if (restDis < this._options.adsorbFacilityDis) {
                    result.index = index + 1;
                    result.coordinate = nextSegment.getEnd();
                    result.isClosestFacility = true;
                }
            }
            return result;
        };
        NewDynamicNaviManager.prototype.distanceToEnd = function (index, coordinate) {
            var result = 0;
            for (var i = index + 1; i < this._segments.length; i += 1) {
                result += this._segments[i].getDistance();
            }
            var end = this._segments[index].getEnd();
            result += new Point(coordinate.x, coordinate.y).distanceTo(end);
            return result;
        };
        NewDynamicNaviManager.prototype.findNearSegment = function (index, coordinate, isMove, bSimulate) {
            if (isMove === void 0) { isMove = true; }
            if (bSimulate === void 0) { bSimulate = false; }
            this._crtIndex = index;
            this._crtCoordinate = coordinate;
            var num = index;
            var restDistance = this.crtSegment.getRestDistance(this._crtCoordinate);
            var restRotateDistance = this._options.restRotateDistance;
            if (restDistance < restRotateDistance &&
                index < this._segments.length - 1 &&
                this._segments[index].floor === this._segments[index + 1].floor) {
                num += 1;
            }
            this._crtRotate = this._segments[num].getRotate();
            isMove && this._moveToSegment(this._crtRotate, bSimulate);
        };
        NewDynamicNaviManager.prototype._moveToSegment = function (rotate, bUseSimNaviDuration) {
            if (bUseSimNaviDuration === void 0) { bUseSimNaviDuration = false; }
            if (rotate === this._mapView.getRotate())
                return;
            var startRotate = this._mapView.getRotate() || 0;
            var targetRotate = Camera.normalizeRotate(rotate, startRotate);
            var deltaRotate = Math.abs(targetRotate - startRotate);
            var duration = deltaRotate / this._options.rotateSpeed * 1000;
            if (bUseSimNaviDuration) {
                duration = 200;
            }
            this._mapView.easeTo({
                rotate: rotate,
                duration: duration,
                easing: 'linear',
                offset: this._options.offset,
            });
        };
        NewDynamicNaviManager.prototype.getMessageInNavi = function (isTipMovePhone, canPlayLiftMsg, bChangeFloor, strFloorId, bUseNextSegment) {
            if (isTipMovePhone === void 0) { isTipMovePhone = true; }
            if (canPlayLiftMsg === void 0) { canPlayLiftMsg = true; }
            if (bChangeFloor === void 0) { bChangeFloor = false; }
            if (strFloorId === void 0) { strFloorId = ''; }
            if (bUseNextSegment === void 0) { bUseNextSegment = false; }
            var curSegment = null;
            if (bChangeFloor) {
                curSegment = this._segments[this._crtIndex + 1];
            }
            else {
                curSegment = this._segments[this._crtIndex];
            }
            if (curSegment) {
                var nextSegment = curSegment.getNextSegment();
                var info = null;
                if (bUseNextSegment == true && nextSegment) {
                    info = nextSegment.getMessageInNavi(this._options.maxFacilityDis, this._crtCoordinate, isTipMovePhone, canPlayLiftMsg, bChangeFloor, strFloorId);
                }
                else {
                    info = curSegment.getMessageInNavi(this._options.maxFacilityDis, this._crtCoordinate, isTipMovePhone, canPlayLiftMsg, bChangeFloor, strFloorId);
                }
                info.isBezier = curSegment.IsBezier();
                if (isTipMovePhone && !this._hasTipMovePhone) {
                    info.message = language.get('originalTip');
                    info.direction = undefined;
                    this._hasTipMovePhone = true;
                }
                return info;
            }
            else {
                var info = {
                    message: '',
                    direction: undefined,
                    isBezier: false,
                };
                return info;
            }
        };
        NewDynamicNaviManager.prototype.getMessageInList = function () {
            var result = [];
            for (var i = 0; i < this._segments.length; i += 1) {
                result.push(this._segments[i].getMessageInNavi(this._options.maxFacilityDis));
            }
            return result;
        };
        Object.defineProperty(NewDynamicNaviManager.prototype, "crtRotate", {
            get: function () {
                return this._crtRotate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NewDynamicNaviManager.prototype, "crtSegment", {
            get: function () {
                return this._segments[this._crtIndex];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NewDynamicNaviManager.prototype, "crtIndex", {
            get: function () {
                return this._crtIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NewDynamicNaviManager.prototype, "curIndex", {
            set: function (index) {
                this._crtIndex = index;
            },
            enumerable: false,
            configurable: true
        });
        NewDynamicNaviManager.prototype.getStartFloor = function () {
            return this._segments[0].floor;
        };
        NewDynamicNaviManager.prototype.getWholeDistance = function () {
            var distance = 0;
            for (var i = 0; i < this._segments.length; i += 1) {
                distance += this._segments[i].getDistance();
            }
            return distance;
        };
        NewDynamicNaviManager.prototype.getEndFloor = function () {
            return this._segments[this._segments.length - 1].floor;
        };
        NewDynamicNaviManager.prototype.getSegments = function () {
            return this._segments;
        };
        NewDynamicNaviManager.prototype.reset = function () {
            this._segments.length = 0;
            delete this._crtCoordinate;
            this._crtIndex = -1;
        };
        return NewDynamicNaviManager;
    }());

    var NewNavigate = (function (_super) {
        __extends$1(NewNavigate, _super);
        function NewNavigate(options) {
            var _this = _super.call(this) || this;
            _this._isInitNavi = false;
            _this._locationMng = null;
            _this.m_naviMapViewStartZoom = 18;
            _this._status = 'init';
            _this._isTipEnd = false;
            _this._isPlayWill = false;
            _this._isBezier = false;
            _this._canPlayLiftMsg = true;
            _this._isMapRotate = false;
            _this._audioProvider = new AudioProvider();
            _this._isInInterrupt = false;
            _this._simIndex = 0;
            _this._simOldIndex = 0;
            _this._canPop = false;
            _this._otherFloorNum = 0;
            _this._facilityTipMarkers = [];
            _this._isPlayingMoveToFloor = false;
            _this._lastFloorIsOutdoor = false;
            _this._locationIsStart = true;
            _this._navigateViewType = 'first';
            _this._deviateNum = 0;
            _this._interruptNum = 0;
            _this._reInitNaviTime = 0;
            _this._navigateSpeed = 0;
            _this._interruptRestTime = 0;
            _this._interruptRestDistance = 0;
            _this._isNaviSleep = false;
            _this.m_bias = 3;
            _this.m_floorBias = 8;
            _this.m_maxFloorBias = 8;
            _this.m_routeTrustness = 0;
            _this.m_nearRouteTrustness = 0;
            _this.m_logDomArray = [];
            _this.m_lastDisToEnd = 999999999;
            _this.m_fowardBias = 10;
            _this.m_maxFowardBias = 10;
            _this.m_lastIndex = 0;
            _this.m_lastDistance = 0;
            _this.m_lastCoord = new Point(0, 0);
            _this.m_lastEndFloorId = '';
            _this.m_lastEndCoord = { x: 0, y: 0 };
            _this.m_lastZoomBeforeCrossing = 19.8;
            _this.m_newZoom = 19.8;
            _this.m_lastNaviState = 'unknown';
            _this.m_generalNaviZoom = 19.8;
            _this.m_crossingNaviZoom = 20.8;
            _this.m_finishNaviZoom = 18.5;
            _this.m_forwardCrossingDis = 5;
            _this.m_backCrossingDis = 2;
            _this.m_crossingAnimTime = 2000;
            bindAll([
                '_onMapGestureStart',
                '_onMapGestureEnd',
                '_onMapRotate',
            ], _this);
            _this._options = __assign$1(__assign$1({}, defaultOptions$1), options);
            _this._markerMng = new MarkerManager(_this._options.markerConfig);
            LogMgr$1.log('Init NewNavigate');
            return _this;
        }
        NewNavigate.prototype.SetNaviZoomAnimParam = function (generalZoom, crossingZoom, finishZoom, animTime) {
            this.m_generalNaviZoom = generalZoom;
            this.m_crossingNaviZoom = crossingZoom;
            this.m_finishNaviZoom = finishZoom;
            this.m_crossingAnimTime = animTime;
            this.m_lastZoomBeforeCrossing = this.m_generalNaviZoom;
            this.m_newZoom = this.m_generalNaviZoom;
        };
        NewNavigate.prototype.GetOption = function () {
            return this._options;
        };
        NewNavigate.prototype.addTo = function (mapView) {
            this._mapView = mapView;
            this._mapView.setCurNavi(this);
            this._mapView.on('gestureStart', this._onMapGestureStart);
            this._mapView.on('gestureEnd', this._onMapGestureEnd);
            this._mapView.on('rotate', this._onMapRotate);
            this._markerMng.addTo(mapView);
            this._naviMng = new NewNaviManager(mapView, {
                lineImage: this._options.lineImage,
                lineWidth: this._options.lineWidth,
                server: this._options.naviServer,
                lineHeight: this._options.lineHeight,
                multilineOpacity: this._options.multilineOpacity,
                defaultFloorGap: this._options.defaultFloorGap,
                recommendRouteType: this._options.recommendRouteType,
                defaultStrategy: this._options.defaultStrategy,
                startLimitLength: this._options.startLimitLength,
                offline: this._options.offline,
                grayImage: this._options.grayImage,
                showShortest: this._options.showShortest,
                shortestLineConfig: this._options.shortestLineConfig,
                isShowNaviProgress: this._options.isShowNaviProgress
            });
            this._dynamicMng = new NewDynamicNaviManager(mapView, {
                rotateSpeed: this._options.rotateSpeed,
                offset: this._options.navigatingOffset,
                restRotateDistance: this._options.restRotateDistance,
                maxFacilityDis: this._options.maxFacilityDis,
                adsorbFacilityDis: this._options.adsorbFacilityDis,
            });
            this.UpdateNaviConfig();
        };
        NewNavigate.prototype.Tick = function (dt) {
            this.TickEvent(dt);
        };
        NewNavigate.prototype.TickEvent = function (dt) {
            while (true) {
                var naviEvent = NaviEventMgr.GetInstance().PopMsg();
                if (naviEvent == null || naviEvent == undefined) {
                    break;
                }
                this.ProcessEvent(naviEvent.m_eventName, naviEvent.m_eventData);
            }
        };
        NewNavigate.prototype.ProcessEvent = function (eventName, eventData) {
            if (eventName == 'gestureStart') {
                this._onMapGestureStart();
            }
            else if (eventName == 'gestureEnd') {
                this._onMapGestureEnd();
            }
            else if (eventName == 'rotate') {
                this._onMapRotate();
            }
        };
        NewNavigate.prototype.getMarkerMgr = function () {
            return this._markerMng;
        };
        NewNavigate.prototype.setNavigateViewType = function (viewType) {
            this._navigateViewType = viewType;
        };
        NewNavigate.prototype.UpdateNaviConfig = function () {
            if (this._mapView == null || this._mapView == undefined) {
                return;
            }
            if (this._options == null || this._options == undefined) {
                return;
            }
            var naviParam = this._mapView.GetNaviParam();
            this._options.maxRoadAttachDistance = naviParam.maxRoadAttachDistance;
            this._options.maxDistanceReInitNavi = naviParam.maxDistanceReInitNavi;
            this._options.outdoorMaxRoadAttachDistance = naviParam.maxOutRoadAttachDistance;
            this._options.outdoorMaxDistanceReInitNavi = naviParam.maxOutDistanceReInitNavi;
        };
        NewNavigate.prototype.interruptNavigating = function () {
            if (this._status === 'init')
                return;
            this.fire('navigatingInterrupt');
            this._mapView && this._mapView.stop();
            if (this._simAnimator) {
                this._simAnimator.pause();
            }
            else {
                this._interruptNum += 1;
            }
            this._isInInterrupt = true;
        };
        NewNavigate.prototype._onMapGestureStart = function () {
            if (this._status === 'init' || (this._status === 'simulateNavigate' && this._navigateViewType !== 'first'))
                return;
            this.interruptNavigating();
            if (this._touchTimer) {
                clearTimeout(this._touchTimer);
                delete this._touchTimer;
            }
        };
        NewNavigate.prototype._onMapGestureEnd = function () {
            var _this = this;
            if (this._status === 'init' || (this._status === 'simulateNavigate' && this._navigateViewType !== 'first'))
                return;
            this.fire('recoveryNavigatingReady');
            this._touchTimer = window.setTimeout(function () {
                _this.recoveryNavigating();
            }, this._options.recoveryTime);
        };
        NewNavigate.prototype._onMapRotate = function () {
            if (this._status !== 'simulateNavigate' || !this._dynamicMng)
                return;
            var thirdViewRotate = this._dynamicMng.crtSegment.getRotate();
            if (this._mapView && this._mapView.getRotate()) {
                thirdViewRotate = this._dynamicMng.crtSegment.getRotate() - this._mapView.getRotate();
            }
            var simMarker = this._markerMng.getMarker('sim');
            if (!simMarker)
                return;
            simMarker.setRotate(this._navigateViewType === 'first' ? 0 : thirdViewRotate);
        };
        NewNavigate.prototype.recoveryNavigating = function () {
            var _this = this;
            if (!this._mapView || !this._dynamicMng || !this._isInInterrupt)
                return;
            this._isInInterrupt = false;
            if (this._touchTimer) {
                clearTimeout(this._touchTimer);
                delete this._touchTimer;
            }
            this.fire('recoveryNavigating');
            if (this._status === 'navigating') {
                if (this._options.isShowNaviProgress) {
                    this.setCountdownTimer();
                }
                if (!this._locationMng)
                    return;
                var position = this._locationMng.getPosition();
                if (!position)
                    return;
                this._navigateViewType === 'first' && this._mapView.easeTo({
                    center: position.coordinate,
                    offset: this._options.navigatingOffset,
                    rotate: this._dynamicMng.crtRotate,
                    duration: 300,
                    easing: 'linear',
                });
            }
            else if (this._status === 'simulateNavigate') {
                var simMarker = this._markerMng.getMarker('sim');
                if (!simMarker)
                    return;
                var position = simMarker.getPosition();
                if (!position)
                    return;
                this._navigateViewType === 'first' && this._mapView.easeTo({
                    center: position.coordinate,
                    offset: this._options.navigatingOffset,
                    rotate: this._dynamicMng.crtRotate,
                    duration: 300,
                    easing: 'linear',
                });
                sleep(316).then(function () {
                    if (_this._options.isShowNaviProgress) {
                        _this.setCountdownTimer();
                    }
                    if (_this._simAnimator) {
                        if (!_this._navigateSpeed) {
                            _this._simAnimator.play(false);
                        }
                        else {
                            _this._simAnimator.play(true);
                        }
                    }
                    else {
                        _this._simulate();
                    }
                });
            }
        };
        NewNavigate.prototype.updateSpeed = function (nowSpeed) {
            var _this = this;
            this.interruptNavigating();
            this._navigateSpeed = nowSpeed;
            setTimeout(function () {
                _this.recoveryNavigating();
            }, 1000);
        };
        NewNavigate.prototype.getActiveRouteType = function () {
            return this._naviMng && this._naviMng.getActiveRouteType();
        };
        NewNavigate.prototype.getRecommendRouteType = function () {
            return this._naviMng && this._naviMng.getRecommendRouteType();
        };
        NewNavigate.prototype.OnPickMarkerRemoved = function () {
            this.fire('OnPickMarkerRemoved');
        };
        NewNavigate.prototype.initNavi = function () {
            return __awaiter(this, void 0, void 0, function () {
                var startMarker, endMarker, startPosition, endPosition, startBounds, fitPadding;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            startMarker = this.getMarker('start') ? this.getMarker('start') : this.getMarker('indoorStart');
                            endMarker = this.getMarker('end');
                            if (!startMarker || !endMarker) {
                                console.error('initNavi: startMarker and endMarker is all required');
                                return [2];
                            }
                            startPosition = startMarker.getPosition();
                            endPosition = endMarker.getPosition();
                            if (!startPosition || !endPosition) {
                                console.error('initNavi: startPosition and endPosition is all required');
                                return [2];
                            }
                            this.fire('beforeInitNavi');
                            this._naviMng && this._naviMng.resetActiveRouteType();
                            return [4, this._renderNavi(startPosition, endPosition)];
                        case 1:
                            _a.sent();
                            this.fire('initNavi');
                            startBounds = this._naviMng.getNaviBounds(false);
                            LogMgr$1.log('NewNavigate.ts initNavi ' + startBounds);
                            if (startBounds) {
                                fitPadding = this._options.fitPadding;
                                this.m_naviMapViewStartZoom = this._mapView.fitBounds(startBounds, fitPadding);
                                LogMgr$1.log('NewNavigate.ts initNavi 2' + this.m_naviMapViewStartZoom);
                            }
                            return [2];
                    }
                });
            });
        };
        NewNavigate.prototype.addFacilityTip = function () {
            if (!this._dynamicMng)
                return;
            var segments = this._dynamicMng.getSegments();
            var facilitySegs = [];
            for (var i = 0; i < segments.length; i += 1) {
                if (segments[i].isFacility()) {
                    facilitySegs.push(segments[i]);
                }
            }
            var arr = [];
            for (var i = 0; i < facilitySegs.length; i += 1) {
                var segObj = {
                    direction: facilitySegs[i].getDirection(),
                    facilityTipText: facilitySegs[i].getFacilityTipText(),
                    nextFloorAddress: facilitySegs[i].getNextFloorAddress(),
                };
                var tipContent = this.getFacilityTipContent(segObj);
                var facilityObj = {
                    floor: facilitySegs[i].floor,
                    coord: facilitySegs[i].getEnd(),
                    tipContent: tipContent,
                };
                arr.push(facilityObj);
            }
            this.setFacilityTipMarkers(arr);
        };
        NewNavigate.prototype.getFacilityTipContent = function (segObj) {
            var direction = segObj.direction, facilityTipText = segObj.facilityTipText, nextFloorAddress = segObj.nextFloorAddress;
            var facilityText = {
                elevator: '鐢垫',
                escalator: '鎵舵',
                stairs: '妤兼',
                ramp: '鍧￠亾',
            };
            var facility = '';
            if (facilityText[facilityTipText]) {
                facility = facilityText[facilityTipText];
            }
            else {
                facility = facilityTipText;
            }
            switch (direction) {
                case 'top':
                    if (facilityTipText === '鍧￠亾') {
                        return "\u6CBF\u9053\u8DEF\u81F3" + nextFloorAddress;
                    }
                    else {
                        return "" + (facilityTipText === '妤兼' ? '璧�' : '涔�') + facility + "\u4E0A\u884C\u81F3" + nextFloorAddress;
                    }
                case 'bottom':
                    if (facilityTipText === '鍧￠亾') {
                        return "\u6CBF\u9053\u8DEF\u81F3" + nextFloorAddress;
                    }
                    else {
                        return "" + (facilityTipText === '妤兼' ? '璧�' : '涔�') + facility + "\u4E0B\u884C\u81F3" + nextFloorAddress;
                    }
                default: {
                    return '';
                }
            }
        };
        NewNavigate.prototype.setFacilityTipMarkers = function (arr) {
            this.removeFacilityTipMarkers();
            for (var i = 0; i < arr.length; i += 1) {
                var _a = arr[i], floor = _a.floor, coord = _a.coord, tipContent = _a.tipContent;
                if (this._mapView) {
                    var dom = document.createElement('div');
                    var defaultTipStyle = {
                        minWidth: '130px',
                        height: '47px',
                        fontSize: '12px',
                        color: '#fff',
                        paddingTop: '8px',
                        display: 'flex',
                        justifyContent: 'center',
                        background: this._options.facilityTipBg ? "url(" + this._options.facilityTipBg + ")" : '#666',
                        backgroundSize: '100% 100%',
                    };
                    var tipStyle = __assign$1(__assign$1({}, defaultTipStyle), this._options.facilityTipStyle);
                    for (var key in tipStyle) {
                        dom.style[key] = tipStyle[key];
                    }
                    dom.innerText = tipContent;
                    var marker = new Marker(dom, { anchor: 'bottom' });
                    marker.addTo(this._mapView);
                    marker.setPosition(floor, { x: coord.x, y: coord.y });
                    this._facilityTipMarkers.push(marker);
                }
            }
        };
        NewNavigate.prototype.removeFacilityTipMarkers = function () {
            if (this._facilityTipMarkers && this._facilityTipMarkers.length > 0) {
                this._facilityTipMarkers.forEach(function (item) {
                    item.remove();
                });
            }
            this._facilityTipMarkers.length = 0;
        };
        NewNavigate.prototype.initOutDoorNavi = function (origin, destination, floorId) {
            return __awaiter(this, void 0, void 0, function () {
                var result, features;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._options.autoTip && loading();
                            this._isInitNavi = true;
                            if (!this._naviMng)
                                return [2];
                            return [4, this._naviMng.renderOutDoorNavi(origin, destination, floorId)];
                        case 1:
                            result = _a.sent();
                            features = this._naviMng.getActiveRoute();
                            if (this._dynamicMng && features) {
                                this._dynamicMng.init(features);
                            }
                            this.fire('initNaviOutDoor');
                            LogMgr$1.log('InitOutDoorNavi');
                            this._options.autoTip && hideLoading();
                            return [2, result];
                    }
                });
            });
        };
        NewNavigate.prototype.getWholeDistance = function () {
            if (!this._dynamicMng)
                return -1;
            return this._dynamicMng.getWholeDistance();
        };
        NewNavigate.prototype.getAllRouteType = function () {
            if (!this._naviMng)
                return [];
            return this._naviMng.getAllRouteType();
        };
        NewNavigate.prototype.setActiveRoute = function (activeRouteType) {
            return __awaiter(this, void 0, void 0, function () {
                var locationPosition, endMarker, endPosition, floorId, coordinate, activeRoute, e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._naviMng || this._naviMng.getActiveRouteType() === activeRouteType)
                                return [2];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, 4, 5]);
                            this._options.autoTip && loading();
                            if (this._status === 'navigating' && this._locationMng) {
                                locationPosition = this._locationMng.getPosition();
                                endMarker = this._markerMng.getMarker('end');
                                if (endMarker && locationPosition) {
                                    endPosition = endMarker.getPosition();
                                    if (endPosition) {
                                        floorId = locationPosition.floorId, coordinate = locationPosition.coordinate;
                                        this.setStartMarker(floorId, coordinate);
                                        this._naviMng.resetStartEnd(locationPosition, endPosition);
                                    }
                                }
                            }
                            return [4, this._naviMng.setActiveRoute(activeRouteType)];
                        case 2:
                            _a.sent();
                            activeRoute = this._naviMng.getActiveRoute();
                            activeRoute && this._dynamicMng && this._dynamicMng.init(activeRoute);
                            this._options.isAddFacilityTip && this.addFacilityTip();
                            return [3, 5];
                        case 3:
                            e_1 = _a.sent();
                            this.removeFacilityTipMarkers();
                            this._options.autoTip && hideLoading();
                            this.fire('setActiveRoute');
                            throw e_1;
                        case 4:
                            this._options.autoTip && hideLoading();
                            this.fire('setActiveRoute');
                            return [7];
                        case 5: return [2];
                    }
                });
            });
        };
        NewNavigate.prototype._beforeReInit = function (locationPosition, endPosition) {
            return __awaiter(this, void 0, void 0, function () {
                var maxRoadAttachDistance, bOutDoor, locationFloor, coordinate, message, closestResult;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._dynamicMng)
                                return [2];
                            maxRoadAttachDistance = this._options.maxRoadAttachDistance;
                            bOutDoor = Global.getInstance().IsOutDoor();
                            if (bOutDoor) {
                                maxRoadAttachDistance = this._options.outdoorMaxRoadAttachDistance;
                            }
                            LogMgr$1.log('Before ReInit OutDoor:' + bOutDoor);
                            locationFloor = locationPosition.floorId, coordinate = locationPosition.coordinate;
                            message = language.get('reInitTip');
                            LogMgr$1.log('zhengli _beforeReInit 1' + message);
                            this._audioProvider.playMessage(message);
                            this._tip(message);
                            return [4, this._renderNavi(locationPosition, endPosition)];
                        case 1:
                            _a.sent();
                            closestResult = this._dynamicMng.getClosestCoord(locationFloor, coordinate);
                            if (closestResult.distance < maxRoadAttachDistance) {
                                this._setupNavigating(locationFloor, closestResult.coordinate, closestResult.index);
                            }
                            return [2];
                    }
                });
            });
        };
        NewNavigate.prototype.startNavigate = function () {
            return __awaiter(this, void 0, void 0, function () {
                var endMarker, endPosition, locationPosition, locationFloor, coordinate, maxRoadAttachDistance, floorSet, closestResult;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._mapView || !this._dynamicMng || !this._naviMng)
                                return [2];
                            if (!this._locationMng) {
                                console.error('startNavigate: 闇€瑕佽缃� setLocationManager');
                                return [2];
                            }
                            endMarker = this._markerMng.getMarker('end');
                            if (!this._isCanNavi() || !endMarker) {
                                console.error('startNavigate: 璇峰厛瑙勫垝璺嚎');
                                return [2];
                            }
                            endPosition = endMarker.getPosition();
                            locationPosition = this._locationMng.getPosition();
                            if (!locationPosition || !endPosition) {
                                console.error('startNavigate: 鏃犲畾浣嶇偣鏃犳硶寮€濮嬪鑸�');
                                return [2];
                            }
                            this._preNavigating();
                            this._locationMng.startNavigate();
                            locationFloor = locationPosition.floorId, coordinate = locationPosition.coordinate;
                            if (!(locationFloor !== this._mapView.currentFloor)) return [3, 3];
                            return [4, this._mapView.setCurrentFloor(locationFloor)];
                        case 1:
                            _a.sent();
                            return [4, sleep(this._options.changeFloorTime)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            maxRoadAttachDistance = this._options.maxRoadAttachDistance;
                            if (this._lastFloor === 'outdoor') {
                                maxRoadAttachDistance = this._options.outdoorMaxRoadAttachDistance;
                            }
                            floorSet = new Set(this._naviMng.getFloorOrder());
                            if (floorSet.has(locationFloor)) {
                                closestResult = this._dynamicMng.getClosestCoord(locationFloor, coordinate);
                                if (closestResult.distance < maxRoadAttachDistance) {
                                    this._setupNavigating(locationFloor, closestResult.coordinate, closestResult.index);
                                }
                                else {
                                    this._beforeReInit(locationPosition, endPosition);
                                }
                            }
                            else {
                                this._beforeReInit(locationPosition, endPosition);
                            }
                            return [4, sleep(1000)];
                        case 4:
                            _a.sent();
                            this._status = 'navigating';
                            this.fire('startNavigate');
                            return [2];
                    }
                });
            });
        };
        NewNavigate.prototype.getNaviClosestCoord = function (floorId, coordinate) {
            if (!this._dynamicMng)
                return;
            return this._dynamicMng.getClosestCoord(floorId, coordinate);
        };
        NewNavigate.prototype._setupNavigating = function (floorId, coordinate, index) {
            return __awaiter(this, void 0, void 0, function () {
                var info, distanceToEnd;
                return __generator(this, function (_a) {
                    if (!this._locationMng || !this._dynamicMng || !this._mapView || !this._naviMng)
                        return [2];
                    this._locationMng.setPosition(floorId, coordinate);
                    this._dynamicMng.findNearSegment(index, coordinate, false);
                    info = this._dynamicMng.getMessageInNavi(false);
                    distanceToEnd = this._dynamicMng.distanceToEnd(index, coordinate);
                    this._fireNavigatingInfo(__assign$1(__assign$1({}, info), { distanceToEnd: distanceToEnd }));
                    this._audioProvider.playMessage("" + language.get('startNaviTip') + info.message);
                    this._naviMng.setWalked(floorId, coordinate, index);
                    this._fireARChange(floorId, coordinate);
                    this._navigateViewType === 'first' && this._mapView.easeTo({
                        center: coordinate,
                        zoom: this._options.navigatingZoom,
                        pitch: this._options.navigatingPitch,
                        rotate: this._dynamicMng.crtSegment.getRotate(),
                        duration: 1000,
                        offset: this._options.navigatingOffset,
                    });
                    return [2];
                });
            });
        };
        NewNavigate.prototype._preNavigating = function () {
            this._audioProvider.refresh();
            this._naviMng && this._naviMng.setIsShowMultiline(false);
            this._toggleControl(false);
            this._mapView && this._mapView.setViewType('single');
        };
        NewNavigate.prototype.removeLayers = function () {
            this._markerMng.clear();
            this._naviMng && this._naviMng.removeLayer();
            this._dynamicMng && this._dynamicMng.reset();
            this.removeFacilityTipMarkers();
        };
        NewNavigate.prototype.removeOutDoorLineLayers = function () {
            this._markerMng.removeMarker('outdoorStart');
            this._naviMng && this._naviMng.removeOutDoorLineLayers();
        };
        NewNavigate.prototype._isCanNavi = function () {
            return this._naviMng && this._naviMng.hasNavi() &&
                this._dynamicMng && this._dynamicMng.getSegments().length > 0;
        };
        NewNavigate.prototype.locationChange = function (floorId, coordinate, duration, bForceAnim) {
            if (bForceAnim === void 0) { bForceAnim = false; }
            if (!this._mapView)
                return;
            if (floorId === '0' || coordinate.x === 0 || coordinate.y === 0)
                return;
            var transFloor = floorId === 'outdoor' ? this._mapView.getDefaultFloor() : floorId;
            if (!transFloor)
                return;
            if (this._status === 'navigating') {
                var point = new Point(coordinate.x, coordinate.y);
                var isOutDoor = Global.getInstance().IsOutDoor();
                this._dynamicNavigate(transFloor, point, duration, isOutDoor);
            }
            else {
                this._locationMng && this._locationMng.setPosition(transFloor, coordinate, duration, bForceAnim);
            }
            this.fire('locationChange', {
                floorId: floorId,
                coordinate: coordinate,
                duration: duration,
            });
            this._lastFloor = floorId;
        };
        NewNavigate.prototype.getNavigatingRotate = function () {
            if (!this._dynamicMng)
                return 0;
            return this._dynamicMng.crtRotate;
        };
        NewNavigate.prototype._fireARChange = function (floorId, coordinate) {
            if (!this._naviMng || !this._mapView)
                return;
            var engine = this._mapView.getEngine();
            if (!engine)
                return;
            this.fire('arChange', {
                coordinate: coordinate,
                line: this._naviMng.getRestLines(floorId),
                offset: engine.getOffset(),
            });
        };
        NewNavigate.prototype.getFloorOrder = function () {
            return this._naviMng ? this._naviMng.getFloorOrder() : [];
        };
        NewNavigate.prototype.DebugNavi = function (bias, routeTrustness, nearRouteTrustness, closestRouteIndex, closestDis, attachDis, naviState, distanceToEnd) {
            var strLog = 'NaviState: Bias: ' + bias
                + ', RouteTrustness: ' + routeTrustness
                + ', NearRouteTrustness: ' + nearRouteTrustness
                + ', ClosestRouteIndex: ' + closestRouteIndex
                + ', ClosestDis: ' + closestDis
                + ', AttachDis: ' + attachDis
                + ', NaviState: ' + naviState
                + ', DistanceToEnd: ' + distanceToEnd;
            LogMgr$1.log(strLog);
            var map = MapView$1.GetInstance().getContainer();
            if (map == null || map == undefined) {
                return;
            }
            var dom1 = null;
            var dom2 = null;
            var dom3 = null;
            if (this.m_logDomArray.length >= 3) {
                dom1 = this.m_logDomArray[0];
                dom2 = this.m_logDomArray[1];
                dom3 = this.m_logDomArray[2];
            }
            if (dom1 == null || dom1 == undefined) {
                dom1 = document.createElement('log1');
                dom1.innerHTML = '<div id="log1" style="position: absolute;top:20px;left:20px;z-index:9999;font-size: small"></div>';
                map === null || map === void 0 ? void 0 : map.appendChild(dom1);
                this.m_logDomArray.push(dom1);
            }
            if (dom2 == null || dom2 == undefined) {
                dom2 = document.createElement('log2');
                dom2.innerHTML = '<div id="log2" style="position: absolute;top:60px;left:20px;z-index:9999;font-size: small"></div>';
                var map_1 = MapView$1.GetInstance().getContainer();
                map_1 === null || map_1 === void 0 ? void 0 : map_1.appendChild(dom2);
                this.m_logDomArray.push(dom2);
            }
            if (dom3 == null || dom3 == undefined) {
                dom3 = document.createElement('log3');
                dom3.innerHTML = '<div id="log3" style="position: absolute;top:100px;left:20px;z-index:9999;font-size: small"></div>';
                var map_2 = MapView$1.GetInstance().getContainer();
                map_2 === null || map_2 === void 0 ? void 0 : map_2.appendChild(dom3);
                this.m_logDomArray.push(dom3);
            }
            dom1.innerText = "     Bias: " + bias
                + " RouteTrustness: " + routeTrustness
                + " NearRouteTrustness: " + nearRouteTrustness;
            dom2.innerText = "ClosestIndex : " + closestRouteIndex
                + " ClosestDis: " + closestDis
                + " AttachDis: " + attachDis;
            dom3.innerText = "NaviState : " + naviState;
        };
        NewNavigate.prototype.GetClosestPointByTwoSegment = function (segment1, segment2) {
            if (segment1 == null || segment1 == undefined
                || segment2 == null || segment2 == undefined) {
                return null;
            }
            return segment1.getEnd();
        };
        NewNavigate.prototype._dynamicNavigate = function (floorId, coordinate, duration, isOutdoor) {
            return __awaiter(this, void 0, void 0, function () {
                var bChangeFloor, bReInitRoute, _a, maxDistanceReInitNavi, maxRoadAttachDistance, strFloorLog, info, floorSet, segment, nextSegment, distance_1, strNaviState, closestIndexArray, closestIndex, distance, closestCoord, curDisToEnd, mapView, mapView, curDisToEnd, curDisToEnd, mapView, mapView, bFind, i, curDisToEnd, mapView, i, routeIndex, oldIndex, oldSegment, distanceToEnd, segment, bDisplayPickMarker, mapView, message, isInFlow, info, isInBuildingMsg, message;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this._mapView || !this._dynamicMng || !this._naviMng || !this._locationMng)
                                return [2];
                            bChangeFloor = false;
                            bReInitRoute = false;
                            if (this._isInitNavi) {
                                this.m_bias = 3;
                                this.m_lastDisToEnd = 999999999;
                                this.m_floorBias = this.m_maxFloorBias;
                                this._locationMng.setPosition(floorId, coordinate, duration);
                                this._fireARChange(floorId, coordinate);
                                this.m_lastZoomBeforeCrossing = this._mapView.getZoom();
                                this.m_newZoom = this.m_generalNaviZoom;
                                this._canPlayLiftMsg = true;
                                return [2];
                            }
                            _a = this._options, maxDistanceReInitNavi = _a.maxDistanceReInitNavi, maxRoadAttachDistance = _a.maxRoadAttachDistance;
                            if (isOutdoor) {
                                maxDistanceReInitNavi = this._options.outdoorMaxDistanceReInitNavi;
                                maxRoadAttachDistance = this._options.outdoorMaxRoadAttachDistance;
                            }
                            if (!(floorId !== this._mapView.currentFloor)) return [3, 5];
                            this.m_floorBias--;
                            strFloorLog = 'OrigionFloor : ' + this._mapView.currentFloor
                                + ' NewFloor : ' + floorId
                                + 'FloorBias : ' + this.m_floorBias;
                            LogMgr$1.log(strFloorLog);
                            if (!(this.m_floorBias < 0)) return [3, 3];
                            this.m_bias = 3;
                            this.m_floorBias = this.m_maxFloorBias;
                            this.m_lastZoomBeforeCrossing = this._mapView.getZoom();
                            this.m_newZoom = this.m_generalNaviZoom;
                            this._canPlayLiftMsg = true;
                            return [4, this._mapView.setCurrentFloor(floorId)];
                        case 1:
                            _b.sent();
                            bChangeFloor = true;
                            info = this._dynamicMng.getMessageInNavi(false, this._canPlayLiftMsg, bChangeFloor, floorId, false);
                            LogMgr$1.log('zhengli changeFloorMsg ' + info.message
                                + ' bChangeFloor:' + bChangeFloor
                                + ' floorId:' + floorId);
                            this._audioProvider.playMessage(info.message, bChangeFloor);
                            return [4, sleep(this._options.changeFloorTime)];
                        case 2:
                            _b.sent();
                            return [3, 4];
                        case 3: return [2];
                        case 4: return [3, 6];
                        case 5:
                            this.m_floorBias++;
                            this.m_floorBias = Math.min(this.m_maxFloorBias, this.m_floorBias);
                            _b.label = 6;
                        case 6:
                            floorSet = new Set(this._naviMng.getFloorOrder());
                            if (!floorSet.has(floorId)) {
                                segment = this._dynamicMng.crtSegment;
                                if (!segment) {
                                    bReInitRoute = true;
                                    LogMgr$1.log('NewNavigate 1 cant find segment');
                                }
                                else {
                                    nextSegment = segment.getNextSegment();
                                    distance_1 = segment.getEnd().distanceTo(coordinate);
                                    if (distance_1 < maxRoadAttachDistance && (segment.isFacility() || (nextSegment && nextSegment.isFacility()))) {
                                        this._locationMng.setPosition(floorId, segment.getEnd(), duration);
                                        this._mapMoveToCenter(segment.getEnd(), duration);
                                        this._fireARChange(floorId, segment.getEnd());
                                        this._deviateNum = 0;
                                    }
                                    else {
                                        this._deviateNum += 1;
                                        this._locationMng.setPosition(floorId, coordinate, duration);
                                    }
                                    if (this._deviateNum >= this._options.deviateReInitNum) {
                                        this._reInitNavi(floorId, coordinate, isOutdoor);
                                        this.m_lastZoomBeforeCrossing = this._mapView.getZoom();
                                        this.m_newZoom = this.m_generalNaviZoom;
                                        this._mapMoveToCenter(coordinate, duration);
                                        this._fireARChange(floorId, coordinate);
                                        this._deviateNum = 0;
                                    }
                                    return [2];
                                }
                            }
                            this._otherFloorNum = 0;
                            strNaviState = 'Unknown';
                            closestIndexArray = this._dynamicMng.getClosestCoordArray(floorId, coordinate);
                            if (closestIndexArray.length == 0 && bReInitRoute == false) ;
                            closestIndex = 0;
                            if (this._dynamicMng.crtIndex == -1 && closestIndexArray.length > 0) {
                                closestIndex = closestIndexArray[0].index;
                            }
                            distance = 0;
                            closestCoord = new Point(0, 0);
                            if (closestIndexArray.length > 0 && closestIndexArray[0].distance <= maxRoadAttachDistance) {
                                this.m_bias++;
                                this.m_bias = Math.min(3, this.m_bias);
                                if (this._dynamicMng.crtIndex == closestIndexArray[0].index) {
                                    this.m_routeTrustness++;
                                    this.m_routeTrustness = Math.min(3, this.m_routeTrustness);
                                    strNaviState = 'Following';
                                    curDisToEnd = this._dynamicMng.distanceToEnd(closestIndexArray[0].index, closestIndexArray[0].coordinate);
                                    if (curDisToEnd <= this.m_lastDisToEnd) {
                                        closestIndex = closestIndexArray[0].index;
                                        strNaviState = 'Following';
                                        closestCoord = closestIndexArray[0].coordinate;
                                        distance = closestIndexArray[0].distance;
                                        this.m_fowardBias++;
                                        this.m_fowardBias = Math.min(this.m_maxFowardBias, this.m_fowardBias);
                                        this.m_lastDisToEnd = curDisToEnd;
                                        if (closestIndexArray[0].endPoint.distanceTo(closestCoord) <= this.m_forwardCrossingDis
                                            || closestIndexArray[0].startPoint.distanceTo(closestCoord) <= this.m_backCrossingDis) {
                                            closestIndex = closestIndexArray[0].index;
                                            strNaviState = 'Crossing';
                                            closestCoord = closestIndexArray[0].coordinate;
                                            distance = closestIndexArray[0].distance;
                                            if (this.m_lastNaviState != 'Crossing') {
                                                this.m_lastZoomBeforeCrossing = this._mapView.getZoom();
                                                mapView = this._mapView;
                                                if (mapView) {
                                                    this.m_newZoom = this.m_crossingNaviZoom;
                                                    this._mapView.easeTo({
                                                        zoom: this.m_crossingNaviZoom,
                                                        duration: 1000,
                                                        center: closestCoord,
                                                    });
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        if (curDisToEnd - this.m_lastDisToEnd > 15) {
                                            this.m_fowardBias = 0;
                                            closestIndex = closestIndexArray[0].index;
                                            strNaviState = 'Following';
                                            closestCoord = closestIndexArray[0].coordinate;
                                            distance = closestIndexArray[0].distance;
                                            this.m_lastDisToEnd = curDisToEnd;
                                        }
                                        else {
                                            closestCoord = this.m_lastCoord;
                                            closestIndex = this.m_lastIndex;
                                            distance = this.m_lastDistance;
                                            if (closestIndexArray[0].endPoint.distanceTo(closestCoord) <= this.m_forwardCrossingDis
                                                || closestIndexArray[0].startPoint.distanceTo(closestCoord) <= this.m_backCrossingDis) {
                                                strNaviState = 'Crossing';
                                                this.m_newZoom = this.m_crossingNaviZoom;
                                            }
                                            else {
                                                strNaviState = 'Unknown';
                                                this.m_newZoom = this.m_generalNaviZoom;
                                            }
                                        }
                                    }
                                }
                                else {
                                    this.m_routeTrustness--;
                                    this.m_nearRouteTrustness++;
                                    this.m_nearRouteTrustness = Math.min(3, this.m_nearRouteTrustness);
                                    if (this.m_routeTrustness < 0) {
                                        if (closestIndexArray[0].index == this._dynamicMng.crtIndex + 1) {
                                            closestIndex = closestIndexArray[0].index;
                                            strNaviState = 'Crossing';
                                            closestCoord = closestIndexArray[0].startPoint;
                                            distance = 0;
                                            this.m_newZoom = this.m_generalNaviZoom;
                                            if (this.m_lastNaviState != 'Crossing') {
                                                this.m_lastZoomBeforeCrossing = this._mapView.getZoom();
                                                mapView = this._mapView;
                                                if (mapView) {
                                                    this.m_newZoom = this.m_generalNaviZoom;
                                                    this._mapView.easeTo({
                                                        zoom: this.m_crossingNaviZoom,
                                                        duration: 1000,
                                                        center: closestCoord,
                                                    });
                                                }
                                            }
                                        }
                                        else {
                                            curDisToEnd = this._dynamicMng.distanceToEnd(closestIndexArray[0].index, closestIndexArray[0].coordinate);
                                            if (curDisToEnd <= this.m_lastDisToEnd) {
                                                closestIndex = closestIndexArray[0].index;
                                                closestCoord = closestIndexArray[0].coordinate;
                                                distance = closestIndexArray[0].distance;
                                                strNaviState = 'RouteChange';
                                            }
                                            else if (curDisToEnd - this.m_lastDisToEnd >= 15) {
                                                this.m_fowardBias = 0;
                                                closestIndex = closestIndexArray[0].index;
                                                strNaviState = 'Following';
                                                closestCoord = closestIndexArray[0].coordinate;
                                                distance = closestIndexArray[0].distance;
                                                this.m_lastDisToEnd = curDisToEnd;
                                            }
                                            else {
                                                closestCoord = this.m_lastCoord;
                                                closestIndex = this.m_lastIndex;
                                                distance = this.m_lastDistance;
                                                if (closestIndexArray[0].endPoint.distanceTo(closestCoord) <= this.m_forwardCrossingDis
                                                    || closestIndexArray[0].startPoint.distanceTo(closestCoord) <= this.m_backCrossingDis) {
                                                    strNaviState = 'Crossing';
                                                    this.m_newZoom = this.m_crossingNaviZoom;
                                                }
                                            }
                                        }
                                        this.m_routeTrustness = this.m_nearRouteTrustness;
                                        this.m_nearRouteTrustness = 0;
                                    }
                                    else {
                                        if (closestIndexArray[0].index == this._dynamicMng.crtIndex) {
                                            curDisToEnd = this._dynamicMng.distanceToEnd(closestIndexArray[0].index, closestIndexArray[0].coordinate);
                                            if (curDisToEnd <= this.m_lastDisToEnd) {
                                                closestIndex = closestIndexArray[0].index;
                                                strNaviState = 'Following';
                                                closestCoord = closestIndexArray[0].coordinate;
                                                distance = closestIndexArray[0].distance;
                                                this.m_fowardBias++;
                                                this.m_fowardBias = Math.min(3, this.m_fowardBias);
                                                this.m_lastDisToEnd = curDisToEnd;
                                                if (closestIndexArray[0].endPoint.distanceTo(closestCoord) <= this.m_forwardCrossingDis
                                                    || closestIndexArray[0].startPoint.distanceTo(closestCoord) <= this.m_backCrossingDis) {
                                                    strNaviState = 'Crossing';
                                                    this.m_newZoom = this.m_crossingNaviZoom;
                                                    if (this.m_lastNaviState != 'Crossing') {
                                                        this.m_lastZoomBeforeCrossing = this._mapView.getZoom();
                                                        mapView = this._mapView;
                                                        if (mapView) {
                                                            this.m_newZoom = this.m_generalNaviZoom;
                                                            this._mapView.easeTo({
                                                                zoom: this.m_crossingNaviZoom,
                                                                duration: 1000,
                                                                center: closestCoord,
                                                            });
                                                        }
                                                    }
                                                }
                                            }
                                            else {
                                                if (curDisToEnd - this.m_lastDisToEnd > 15) {
                                                    this.m_fowardBias = 0;
                                                    closestIndex = closestIndexArray[0].index;
                                                    strNaviState = 'Following';
                                                    closestCoord = closestIndexArray[0].coordinate;
                                                    distance = closestIndexArray[0].distance;
                                                    this.m_lastDisToEnd = curDisToEnd;
                                                }
                                                else {
                                                    closestCoord = this.m_lastCoord;
                                                    closestIndex = this.m_lastIndex;
                                                    distance = this.m_lastDistance;
                                                    if (closestIndexArray[0].endPoint.distanceTo(closestCoord) <= this.m_forwardCrossingDis
                                                        || closestIndexArray[0].startPoint.distanceTo(closestCoord) <= this.m_backCrossingDis) {
                                                        strNaviState = 'Crossing';
                                                        this.m_newZoom = this.m_crossingNaviZoom;
                                                    }
                                                    else {
                                                        strNaviState = 'Unknown';
                                                        this.m_newZoom = this.m_generalNaviZoom;
                                                    }
                                                }
                                            }
                                        }
                                        else {
                                            if (closestIndexArray[0].index == this._dynamicMng.crtIndex + 1) {
                                                closestIndex = closestIndexArray[0].index;
                                                strNaviState = 'Crossing';
                                                closestCoord = closestIndexArray[0].startPoint;
                                                distance = 0;
                                                if (this.m_lastNaviState != 'Crossing') {
                                                    this.m_lastZoomBeforeCrossing = this._mapView.getZoom();
                                                    mapView = this._mapView;
                                                    if (mapView) {
                                                        this.m_newZoom = this.m_crossingNaviZoom;
                                                        this._mapView.easeTo({
                                                            zoom: this.m_crossingNaviZoom,
                                                            duration: 1000,
                                                            center: closestCoord,
                                                        });
                                                    }
                                                }
                                            }
                                            else {
                                                closestIndex = this._dynamicMng.crtIndex;
                                                strNaviState = 'Following';
                                                bFind = false;
                                                for (i = 0; i < closestIndexArray.length; i++) {
                                                    if (closestIndexArray[i].index == this._dynamicMng.crtIndex) {
                                                        closestCoord = closestIndexArray[i].coordinate;
                                                        distance = closestIndexArray[i].distance;
                                                        bFind = true;
                                                        break;
                                                    }
                                                }
                                                if (bFind == false) {
                                                    closestCoord = closestIndexArray[0].coordinate;
                                                    distance = closestIndexArray[0].distance;
                                                    closestIndex = closestIndexArray[0].index;
                                                }
                                                curDisToEnd = this._dynamicMng.distanceToEnd(closestIndex, closestCoord);
                                                if (curDisToEnd - this.m_lastDisToEnd >= 0 && curDisToEnd - this.m_lastDisToEnd < 15) {
                                                    closestCoord = this.m_lastCoord;
                                                    closestIndex = this.m_lastIndex;
                                                    distance = this.m_lastDistance;
                                                    if (closestIndexArray[0].endPoint.distanceTo(closestCoord) <= this.m_forwardCrossingDis
                                                        || closestIndexArray[0].startPoint.distanceTo(closestCoord) <= this.m_backCrossingDis) {
                                                        strNaviState = 'Crossing';
                                                        this.m_newZoom = this.m_crossingNaviZoom;
                                                    }
                                                    else {
                                                        strNaviState = 'Unknown';
                                                        this.m_newZoom = this.m_generalNaviZoom;
                                                    }
                                                }
                                                else if (curDisToEnd - this.m_lastDisToEnd >= 15) {
                                                    strNaviState = 'Unknown';
                                                    this.m_newZoom = this.m_generalNaviZoom;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                this.m_bias--;
                                if (this.m_bias < 0) {
                                    bReInitRoute = true;
                                    this.m_bias = 0;
                                    strNaviState = 'REcal';
                                }
                                else {
                                    strNaviState = 'NaviStart';
                                    if (closestIndexArray.length > 0) {
                                        closestCoord = closestIndexArray[0].coordinate;
                                        closestIndex = closestIndexArray[0].index;
                                        distance = closestIndexArray[0].distance;
                                    }
                                    else {
                                        closestCoord = coordinate;
                                        closestIndex = 0;
                                        distance = 0;
                                    }
                                }
                            }
                            if (this.m_lastNaviState == 'Crossing' && strNaviState != 'Crossing' && strNaviState != 'Unknown') {
                                mapView = this._mapView;
                                if (mapView) {
                                    this.m_newZoom = this.m_generalNaviZoom;
                                    this._mapView.easeTo({
                                        zoom: this.m_generalNaviZoom,
                                        duration: 1000,
                                    });
                                }
                            }
                            this.m_lastNaviState = strNaviState;
                            if (this._dynamicMng && this._dynamicMng._segments) {
                                for (i = 0; i < 3 && i < closestIndexArray.length; i++) {
                                    if (closestIndexArray[i].distance == null || closestIndexArray[i].distance == undefined) {
                                        closestIndexArray[i].distance = 0;
                                    }
                                    if (closestIndexArray[i].distance <= maxRoadAttachDistance) {
                                        routeIndex = closestIndexArray[i].index;
                                        if (routeIndex >= 0 && routeIndex < this._dynamicMng._segments.length) {
                                            this._dynamicMng._segments[routeIndex].m_bias++;
                                            this._dynamicMng._segments[routeIndex].m_bias = Math.min(3, this._dynamicMng._segments[routeIndex].m_bias);
                                        }
                                    }
                                }
                            }
                            if (closestIndexArray.length > 0) {
                                this.DebugNavi(this.m_bias, this.m_routeTrustness, this.m_nearRouteTrustness, closestIndex, closestIndexArray[0].distance, maxRoadAttachDistance, strNaviState, this.m_lastDisToEnd);
                            }
                            else {
                                this.DebugNavi(this.m_bias, this.m_routeTrustness, this.m_nearRouteTrustness, closestIndex, 9999, maxRoadAttachDistance, strNaviState, this.m_lastDisToEnd);
                            }
                            if (!bReInitRoute) return [3, 8];
                            this._locationMng.setPosition(floorId, coordinate, duration);
                            this._fireARChange(floorId, coordinate);
                            this.m_lastZoomBeforeCrossing = this._mapView.getZoom();
                            this.m_newZoom = this.m_generalNaviZoom;
                            this._mapMoveToCenter(coordinate, duration);
                            return [4, this._reInitNavi(floorId, coordinate, isOutdoor)];
                        case 7:
                            _b.sent();
                            return [2];
                        case 8:
                            oldIndex = this._dynamicMng.crtIndex;
                            oldSegment = this._dynamicMng.crtSegment;
                            distanceToEnd = 0;
                            if (closestIndexArray.length > 0) {
                                distanceToEnd = this._dynamicMng.distanceToEnd(closestIndex, closestCoord);
                            }
                            else {
                                distanceToEnd = 9999;
                            }
                            if (distanceToEnd < this._options.maxHisNoticeDistance) {
                                this.fire('showHisNotice');
                            }
                            if (floorId !== this._lastFloor && oldSegment && oldSegment.isFacility()) {
                                segment = this._dynamicMng.getSegments()[oldIndex + 1];
                                if (!segment)
                                    return [2];
                                closestIndex = oldIndex + 1;
                                distance = 0;
                                closestCoord = segment.getStart();
                            }
                            this.m_lastIndex = closestIndex;
                            this.m_lastCoord = closestCoord;
                            this.m_lastDistance = distance;
                            this.m_lastDisToEnd = this._dynamicMng.distanceToEnd(closestIndex, closestCoord);
                            bDisplayPickMarker = this._mapView.getDisplayNaviPickMarker();
                            if (bDisplayPickMarker) {
                                this.setPickMarker(floorId, coordinate);
                            }
                            if (this._isSameFloor(floorId) && distanceToEnd <= this._options.maxDistanceArriving) {
                                this._locationMng.setPosition(floorId, coordinate, duration);
                                this._mapMoveToCenter(coordinate, duration);
                                this._fireNavigateEnd();
                                this._naviMng.setAllWalked();
                                this._fireARChange(floorId, coordinate);
                                mapView = this._mapView;
                                if (mapView) {
                                    this._mapView.easeTo({
                                        zoom: this.m_finishNaviZoom,
                                        duration: 1000,
                                    });
                                }
                                return [2];
                            }
                            this._lastDisToEnd = distanceToEnd;
                            if (this._isSameFloor(floorId) && distanceToEnd < this._options.maxDistanceArriveTip &&
                                !this._isTipEnd &&
                                floorId === this._dynamicMng.getEndFloor()) {
                                message = language.getType() === 'cn' ? this._options.beforeArriveTip : 'You are near to your desination';
                                this._tip(message);
                                this._audioProvider.playMessage(message);
                                this._isTipEnd = true;
                            }
                            this._locationMng.setPosition(floorId, closestCoord, duration);
                            this._naviMng.setWalked(floorId, closestCoord, closestIndex);
                            this._fireARChange(floorId, closestCoord);
                            isInFlow = this._locationMng && this._locationMng.isEnableFlow();
                            this._dynamicMng.findNearSegment(closestIndex, closestCoord, !this._isInInterrupt && !isInFlow);
                            info = this._dynamicMng.getMessageInNavi(false, this._canPlayLiftMsg && bChangeFloor == false, false, floorId, true);
                            isInBuildingMsg = info.isInBuildingMsg;
                            this._fireNavigatingInfo(__assign$1(__assign$1({}, info), { distanceToEnd: distanceToEnd }));
                            LogMgr$1.log('zhengli4 playMessage isInBuildingMsg:' + isInBuildingMsg
                                + ' Message:' + info.message);
                            if (info.isLeftMsg == true) {
                                this._canPlayLiftMsg = false;
                            }
                            if (oldIndex !== this._dynamicMng.crtIndex) {
                                if (isInBuildingMsg == false) {
                                    this._audioProvider.playMessage(info.message, bChangeFloor || isInBuildingMsg);
                                    this._isPlayWill = false;
                                }
                            }
                            else if (info.isWillChange && !this._isPlayWill || info.isLeftMsg) {
                                this._audioProvider.playMessage(info.message, bChangeFloor || isInBuildingMsg || info.isLeftMsg);
                                this._isPlayWill = true;
                            }
                            if (!(this._dynamicMng.crtRotate !== this._mapView.getRotate())) return [3, 10];
                            this._isMapRotate = true;
                            return [4, sleep(this._getRotateDuration(this._dynamicMng.crtRotate) + 16)];
                        case 9:
                            _b.sent();
                            this._isMapRotate = false;
                            _b.label = 10;
                        case 10:
                            !this._isMapRotate && this._mapMoveToCenter(closestCoord, duration);
                            return [3, 12];
                        case 11:
                            if (distance < maxDistanceReInitNavi) {
                                message = language.get('deviateTip');
                                this._audioProvider.playMessage(message);
                                this._fireNavigatingInfo({ message: message, distanceToEnd: distanceToEnd, isWillChange: false });
                                this._locationMng.setPosition(floorId, coordinate, duration);
                                this._fireARChange(floorId, coordinate);
                                this._mapMoveToCenter(coordinate, duration);
                            }
                            _b.label = 12;
                        case 12:
                            this.fire('navigating');
                            return [2];
                    }
                });
            });
        };
        NewNavigate.prototype._isSameFloor = function (floorId) {
            if (!this._naviMng)
                return false;
            var floorOrder = this._naviMng.getFloorOrder();
            return floorOrder[floorOrder.length - 1] === floorId;
        };
        NewNavigate.prototype._getRotateDuration = function (rotate) {
            if (!this._mapView || typeof rotate !== 'number')
                return 0;
            var startRotate = this._mapView.getRotate() || 0;
            var targetRotate = Camera.normalizeRotate(rotate, startRotate);
            var delta = Math.abs(targetRotate - startRotate);
            return delta / this._options.rotateSpeed * 1000 + 16;
        };
        NewNavigate.prototype._mapMoveToCenter = function (center, duration) {
            if (!this._mapView)
                return;
            !this._isInInterrupt &&
                this._navigateViewType === 'first' &&
                this._mapView.easeTo({
                    center: center,
                    duration: duration,
                    easing: 'linear',
                    offset: this._options.navigatingOffset,
                    zoom: this.m_newZoom,
                });
        };
        NewNavigate.prototype._isCanReInitNavi = function () {
            LogMgr$1.log('NewNavigate.ts _isCanReInitNavi ' + this._options.reInitTimeDiff);
            return Date.now() - this._reInitNaviTime > this._options.reInitTimeDiff * 1000;
        };
        NewNavigate.prototype._reInitNavi = function (floorId, coordinate, isOutdoor) {
            return __awaiter(this, void 0, void 0, function () {
                var endMarker, endPosition, message, startBounds;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this._lastReInitNaviPoint && this._lastReInitNaviPoint.equal(coordinate))
                                return [2];
                            if (!this._dynamicMng || !this._naviMng || !this._isCanReInitNavi())
                                return [2];
                            LogMgr$1.log('NewNavigate.ts _reInitNavi 1 ' + floorId + ' ' + coordinate + ' ' + isOutdoor);
                            this._reInitNaviTime = Date.now();
                            this.setStartMarker(floorId, coordinate);
                            this._lastReInitNaviPoint = coordinate.clone();
                            endMarker = this._markerMng.getMarker('end');
                            if (endMarker == null || endMarker == undefined) {
                                this.setEndMarker(this.m_lastEndFloorId, this.m_lastEndCoord);
                                endMarker = this._markerMng.getMarker('end');
                                if (endMarker == null || endMarker == undefined) {
                                    return [2];
                                }
                            }
                            LogMgr$1.log('NewNavigate.ts _reInitNavi 2 ');
                            endPosition = endMarker.getPosition();
                            if (!endPosition)
                                return [2];
                            LogMgr$1.log('NewNavigate.ts _reInitNavi 3 ');
                            message = language.getType() === 'cn' ? this._options.reInitTip : 'You are off course and are replanning your route';
                            this._audioProvider.playMessage(message, false);
                            this._tip(message);
                            delete this._lastDisToEnd;
                            LogMgr$1.log('NewNavigate.ts _reInitNavi 4');
                            return [4, this._renderNavi({ floorId: floorId, coordinate: coordinate }, endPosition, true)];
                        case 1:
                            _a.sent();
                            LogMgr$1.log('NewNavigate.ts _reInitNavi 5');
                            return [4, this._dynamicNavigate(floorId, coordinate, 500, isOutdoor)];
                        case 2:
                            _a.sent();
                            this.fire('routeTypeChange', true);
                            startBounds = this._naviMng.getNaviBounds(false);
                            LogMgr$1.log('NewNavigate.ts reinitNavi ' + startBounds);
                            if (startBounds) {
                                this._options.fitPadding;
                                LogMgr$1.log('NewNavigate.ts reinitNavi 2' + this.m_naviMapViewStartZoom);
                            }
                            return [2];
                    }
                });
            });
        };
        NewNavigate.prototype._resetStatus = function () {
            this._status = 'init';
            this._isPlayWill = false;
            this._isTipEnd = false;
            this._simIndex = 0;
            delete this._lastDisToEnd;
            this._isInInterrupt = false;
            if (this._touchTimer) {
                clearTimeout(this._touchTimer);
                delete this._touchTimer;
            }
            if (this._shortestRouteTimer) {
                clearTimeout(this._shortestRouteTimer);
                delete this._shortestRouteTimer;
            }
        };
        NewNavigate.prototype._toggleControl = function (isShow) {
            if (!this._mapView)
                return;
            var hideControlByNavigating = this._options.hideControlByNavigating;
            for (var i = 0; i < hideControlByNavigating.length; i += 1) {
                var control = this._mapView.getControl(hideControlByNavigating[i]);
                if (control) {
                    isShow ? control.show() : control.hide();
                }
            }
        };
        NewNavigate.prototype._tip = function (msg) {
            if (!this._options.autoTip)
                return;
            this.fire('tip', msg);
            tip(msg);
        };
        NewNavigate.prototype._fireNavigateEnd = function () {
            if (!this._mapView)
                return;
            this.fire('navigateEnd');
            this._resetStatus();
            this._status = 'SimulateNaviEnd';
            this._toggleControl(true);
            this._locationMng && this._locationMng.endNavigate();
            this._audioProvider.playMessage(language.get('endTip'), true);
        };
        NewNavigate.prototype.navigateComplete = function () {
            this.removeLayers();
        };
        NewNavigate.prototype.navigateCancel = function () {
            this._toggleControl(true);
            this._resetStatus();
            this._simAnimator && this._simAnimator.stop();
            this._mapView && this._mapView.stop();
            this._audioProvider.close();
            if (this._locationMng) {
                this._locationMng.show();
                this._locationMng.endNavigate();
            }
            this.removeLayers();
            this.fire('navigateCancel');
        };
        NewNavigate.prototype.exitNavigate = function () {
            return __awaiter(this, void 0, void 0, function () {
                var floorId, locPosition;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._mapView || !this._dynamicMng || !this._naviMng)
                                return [2];
                            this._resetStatus();
                            this._toggleControl(true);
                            this.removeMarker('sim');
                            this._simAnimator && this._simAnimator.stop();
                            this._mapView && this._mapView.stop();
                            this._audioProvider.close();
                            floorId = this._dynamicMng.getStartFloor();
                            if (this._locationMng) {
                                this._locationMng.show();
                                this._locationMng.endNavigate();
                                locPosition = this._locationMng.getPosition();
                                floorId = locPosition ? locPosition.floorId : floorId;
                            }
                            if (!(floorId !== this._mapView.currentFloor)) return [3, 3];
                            return [4, this._mapView.setCurrentFloor(floorId)];
                        case 1:
                            _a.sent();
                            return [4, sleep(this._options.changeFloorTime)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            this._naviMng.setIsShowMultiline(true);
                            this._dynamicMng && this._dynamicMng.resetTipMovePhone();
                            this.fire('exitNavigate');
                            return [2];
                    }
                });
            });
        };
        NewNavigate.prototype.fitNaviLine = function (mode) {
            if (mode === void 0) { mode = false; }
            if (!this._naviMng || !this._mapView || this._mapView.getViewType() === 'multiple')
                return;
            var fitPadding = this._options.fitPadding;
            var bounds = this._naviMng.getNaviBounds(mode);
            var zoom;
            bounds && (zoom = this._mapView.fitBounds(bounds, fitPadding));
            return zoom;
        };
        NewNavigate.prototype.setLocationManager = function (locationMng) {
            this._locationMng = locationMng;
        };
        NewNavigate.prototype.removeLocationManager = function () {
            delete this._locationMng;
        };
        NewNavigate.prototype.getStatus = function () {
            return this._status;
        };
        NewNavigate.prototype._renderNavi = function (startPosition, endPosition, isReinitNavi) {
            if (isReinitNavi === void 0) { isReinitNavi = false; }
            return __awaiter(this, void 0, void 0, function () {
                var features, error_1, msg;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this._shortestRouteTimer) {
                                clearTimeout(this._shortestRouteTimer);
                                delete this._shortestRouteTimer;
                            }
                            if (!this._naviMng)
                                return [2];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, 4, 5]);
                            this._options.autoTip && loading();
                            this._isInitNavi = true;
                            return [4, this._naviMng.renderNavi(startPosition, endPosition)];
                        case 2:
                            _a.sent();
                            features = this._naviMng.getActiveRoute();
                            if (this._dynamicMng && features) {
                                this._dynamicMng.init(features);
                            }
                            this._options.isAddFacilityTip && this.addFacilityTip();
                            return [3, 5];
                        case 3:
                            error_1 = _a.sent();
                            LogMgr$1.log('鑾峰彇 naviLine 鏃讹紝缃戠粶鍙戠敓寮傚父...');
                            if (isReinitNavi && this.getActiveRouteType() !== 'shortest') {
                                this._shortestRouteTimer = window.setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4, this.setActiveRoute('shortest')];
                                            case 1:
                                                _a.sent();
                                                return [2];
                                        }
                                    });
                                }); }, 1000);
                            }
                            else {
                                LogMgr$1.log(error_1);
                                msg = error_1.message;
                                if (msg == null || msg == undefined || msg == '') {
                                    msg = '褰撳墠缃戠粶寮傚父锛岃妫€鏌ョ綉缁滃悗閲嶈瘯';
                                }
                                this._tip(language.getType() === 'cn' ? msg : 'Navigate server maintenance is in process');
                                LogMgr$1.log('_renderNavi 1 else');
                                this._options.autoTip && hideLoading();
                                this._isInitNavi = false;
                                throw error_1;
                            }
                            return [3, 5];
                        case 4:
                            LogMgr$1.log('鑾峰彇 naviLine 鏃讹紝缃戠粶鍙戠敓寮傚父,finally 浠ｇ爜');
                            this._options.autoTip && hideLoading();
                            this._isInitNavi = false;
                            return [7];
                        case 5:
                            this.fire('renderNavi');
                            return [2];
                    }
                });
            });
        };
        NewNavigate.prototype.setPickMarker = function (floorId, coordinate) {
            this.setMarker('pick', floorId, coordinate);
            this.fire('setPickMarker', { floorId: floorId, coordinate: coordinate });
        };
        NewNavigate.prototype.setStartMarker = function (floorId, coordinate, startMarkWithoutDir) {
            if (startMarkWithoutDir === void 0) { startMarkWithoutDir = false; }
            if (startMarkWithoutDir) {
                this.setMarker('startWithoutDir', floorId, coordinate);
            }
            else {
                this.setMarker('start', floorId, coordinate);
            }
        };
        NewNavigate.prototype.setEndMarker = function (floorId, coordinate) {
            this.m_lastEndFloorId = floorId;
            this.m_lastEndCoord = coordinate;
            this.setMarker('end', floorId, coordinate);
        };
        NewNavigate.prototype._lngLatToMercator = function (_a) {
            var lng = _a[0], lat = _a[1];
            var x = Number(lng) * 20037508.34 / 180;
            var y = Math.log(Math.tan((90 + Number(lat)) * Math.PI / 360)) / (Math.PI / 180);
            y = y * 20037508.34 / 180;
            return { x: x, y: y };
        };
        NewNavigate.prototype.setOutdoorStartMarker = function (floorId, LatLong) {
            var startMercator = this._lngLatToMercator(LatLong);
            this.setMarker('outdoorStart', floorId, startMercator);
            this.updateMarker('start', 'indoorStart');
        };
        NewNavigate.prototype.setOutdoorEndMarker = function (floorId, LatLong) {
            var endMercator = this._lngLatToMercator(LatLong);
            this.setMarker('outdoorEnd', floorId, endMercator);
        };
        NewNavigate.prototype.updateMarker = function (oldName, newName) {
            this._markerMng.updateMarker(oldName, newName);
        };
        NewNavigate.prototype.removeMarker = function (name) {
            this._markerMng.removeMarker(name);
        };
        NewNavigate.prototype.simulateNavigate = function () {
            return __awaiter(this, void 0, void 0, function () {
                var simSpeed, startFloor, routes, segments, info;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            simSpeed = this._options.simSpeed;
                            if (this._navigateSpeed) {
                                this._navigateSpeed = simSpeed;
                            }
                            if (this._options.isShowNaviProgress) {
                                (!this._naviProgress) && this.addProgress();
                            }
                            if (!this._mapView || !this._naviMng || !this._dynamicMng)
                                return [2];
                            if (!this._naviMng.hasNavi()) {
                                console.error('璇峰厛瑙勫垝璺嚎');
                                return [2];
                            }
                            this._status = 'simulateNavigate';
                            if (this._options.isShowNaviProgress) {
                                setTimeout(function () {
                                    _this.setCountdownTimer();
                                }, 3000);
                            }
                            this._preNavigating();
                            this._locationMng && this._locationMng.hide();
                            startFloor = this._dynamicMng.getStartFloor();
                            routes = this._naviMng.getRoutes();
                            this.setMarker('sim', startFloor, routes[0].line[0]);
                            if (!(startFloor !== this._mapView.currentFloor)) return [3, 3];
                            return [4, this._mapView.setCurrentFloor(startFloor)];
                        case 1:
                            _a.sent();
                            return [4, sleep(this._options.changeFloorTime)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            segments = this._dynamicMng.getSegments();
                            this._dynamicMng.findNearSegment(0, routes[0].line[0], false);
                            info = this._dynamicMng.getMessageInNavi(false);
                            this._fireNavigatingInfo(__assign$1(__assign$1({}, info), { distanceToEnd: this._dynamicMng.getWholeDistance() }));
                            this._audioProvider.playMessage(language.get('simStart') + "," + info.message);
                            this._navigateViewType === 'first' ? this._mapView.easeTo({
                                center: routes[0].line[0],
                                zoom: this._options.navigatingZoom,
                                pitch: this._options.navigatingPitch,
                                rotate: segments[0].getRotate(),
                                duration: 3000,
                                offset: this._options.navigatingOffset,
                                complete: function () { return _this._simulate(); },
                            }) : this._simulate();
                            return [2];
                    }
                });
            });
        };
        NewNavigate.prototype.GetRouteArrayData = function () {
            if (this._naviMng == null || this._naviMng == undefined) {
                return null;
            }
            return this._naviMng.GetRouteArrayData();
        };
        NewNavigate.prototype._simulate = function () {
            var _this = this;
            if (!this._naviMng)
                return;
            if (this._status !== 'simulateNavigate')
                return;
            var routes = this._naviMng.getRoutes();
            var simSpeed = this._options.simSpeed;
            console.log('Navigate.ts _simulate');
            MapView$1.GetInstance().OnClick2d3d();
            var animate = function () { return __awaiter(_this, void 0, void 0, function () {
                var oldInterruptNum, endPoint, simMarker, coordinate, startPoint, distance, time, lastUpdateTime, thirdViewRotate, info, isInBuildingMsg;
                var _this = this;
                return __generator(this, function (_a) {
                    if (this._status !== 'simulateNavigate' || !this._dynamicMng || !this._mapView)
                        return [2];
                    oldInterruptNum = this._interruptNum;
                    this._simAnimator && this._simAnimator.stop();
                    endPoint = routes[this._simIndex].line[1];
                    simMarker = this._markerMng.getMarker('sim');
                    coordinate = simMarker.getPosition().coordinate;
                    startPoint = new Point(coordinate.x, coordinate.y);
                    distance = startPoint.distanceTo(endPoint);
                    if (!this._navigateSpeed) {
                        time = Math.max(distance / simSpeed * 1000, 16);
                    }
                    else {
                        time = Math.max(distance / this._navigateSpeed * 1000, 16);
                    }
                    lastUpdateTime = Date.now();
                    this._dynamicMng.findNearSegment(this._simIndex, startPoint, this._navigateViewType === 'first', true);
                    thirdViewRotate = this._dynamicMng.crtSegment.getRotate();
                    if (this._mapView && this._mapView.getRotate()) {
                        thirdViewRotate = this._dynamicMng.crtSegment.getRotate() - this._mapView.getRotate();
                    }
                    simMarker.setRotate(this._navigateViewType === 'first' ? 0 : thirdViewRotate);
                    if (this._dynamicMng.crtRotate !== this._mapView.getRotate() && this._navigateViewType === 'first') ;
                    if (this._interruptNum !== oldInterruptNum)
                        return [2];
                    info = this._dynamicMng.getMessageInNavi(false, this._canPlayLiftMsg, false, '', true);
                    isInBuildingMsg = info.isInBuildingMsg;
                    if (isInBuildingMsg == false && info.isLeftMsg == false && info.isBezier == false) {
                        this._audioProvider.playMessage(info.message, false);
                    }
                    this._simOldIndex = this._simIndex;
                    this._simAnimator = new Animator().ofObject(startPoint, endPoint, time);
                    this._simAnimator.easing('linear');
                    this._simAnimator.on('update', function (e) { return __awaiter(_this, void 0, void 0, function () {
                        var value, floorId, info_1, distanceToEnd, isInBuildingMsg_1;
                        return __generator(this, function (_a) {
                            value = e;
                            if (this._status !== 'simulateNavigate' ||
                                !this._naviMng || !this._dynamicMng || !this._mapView)
                                return [2];
                            floorId = this._mapView.currentFloor;
                            this.setMarker('sim', floorId, value);
                            if (this._navigateViewType === 'first') {
                                this._naviMng.setWalked(floorId, value, this._simIndex);
                                this._mapView.setCenterByOffset(value, this._options.navigatingOffset);
                            }
                            if (Date.now() - lastUpdateTime > this._options.simNaviInfoInterval) {
                                this._dynamicMng.findNearSegment(this._simIndex, new Point(value.x, value.y), false, true);
                                info_1 = this._dynamicMng.getMessageInNavi(false, this._canPlayLiftMsg, false, '', true);
                                distanceToEnd = this._dynamicMng.distanceToEnd(this._simIndex, value);
                                this._fireNavigatingInfo(__assign$1(__assign$1({}, info_1), { distanceToEnd: distanceToEnd }));
                                if (info_1.isLeftMsg == true) {
                                    this._canPlayLiftMsg = false;
                                }
                                isInBuildingMsg_1 = info_1.isInBuildingMsg;
                                LogMgr$1.log('zhengli5 playMessage isInBuildingMsg:' + isInBuildingMsg_1
                                    + ' Message:' + info_1.message
                                    + ' Info.isWillChange:' + info_1.isWillChange
                                    + ' this._isPlayWill:' + this._isPlayWill);
                                if ((info_1.isWillChange && !this._isPlayWill && info_1.isBezier == false)
                                    || info_1.isLeftMsg) {
                                    this._audioProvider.playMessage(info_1.message, isInBuildingMsg_1 || info_1.isLeftMsg);
                                    this._isPlayWill = true;
                                }
                                lastUpdateTime = Date.now();
                            }
                            return [2];
                        });
                    }); }).on('complete', function () { return __awaiter(_this, void 0, void 0, function () {
                        var info_2, distanceToEnd, isInBuildingMsg_2, info_3, nextPoint, sleepDuration;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    delete this._simAnimator;
                                    if (this._status !== 'simulateNavigate' ||
                                        !this._mapView || !this._dynamicMng || !this._naviMng)
                                        return [2];
                                    this._simIndex += 1;
                                    if (!routes[this._simIndex]) return [3, 5];
                                    if (!(routes[this._simIndex].floor === this._mapView.currentFloor)) return [3, 1];
                                    this._dynamicMng.findNearSegment(this._simIndex - 1, endPoint, this._navigateViewType === 'first', true);
                                    info_2 = this._dynamicMng.getMessageInNavi(false, this._canPlayLiftMsg, false, '', false);
                                    distanceToEnd = this._dynamicMng.distanceToEnd(this._simIndex - 1, endPoint);
                                    this._fireNavigatingInfo(__assign$1(__assign$1({}, info_2), { distanceToEnd: distanceToEnd }));
                                    isInBuildingMsg_2 = info_2.isInBuildingMsg;
                                    LogMgr$1.log('zhengli6 playMessage isInBuildingMsg:' + isInBuildingMsg_2
                                        + ' Message:' + info_2.message);
                                    if (info_2.isLeftMsg == true) {
                                        this._canPlayLiftMsg = false;
                                    }
                                    if ((info_2.isWillChange && !this._isPlayWill && info_2.isBezier == false)
                                        || info_2.isLeftMsg) {
                                        this._audioProvider.playMessage(info_2.message, isInBuildingMsg_2 || info_2.isLeftMsg);
                                        this._isPlayWill = true;
                                    }
                                    return [3, 4];
                                case 1: return [4, this._mapView.setCurrentFloor(routes[this._simIndex].floor)];
                                case 2:
                                    _a.sent();
                                    this._canPlayLiftMsg = true;
                                    info_3 = this._dynamicMng.getMessageInNavi(false, false, true, routes[this._simIndex].floor);
                                    LogMgr$1.log('zhengli SimChangeFloorMsg ' + info_3.message
                                        + ' bChangeFloor:' + true
                                        + ' floorId:' + routes[this._simIndex].floor);
                                    this._audioProvider.playMessage(info_3.message, true);
                                    return [4, sleep(this._options.changeFloorTime)];
                                case 3:
                                    _a.sent();
                                    if (this._status === 'simulateNavigate') {
                                        nextPoint = routes[this._simIndex].line[0];
                                        this._navigateViewType === 'first' && this._mapView.jumpTo({
                                            center: nextPoint,
                                            offset: this._options.navigatingOffset,
                                        });
                                        this.setMarker('sim', routes[this._simIndex].floor, nextPoint);
                                    }
                                    _a.label = 4;
                                case 4:
                                    sleepDuration = this._navigateViewType === 'first' ?
                                        this._getRotateDuration(this._dynamicMng.crtRotate) : 0;
                                    sleepDuration = 0;
                                    this._isNaviSleep = true;
                                    this._interruptNum === oldInterruptNum && sleep(sleepDuration).then(function () {
                                        if ((_this._simIndex + 1) !== routes.length) {
                                            _this._isNaviSleep = false;
                                            if (_this._options.isShowNaviProgress) {
                                                _this.setCountdownTimer();
                                            }
                                        }
                                        _this._interruptNum === oldInterruptNum && animate();
                                    });
                                    return [3, 6];
                                case 5:
                                    this.fire('simulateNavigateEnd');
                                    clearInterval(this._progressInter);
                                    this.destoryCountdownTime();
                                    this._audioProvider.playMessage(language.get('arriveTip'), true);
                                    this._resetStatus();
                                    this._toggleControl(true);
                                    this._locationMng && this._locationMng.show();
                                    this.removeMarker('sim');
                                    this._naviMng.setIsShowMultiline(true);
                                    _a.label = 6;
                                case 6:
                                    this._isPlayWill = false;
                                    return [2];
                            }
                        });
                    }); }).on('changeSpeed', function (e) {
                        animate();
                    }).start();
                    return [2];
                });
            }); };
            animate();
        };
        NewNavigate.prototype.setCountdownTimer = function () {
            return __awaiter(this, void 0, void 0, function () {
                var countdown, simSpeed, segments, distance, orginTime, time, nowSpeed, t;
                var _this = this;
                return __generator(this, function (_a) {
                    if (!this._options.isShowNaviProgress)
                        return [2];
                    if (document.getElementById('ngr-countDown')) {
                        document.getElementById('ngr-countDown').style.zIndex = 100001;
                    }
                    countdown = document.getElementById('ngr-process');
                    if (!countdown)
                        return [2];
                    if (!this._dynamicMng)
                        return [2];
                    simSpeed = this._options.simSpeed;
                    segments = this._dynamicMng.getSegments();
                    distance = 0;
                    segments.map(function (item, i) {
                        distance += item.getDistance();
                    });
                    orginTime = Math.max(distance / simSpeed * 100, 0);
                    time = 0;
                    nowSpeed = 0;
                    if (!this._navigateSpeed) {
                        if (this._interruptRestDistance) {
                            time = Math.max(this._interruptRestDistance / simSpeed * 100, 0);
                        }
                        else {
                            time = Math.max(distance / simSpeed * 100, 0);
                        }
                        nowSpeed = simSpeed;
                    }
                    else {
                        nowSpeed = this._navigateSpeed;
                        if (this._interruptRestDistance) {
                            time = Math.max(this._interruptRestDistance / this._navigateSpeed * 100, 0);
                            orginTime = Math.max(distance / this._navigateSpeed * 100, 0);
                        }
                        else {
                            time = Math.max(distance / this._navigateSpeed * 100, 0);
                        }
                    }
                    t = time;
                    this._progressInter = setInterval(function () {
                        t--;
                        var height = 100 - (t / orginTime) * 100 + '%';
                        var countDownHeight = 94 - (t / orginTime) * 100 + '%';
                        if (document.getElementById('ngr-process') && document.getElementById('ngr-countDown')) {
                            document.getElementById('ngr-process').style.height = height;
                            document.getElementById('ngr-countDown').style.bottom = countDownHeight;
                        }
                        if (_this._isInInterrupt || _this._isNaviSleep) {
                            _this._interruptRestTime = t;
                            if (!_this._navigateSpeed) {
                                _this._interruptRestDistance = nowSpeed * (_this._interruptRestTime) / 100;
                            }
                            else {
                                _this._interruptRestDistance = nowSpeed * (_this._interruptRestTime) / 100;
                            }
                            clearInterval(_this._progressInter);
                        }
                        if (t <= 0) {
                            _this._interruptRestTime = 0;
                            _this._interruptRestDistance = 0;
                            _this._navigateSpeed = 0;
                            _this._isNaviSleep = false;
                            clearInterval(_this._progressInter);
                            _this.destoryCountdownTime();
                        }
                    }, 10);
                    return [2];
                });
            });
        };
        NewNavigate.prototype.destoryCountdownTime = function () {
            if (!this._naviProgress)
                return;
            if (!this._mapView)
                return;
            var map = this._mapView.getContainer();
            map === null || map === void 0 ? void 0 : map.removeChild(this._naviProgress);
            this._progressInter && clearInterval(this._progressInter);
            delete this._naviProgress;
        };
        NewNavigate.prototype.addProgress = function () {
            return __awaiter(this, void 0, void 0, function () {
                var map;
                return __generator(this, function (_a) {
                    if (!this._mapView)
                        return [2];
                    this._naviProgress = document.createElement('div');
                    this._naviProgress.setAttribute('id', 'ngr-loading-status');
                    this._naviProgress.innerHTML = "     <div id=\"ngr-process\"></div>\n        <span class=\"ngr-start-loading\"></span>\n        <span class=\"ngr-end-loading\"></span>\n        <span id=\"ngr-countDown\"></span>";
                    map = this._mapView.getContainer();
                    map === null || map === void 0 ? void 0 : map.appendChild(this._naviProgress);
                    return [2];
                });
            });
        };
        NewNavigate.prototype.getSegments = function () {
            return this._dynamicMng ? this._dynamicMng.getSegments() : [];
        };
        NewNavigate.prototype.getCurSegment = function () {
            return this._dynamicMng ? this._dynamicMng.getCurSegment() : null;
        };
        NewNavigate.prototype._fireNavigatingInfo = function (info) {
            this.fire('navigatingInfo', info);
        };
        NewNavigate.prototype.setMarker = function (name, floorId, coordinate) {
            this._markerMng.setMarker(name, floorId, coordinate);
        };
        NewNavigate.prototype.hasNaviLine = function () {
            return this._naviMng && this._naviMng.hasNavi();
        };
        NewNavigate.prototype.getMarker = function (name) {
            var result = null;
            if (name == 'start') {
                result = this._markerMng.getMarker(name);
                if (result != null && result != undefined) {
                    return result;
                }
                else {
                    return this._markerMng.getMarker('startWithoutDir');
                }
            }
            else {
                return this._markerMng.getMarker(name);
            }
        };
        NewNavigate.prototype.openAudio = function () {
            this._audioProvider.open();
        };
        NewNavigate.prototype.closeAudio = function () {
            this._audioProvider.close();
        };
        NewNavigate.prototype.playMessage = function (msg) {
            this._audioProvider.playMessage(msg);
        };
        NewNavigate.prototype.setNavigatingStartFloor = function (floorId) {
            this._startNavigatingFloor = floorId;
        };
        NewNavigate.prototype.getNavigatingStartFloor = function () {
            return this._startNavigatingFloor;
        };
        NewNavigate.prototype.setPopStatus = function (status) {
            this._canPop = status;
        };
        NewNavigate.prototype.setIsPoping = function (status) {
            this._popStatus = status;
        };
        NewNavigate.prototype.setLocationIsStart = function (status) {
            this._locationIsStart = status;
        };
        NewNavigate.prototype.IsInNaviMode = function () {
            if (this._status == 'navigating'
                || this._status == 'simulateNavigate'
                || this._status == 'SimulateNaviEnd') {
                return true;
            }
            else {
                return false;
            }
        };
        NewNavigate.prototype.IsInSimulateMode = function () {
            if (this._status == 'simulateNavigate') {
                return true;
            }
            else {
                return false;
            }
        };
        NewNavigate.prototype.destroy = function () {
            if (this._mapView) {
                this._mapView.off('gestureStart', this._onMapGestureStart);
                this._mapView.off('gestureEnd', this._onMapGestureEnd);
                this._mapView.off('rotate', this._onMapRotate);
                delete this._mapView;
            }
            if (this._naviMng) {
                this._naviMng.destroy();
                delete this._naviMng;
            }
            if (this._locationMng) {
                this._locationMng.destroy();
                delete this._locationMng;
            }
            this._markerMng.destroy();
            this._audioProvider.destroy();
        };
        return NewNavigate;
    }(NCore$1));

    var LocationMgr = (function () {
        function LocationMgr() {
            this.m_serverUrl = 'https://';
            this.m_beaconJsonObj = null;
            this.m_mapBeaconList = new Map();
            this.m_envirment = 2.0;
        }
        LocationMgr.GetInstance = function () {
            if (LocationMgr.m_instance == null) {
                LocationMgr.m_instance = new LocationMgr();
                LocationMgr.m_instance.Init();
            }
            return LocationMgr.m_instance;
        };
        LocationMgr.prototype.Init = function () {
            return __awaiter(this, void 0, void 0, function () {
                var res, jsonObj;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4, new HttpClient().get(this.m_serverUrl)];
                        case 1:
                            res = _a.sent();
                            jsonObj = typeof res === 'string' ? JSON.parse(res) : res;
                            this.m_beaconJsonObj = jsonObj;
                            return [2];
                    }
                });
            });
        };
        LocationMgr.prototype.UpdateBeaconSignalPos = function (beaconSignalList) {
            if (beaconSignalList == null || beaconSignalList == undefined) {
                return;
            }
            for (var i = 0; i < beaconSignalList.length; i++) {
                var id = beaconSignalList[i].id;
                var _a = this.GetBeaconPosById(id), bFind = _a.bFind, x = _a.x, y = _a.y, floor = _a.floor;
                if (bFind) {
                    beaconSignalList[i].x = x;
                    beaconSignalList[i].y = y;
                    beaconSignalList[i].floor = floor;
                    beaconSignalList[i].dis = this.RssiToDis(beaconSignalList[i].rssi);
                }
            }
        };
        LocationMgr.prototype.RssiToDis = function (rssi) {
            return 10;
        };
        LocationMgr.prototype.FilterBeaconByFloor = function (beaconList, floor) {
            var result = new Array();
            if (beaconList == null || beaconList == undefined || beaconList.length == 0) {
                return result;
            }
            for (var i = 0; i < beaconList.length; i++) {
                if (beaconList[i].floor == floor) {
                    result.push(beaconList[i]);
                }
            }
            return result;
        };
        LocationMgr.prototype.GetUserFloorByBeaconSignalList = function (beaconList) {
            if (beaconList == null || beaconList == undefined || beaconList.length == 0) {
                return null;
            }
            var minDis = beaconList[0].dis;
            var minIndex = 0;
            for (var i = 0; i < beaconList.length; i++) {
                var beacon = beaconList[i];
                if (beacon.dis < minDis) {
                    minDis = beacon.dis;
                    minIndex = i;
                }
            }
            return beaconList[minIndex].floor;
        };
        LocationMgr.prototype.GetBeaconPosById = function (id) {
            var result = {
                bFind: false,
                x: 0,
                y: 0,
                floor: '',
            };
            if (id == null || id == undefined) {
                return result;
            }
            if (this.m_beaconJsonObj == null || this.m_beaconJsonObj == undefined) {
                return result;
            }
            var beaconInfo = this.m_mapBeaconList[id];
            if (beaconInfo == null || beaconInfo == undefined) {
                return result;
            }
            result.x = beaconInfo.x;
            result.y = beaconInfo.y;
            result.floor = beaconInfo.floor;
            return result;
        };
        LocationMgr.prototype.CalPos = function (beaconSignalList) {
            var result = {
                bSuccess: false,
                x: 0,
                y: 0,
                floor: '',
            };
            if (beaconSignalList == null || beaconSignalList == undefined) {
                return result;
            }
            this.UpdateBeaconSignalPos(beaconSignalList);
            var floor = this.GetUserFloorByBeaconSignalList(beaconSignalList);
            var curFloorBeaconSignalList = this.FilterBeaconByFloor(beaconSignalList, floor);
            var disArray = new Array();
            for (var i = 0; i < curFloorBeaconSignalList.length; i++) {
                disArray.push(curFloorBeaconSignalList[i].dis);
            }
            var pointArray = new Array();
            for (var i = 0; i < curFloorBeaconSignalList.length; i++) {
                pointArray.push(new Point(curFloorBeaconSignalList[i].x, curFloorBeaconSignalList[i].y));
            }
            var userPos = this.threePoints(disArray, pointArray);
            result.bSuccess = true;
            result.x = userPos.x;
            result.y = userPos.y;
            result.floor = floor;
            return result;
        };
        LocationMgr.prototype.onePoints = function (point) {
            return point;
        };
        LocationMgr.prototype.threePoints = function (disArray, pointArray) {
            var result = new Point(0, 0);
            if (disArray == null || disArray == undefined
                || pointArray == null || pointArray == undefined
                || disArray.length != pointArray.length
                || disArray.length == 0 || pointArray.length == 0) {
                return result;
            }
            for (var i = 0; i < disArray.length; i++) {
                if (disArray[i] < 0) {
                    return result;
                }
            }
            if (disArray.length = 1) {
                result.x = pointArray[0].x;
                result.y = pointArray[0].y;
                return result;
            }
            for (var i = 0; i < disArray.length; ++i) {
                for (var j = i + 1; j < disArray.length; ++j) {
                    var tempDis = (pointArray[i].x - pointArray[j].x) * (pointArray[i].x - pointArray[j].x) +
                        (pointArray[i].y - pointArray[j].y) * (pointArray[i].y - pointArray[j].y);
                    var p2p = Math.pow(tempDis, 0.5);
                    if (disArray[i] + disArray[j] <= p2p) {
                        result.x += pointArray[i].x + (pointArray[j].x - pointArray[i].x) * disArray[i] / (disArray[i] + disArray[j]);
                        result.y += pointArray[i].y + (pointArray[j].y - pointArray[i].y) * disArray[i] / (disArray[i] + disArray[j]);
                    }
                    else {
                        var dr = p2p / 2 + (disArray[i] * disArray[i] - disArray[j] * disArray[j]) / (2 * p2p);
                        result.x += pointArray[i].x + (pointArray[j].x - pointArray[i].x) * dr / p2p;
                        result.y += pointArray[i].y + (pointArray[j].y - pointArray[i].y) * dr / p2p;
                    }
                }
            }
            result.x /= disArray.length;
            result.y /= disArray.length;
            return result;
        };
        LocationMgr.m_instance = null;
        return LocationMgr;
    }());

    var version = "6.0.0";

    var index = {
        Map: MapView$1,
        StyleUtils: StyleUtils,
        ZoomControl: ZoomControl,
        FloorControl: FloorControl,
        CompassControl: CompassControl,
        ViewControl: ViewControl,
        ScaleControl: ScaleControl,
        LocateControl: LocateControl,
        FullscreenControl: FullscreenControl,
        Marker: Marker,
        FillLayer: FillLayer,
        FillExtrusionLayer: FillExtrusionLayer,
        SymbolLayer: SymbolLayer,
        LineLayer: LineLayer,
        TrackLayer: TrackLayer,
        ModelLayer: ModelLayer,
        CircleLayer: CircleLayer,
        PictureLayer: PictureLayer,
        HeatmapLayer: HeatmapLayer,
        ConnectionLayer: ConnectionLayer,
        TileLayer: TileLayer,
        CanvasMarker: CanvasMarker,
        LiftMarker: LiftMarker,
        Animator: Animator,
        Navigate: Navigate,
        NewNavigate: NewNavigate,
        LocationManager: LocationManager,
        TOOL: TOOL,
        UTILS: UTILS,
        Point: Point,
        language: language,
        AREA: AREA,
        HttpClient: HttpClient,
        version: version,
        Point3: Point3,
        Color: Color,
        ZoomRangeConfig: ZoomRangeConfig,
        LogMgr: LogMgr$1,
        ShadowMgr: ShadowMgr$1,
        ShadowTexture: ShadowTexture,
        OrthoShadowLight: OrthoShadowLight,
        ShadowLight: ShadowLight,
        ShadowCamera: ShadowCamera,
        ParkingMgr: ParkingMgr,
        Global: Global,
        LocationMgr: LocationMgr,
        OBJLoader: OBJLoader,
    };

    exports.AREA = AREA;
    exports.Animator = Animator;
    exports.CanvasMarker = CanvasMarker;
    exports.CircleLayer = CircleLayer;
    exports.Color = Color;
    exports.CompassControl = CompassControl;
    exports.ConnectionLayer = ConnectionLayer;
    exports.FillExtrusionLayer = FillExtrusionLayer;
    exports.FillLayer = FillLayer;
    exports.FloorControl = FloorControl;
    exports.FullscreenControl = FullscreenControl;
    exports.Global = Global;
    exports.HeatmapLayer = HeatmapLayer;
    exports.HttpClient = HttpClient;
    exports.LiftMarker = LiftMarker;
    exports.LineLayer = LineLayer;
    exports.LocateControl = LocateControl;
    exports.LocationManager = LocationManager;
    exports.LocationMgr = LocationMgr;
    exports.LogMgr = LogMgr$1;
    exports.Map = MapView$1;
    exports.Marker = Marker;
    exports.ModelLayer = ModelLayer;
    exports.Navigate = Navigate;
    exports.NewNavigate = NewNavigate;
    exports.OBJLoader = OBJLoader;
    exports.OrthoShadowLight = OrthoShadowLight;
    exports.ParkingMgr = ParkingMgr;
    exports.PictureLayer = PictureLayer;
    exports.Point = Point;
    exports.Point3 = Point3;
    exports.ScaleControl = ScaleControl;
    exports.ShadowCamera = ShadowCamera;
    exports.ShadowLight = ShadowLight;
    exports.ShadowMgr = ShadowMgr$1;
    exports.ShadowTexture = ShadowTexture;
    exports.StyleUtils = StyleUtils;
    exports.SymbolLayer = SymbolLayer;
    exports.TOOL = TOOL;
    exports.TileLayer = TileLayer;
    exports.TrackLayer = TrackLayer;
    exports.UTILS = UTILS;
    exports.ViewControl = ViewControl;
    exports.ZoomControl = ZoomControl;
    exports.ZoomRangeConfig = ZoomRangeConfig;
    exports["default"] = index;
    exports.language = language;
    exports.version = version;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
//# sourceMappingURL=palmap-map-dev.js.map
